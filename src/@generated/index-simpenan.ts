import { Field } from '@nestjs/graphql';
import { ArgsType } from '@nestjs/graphql';
import { Type } from 'class-transformer';
import { Prisma } from '@prisma/client';
import { Int } from '@nestjs/graphql';
import { InputType } from '@nestjs/graphql';
import { ObjectType } from '@nestjs/graphql';
import { Float } from '@nestjs/graphql';
import { HideField } from '@nestjs/graphql';
import * as Validator from 'class-validator';
import { registerEnumType } from '@nestjs/graphql';

export enum WithdrawalRequestScalarFieldEnum {
    id = "id",
    userId = "userId",
    amount = "amount",
    status = "status",
    proofUrl = "proofUrl",
    proofDescription = "proofDescription",
    transactionId = "transactionId",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum UserNotificationScalarFieldEnum {
    id = "id",
    title = "title",
    subtitle = "subtitle",
    content = "content",
    createdAt = "createdAt",
    category = "category",
    isRead = "isRead",
    isCleared = "isCleared",
    userId = "userId",
    deepLink = "deepLink",
    fcmToken = "fcmToken"
}

export enum UserScalarFieldEnum {
    id = "id",
    firstName = "firstName",
    lastName = "lastName",
    email = "email",
    addressId = "addressId",
    userRole = "userRole",
    userType = "userType",
    avatarUrl = "avatarUrl",
    whatsappNumber = "whatsappNumber",
    whatsappVerifiedAt = "whatsappVerifiedAt",
    password = "password",
    referralCode = "referralCode",
    referredById = "referredById",
    status = "status",
    schoolId = "schoolId",
    createdAt = "createdAt",
    updatedAt = "updatedAt",
    deletedAt = "deletedAt",
    theme = "theme"
}

export enum TransactionScalarFieldEnum {
    id = "id",
    amount = "amount",
    proofUrl = "proofUrl",
    status = "status",
    transactionCategory = "transactionCategory",
    fromAccountId = "fromAccountId",
    toAccountId = "toAccountId",
    invoiceId = "invoiceId",
    installmentId = "installmentId",
    withdrawalRequestId = "withdrawalRequestId",
    uniqueCode = "uniqueCode",
    createdAt = "createdAt"
}

export enum SubdistrictScalarFieldEnum {
    id = "id",
    name = "name",
    districtId = "districtId",
    postalCode = "postalCode"
}

export enum ShippingScalarFieldEnum {
    id = "id",
    logisticName = "logisticName",
    deliveryDate = "deliveryDate",
    shippingStatus = "shippingStatus",
    addressId = "addressId",
    courier = "courier",
    estimatedTime = "estimatedTime",
    trackingNo = "trackingNo",
    orderId = "orderId",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum SessionScalarFieldEnum {
    id = "id",
    token = "token",
    expiresAt = "expiresAt",
    createdAt = "createdAt",
    userId = "userId",
    device = "device",
    ipAddress = "ipAddress"
}

export enum SchoolScalarFieldEnum {
    id = "id",
    name = "name",
    addressId = "addressId",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum RewardClaimScalarFieldEnum {
    id = "id",
    userId = "userId",
    rewardId = "rewardId",
    processedAt = "processedAt",
    createdAt = "createdAt"
}

export enum RewardScalarFieldEnum {
    id = "id",
    name = "name",
    pointCost = "pointCost",
    description = "description",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum ProvinceScalarFieldEnum {
    id = "id",
    name = "name"
}

export enum ProjectScalarFieldEnum {
    id = "id",
    name = "name",
    description = "description",
    projectCategory = "projectCategory",
    startDate = "startDate",
    endDate = "endDate",
    returnRate = "returnRate",
    goalAmount = "goalAmount",
    minimumInvestment = "minimumInvestment",
    maxInvestor = "maxInvestor",
    accountId = "accountId",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum ProgramCategoryScalarFieldEnum {
    id = "id",
    name = "name",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum ProgramScalarFieldEnum {
    id = "id",
    name = "name",
    startDate = "startDate",
    dueDate = "dueDate",
    description = "description",
    createdById = "createdById",
    categoryId = "categoryId",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum UserType {
    PARENT = "PARENT",
    SCHOOL_HEAD = "SCHOOL_HEAD",
    STUDENT = "STUDENT",
    TEACHER = "TEACHER",
    HOUSEWIFE = "HOUSEWIFE",
    ENTREPRENEUR = "ENTREPRENEUR",
    WORKER = "WORKER",
    OTHER = "OTHER"
}

export enum UserStatus {
    ACTIVE = "ACTIVE",
    PENDING = "PENDING",
    INACTIVE = "INACTIVE"
}

export enum UserRole {
    MEMBER = "MEMBER",
    ADMIN = "ADMIN",
    SUPERUSER = "SUPERUSER",
    STUDENT = "STUDENT"
}

export enum UserNotificationCategory {
    BILLING_ALERT = "BILLING_ALERT",
    ANNOUNCEMENT = "ANNOUNCEMENT",
    CHAT_MESSAGE = "CHAT_MESSAGE"
}

export enum TransactionType {
    DEBIT = "DEBIT",
    CREDIT = "CREDIT"
}

export enum TransactionStatus {
    PROCESSING = "PROCESSING",
    PENDING = "PENDING",
    FAILED = "FAILED",
    CANCELLED = "CANCELLED",
    COMPLETED = "COMPLETED"
}

export enum TransactionIsolationLevel {
    ReadUncommitted = "ReadUncommitted",
    ReadCommitted = "ReadCommitted",
    RepeatableRead = "RepeatableRead",
    Serializable = "Serializable"
}

export enum TransactionCategory {
    INVESTMENT = "INVESTMENT",
    INVESTMENT_RETURN = "INVESTMENT_RETURN",
    COMISSION_BONUS = "COMISSION_BONUS",
    WITHDRAWAL = "WITHDRAWAL",
    MEMBER_REGISTRATION = "MEMBER_REGISTRATION",
    STUDENT_REGISTRATION = "STUDENT_REGISTRATION"
}

export enum Theme {
    LIGHT = "LIGHT",
    DARK = "DARK"
}

export enum SortOrder {
    asc = "asc",
    desc = "desc"
}

export enum ShippingStatus {
    PROCESSING = "PROCESSING",
    DELIVERING = "DELIVERING",
    DELIVERED = "DELIVERED"
}

export enum ProjectCategory {
    PROPERTY = "PROPERTY",
    BUSSINESS = "BUSSINESS"
}

export enum PointType {
    REFERRING = "REFERRING",
    REDEEMING = "REDEEMING"
}

export enum NullsOrder {
    first = "first",
    last = "last"
}

export enum InstallmentStatus {
    UPCOMING = "UPCOMING",
    PAID = "PAID"
}

export enum FileType {
    MP4 = "MP4",
    JPG = "JPG",
    PNG = "PNG",
    PDF = "PDF"
}

export enum FaqType {
    REFERRAL_PAGE = "REFERRAL_PAGE",
    DASHBOARD_PAGE = "DASHBOARD_PAGE",
    REWARD_PAGE = "REWARD_PAGE",
    PROJECT_PAGE = "PROJECT_PAGE"
}

export enum AccountCategory {
    EQUITY = "EQUITY",
    PROJECT = "PROJECT",
    COMISSION = "COMISSION",
    CASH = "CASH",
    PLATFORM = "PLATFORM",
    BANK = "BANK",
    DEBT = "DEBT"
}

export enum PointTransactionScalarFieldEnum {
    id = "id",
    amount = "amount",
    pointType = "pointType",
    transactionType = "transactionType",
    currentBalance = "currentBalance",
    userId = "userId",
    createdAt = "createdAt"
}

export enum OrderScalarFieldEnum {
    id = "id",
    status = "status",
    orderById = "orderById",
    shippingId = "shippingId",
    invoiceId = "invoiceId",
    platformFee = "platformFee",
    total = "total",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum ItemScalarFieldEnum {
    id = "id",
    name = "name",
    description = "description",
    price = "price",
    cost = "cost",
    userRole = "userRole",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum InvoiceScalarFieldEnum {
    id = "id",
    adminFee = "adminFee",
    amount = "amount",
    uniqueCode = "uniqueCode",
    createdAt = "createdAt"
}

export enum InstallmentScalarFieldEnum {
    id = "id",
    number = "number",
    lateFee = "lateFee",
    amount = "amount",
    dueDate = "dueDate",
    status = "status",
    transactionId = "transactionId",
    invoiceId = "invoiceId"
}

export enum ImagesScalarFieldEnum {
    id = "id",
    fileType = "fileType",
    filesize = "filesize",
    url = "url",
    hotelImageId = "hotelImageId",
    programImageId = "programImageId",
    rewardImageId = "rewardImageId",
    projectImageId = "projectImageId",
    createdAt = "createdAt"
}

export enum HotelScalarFieldEnum {
    id = "id",
    name = "name",
    addressId = "addressId",
    description = "description",
    rating = "rating",
    startDate = "startDate",
    quota = "quota",
    createdById = "createdById",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum FileScalarFieldEnum {
    id = "id",
    fileType = "fileType",
    filesize = "filesize",
    name = "name",
    description = "description",
    url = "url",
    createdById = "createdById",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum FaqScalarFieldEnum {
    id = "id",
    name = "name",
    description = "description",
    createdAt = "createdAt",
    updatedAt = "updatedAt",
    type = "type"
}

export enum DistrictScalarFieldEnum {
    id = "id",
    name = "name",
    cityId = "cityId"
}

export enum CityScalarFieldEnum {
    id = "id",
    name = "name",
    provinceId = "provinceId"
}

export enum CheckInScalarFieldEnum {
    id = "id",
    userId = "userId",
    hotelId = "hotelId",
    checkInAt = "checkInAt",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum CartScalarFieldEnum {
    id = "id",
    orderId = "orderId",
    membershipItemId = "membershipItemId",
    projectItemId = "projectItemId",
    quantity = "quantity",
    price = "price",
    cost = "cost",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum BankScalarFieldEnum {
    id = "id",
    name = "name",
    logoUrl = "logoUrl",
    accountNumber = "accountNumber",
    accountId = "accountId"
}

export enum AddressScalarFieldEnum {
    id = "id",
    name = "name",
    subdistrictId = "subdistrictId",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}

export enum AccountScalarFieldEnum {
    id = "id",
    accountNumber = "accountNumber",
    name = "name",
    createdAt = "createdAt",
    updatedAt = "updatedAt",
    userId = "userId",
    accountCategory = "accountCategory"
}

registerEnumType(AccountScalarFieldEnum, { name: 'AccountScalarFieldEnum', description: undefined })
registerEnumType(AddressScalarFieldEnum, { name: 'AddressScalarFieldEnum', description: undefined })
registerEnumType(BankScalarFieldEnum, { name: 'BankScalarFieldEnum', description: undefined })
registerEnumType(CartScalarFieldEnum, { name: 'CartScalarFieldEnum', description: undefined })
registerEnumType(CheckInScalarFieldEnum, { name: 'CheckInScalarFieldEnum', description: undefined })
registerEnumType(CityScalarFieldEnum, { name: 'CityScalarFieldEnum', description: undefined })
registerEnumType(DistrictScalarFieldEnum, { name: 'DistrictScalarFieldEnum', description: undefined })
registerEnumType(FaqScalarFieldEnum, { name: 'FaqScalarFieldEnum', description: undefined })
registerEnumType(FileScalarFieldEnum, { name: 'FileScalarFieldEnum', description: undefined })
registerEnumType(HotelScalarFieldEnum, { name: 'HotelScalarFieldEnum', description: undefined })
registerEnumType(ImagesScalarFieldEnum, { name: 'ImagesScalarFieldEnum', description: undefined })
registerEnumType(InstallmentScalarFieldEnum, { name: 'InstallmentScalarFieldEnum', description: undefined })
registerEnumType(InvoiceScalarFieldEnum, { name: 'InvoiceScalarFieldEnum', description: undefined })
registerEnumType(ItemScalarFieldEnum, { name: 'ItemScalarFieldEnum', description: undefined })
registerEnumType(OrderScalarFieldEnum, { name: 'OrderScalarFieldEnum', description: undefined })
registerEnumType(PointTransactionScalarFieldEnum, { name: 'PointTransactionScalarFieldEnum', description: undefined })
registerEnumType(AccountCategory, { name: 'AccountCategory', description: undefined })
registerEnumType(FaqType, { name: 'FaqType', description: undefined })
registerEnumType(FileType, { name: 'FileType', description: undefined })
registerEnumType(InstallmentStatus, { name: 'InstallmentStatus', description: undefined })
registerEnumType(NullsOrder, { name: 'NullsOrder', description: undefined })
registerEnumType(PointType, { name: 'PointType', description: undefined })
registerEnumType(ProjectCategory, { name: 'ProjectCategory', description: undefined })
registerEnumType(ShippingStatus, { name: 'ShippingStatus', description: undefined })
registerEnumType(SortOrder, { name: 'SortOrder', description: undefined })
registerEnumType(Theme, { name: 'Theme', description: undefined })
registerEnumType(TransactionCategory, { name: 'TransactionCategory', description: undefined })
registerEnumType(TransactionIsolationLevel, { name: 'TransactionIsolationLevel', description: undefined })
registerEnumType(TransactionStatus, { name: 'TransactionStatus', description: undefined })
registerEnumType(TransactionType, { name: 'TransactionType', description: undefined })
registerEnumType(UserNotificationCategory, { name: 'UserNotificationCategory', description: undefined })
registerEnumType(UserRole, { name: 'UserRole', description: undefined })
registerEnumType(UserStatus, { name: 'UserStatus', description: undefined })
registerEnumType(UserType, { name: 'UserType', description: undefined })
registerEnumType(ProgramScalarFieldEnum, { name: 'ProgramScalarFieldEnum', description: undefined })
registerEnumType(ProgramCategoryScalarFieldEnum, { name: 'ProgramCategoryScalarFieldEnum', description: undefined })
registerEnumType(ProjectScalarFieldEnum, { name: 'ProjectScalarFieldEnum', description: undefined })
registerEnumType(ProvinceScalarFieldEnum, { name: 'ProvinceScalarFieldEnum', description: undefined })
registerEnumType(RewardScalarFieldEnum, { name: 'RewardScalarFieldEnum', description: undefined })
registerEnumType(RewardClaimScalarFieldEnum, { name: 'RewardClaimScalarFieldEnum', description: undefined })
registerEnumType(SchoolScalarFieldEnum, { name: 'SchoolScalarFieldEnum', description: undefined })
registerEnumType(SessionScalarFieldEnum, { name: 'SessionScalarFieldEnum', description: undefined })
registerEnumType(ShippingScalarFieldEnum, { name: 'ShippingScalarFieldEnum', description: undefined })
registerEnumType(SubdistrictScalarFieldEnum, { name: 'SubdistrictScalarFieldEnum', description: undefined })
registerEnumType(TransactionScalarFieldEnum, { name: 'TransactionScalarFieldEnum', description: undefined })
registerEnumType(UserScalarFieldEnum, { name: 'UserScalarFieldEnum', description: undefined })
registerEnumType(UserNotificationScalarFieldEnum, { name: 'UserNotificationScalarFieldEnum', description: undefined })
registerEnumType(WithdrawalRequestScalarFieldEnum, { name: 'WithdrawalRequestScalarFieldEnum', description: undefined })

@ArgsType()
export class AccountAggregateArgs {
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
    @Field(() => [AccountOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<AccountOrderByWithRelationInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => AccountCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof AccountCountAggregateInput>;
    @Field(() => AccountAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof AccountAvgAggregateInput>;
    @Field(() => AccountSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof AccountSumAggregateInput>;
    @Field(() => AccountMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof AccountMinAggregateInput>;
    @Field(() => AccountMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof AccountMaxAggregateInput>;
}

@InputType()
export class AccountAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
}

@ObjectType()
export class AccountAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
}

@InputType()
export class AccountAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
}

@InputType()
export class AccountCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @HideField()
    createdAt?: true;
    @HideField()
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    accountCategory?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class AccountCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    accountNumber!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    userId!: number;
    @Field(() => Int, {nullable:false})
    accountCategory!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class AccountCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountCategory?: keyof typeof SortOrder;
}

@ObjectType()
export class AccountCount {
    @Field(() => Int, {nullable:false})
    transactionOrigins?: number;
    @Field(() => Int, {nullable:false})
    transactionDestination?: number;
}

@InputType()
export class AccountCreateManyUserInputEnvelope {
    @Field(() => [AccountCreateManyUserInput], {nullable:false})
    @Type(() => AccountCreateManyUserInput)
    data!: Array<AccountCreateManyUserInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class AccountCreateManyUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
}

@InputType()
export class AccountCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
}

@InputType()
export class AccountCreateNestedManyWithoutUserInput {
    @Field(() => [AccountCreateWithoutUserInput], {nullable:true})
    @Type(() => AccountCreateWithoutUserInput)
    create?: Array<AccountCreateWithoutUserInput>;
    @Field(() => [AccountCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<AccountCreateOrConnectWithoutUserInput>;
    @Field(() => AccountCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => AccountCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof AccountCreateManyUserInputEnvelope>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
}

@InputType()
export class AccountCreateNestedOneWithoutBankAccountInput {
    @Field(() => AccountCreateWithoutBankAccountInput, {nullable:true})
    @Type(() => AccountCreateWithoutBankAccountInput)
    create?: InstanceType<typeof AccountCreateWithoutBankAccountInput>;
    @Field(() => AccountCreateOrConnectWithoutBankAccountInput, {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutBankAccountInput)
    connectOrCreate?: InstanceType<typeof AccountCreateOrConnectWithoutBankAccountInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
}

@InputType()
export class AccountCreateNestedOneWithoutProjectInput {
    @Field(() => AccountCreateWithoutProjectInput, {nullable:true})
    @Type(() => AccountCreateWithoutProjectInput)
    create?: InstanceType<typeof AccountCreateWithoutProjectInput>;
    @Field(() => AccountCreateOrConnectWithoutProjectInput, {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutProjectInput)
    connectOrCreate?: InstanceType<typeof AccountCreateOrConnectWithoutProjectInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
}

@InputType()
export class AccountCreateNestedOneWithoutTransactionDestinationInput {
    @Field(() => AccountCreateWithoutTransactionDestinationInput, {nullable:true})
    @Type(() => AccountCreateWithoutTransactionDestinationInput)
    create?: InstanceType<typeof AccountCreateWithoutTransactionDestinationInput>;
    @Field(() => AccountCreateOrConnectWithoutTransactionDestinationInput, {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutTransactionDestinationInput)
    connectOrCreate?: InstanceType<typeof AccountCreateOrConnectWithoutTransactionDestinationInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
}

@InputType()
export class AccountCreateNestedOneWithoutTransactionOriginsInput {
    @Field(() => AccountCreateWithoutTransactionOriginsInput, {nullable:true})
    @Type(() => AccountCreateWithoutTransactionOriginsInput)
    create?: InstanceType<typeof AccountCreateWithoutTransactionOriginsInput>;
    @Field(() => AccountCreateOrConnectWithoutTransactionOriginsInput, {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutTransactionOriginsInput)
    connectOrCreate?: InstanceType<typeof AccountCreateOrConnectWithoutTransactionOriginsInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
}

@InputType()
export class AccountCreateOrConnectWithoutBankAccountInput {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountCreateWithoutBankAccountInput, {nullable:false})
    @Type(() => AccountCreateWithoutBankAccountInput)
    create!: InstanceType<typeof AccountCreateWithoutBankAccountInput>;
}

@InputType()
export class AccountCreateOrConnectWithoutProjectInput {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountCreateWithoutProjectInput, {nullable:false})
    @Type(() => AccountCreateWithoutProjectInput)
    create!: InstanceType<typeof AccountCreateWithoutProjectInput>;
}

@InputType()
export class AccountCreateOrConnectWithoutTransactionDestinationInput {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountCreateWithoutTransactionDestinationInput, {nullable:false})
    @Type(() => AccountCreateWithoutTransactionDestinationInput)
    create!: InstanceType<typeof AccountCreateWithoutTransactionDestinationInput>;
}

@InputType()
export class AccountCreateOrConnectWithoutTransactionOriginsInput {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountCreateWithoutTransactionOriginsInput, {nullable:false})
    @Type(() => AccountCreateWithoutTransactionOriginsInput)
    create!: InstanceType<typeof AccountCreateWithoutTransactionOriginsInput>;
}

@InputType()
export class AccountCreateOrConnectWithoutUserInput {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountCreateWithoutUserInput, {nullable:false})
    @Type(() => AccountCreateWithoutUserInput)
    create!: InstanceType<typeof AccountCreateWithoutUserInput>;
}

@InputType()
export class AccountCreateWithoutBankAccountInput {
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => UserCreateNestedOneWithoutAccountsInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutAccountsInput>;
    @HideField()
    transactionOrigins?: InstanceType<typeof TransactionCreateNestedManyWithoutFromAccountInput>;
    @HideField()
    transactionDestination?: InstanceType<typeof TransactionCreateNestedManyWithoutToAccountInput>;
    @HideField()
    project?: InstanceType<typeof ProjectCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountCreateWithoutProjectInput {
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => UserCreateNestedOneWithoutAccountsInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutAccountsInput>;
    @HideField()
    transactionOrigins?: InstanceType<typeof TransactionCreateNestedManyWithoutFromAccountInput>;
    @HideField()
    transactionDestination?: InstanceType<typeof TransactionCreateNestedManyWithoutToAccountInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountCreateWithoutTransactionDestinationInput {
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => UserCreateNestedOneWithoutAccountsInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutAccountsInput>;
    @HideField()
    transactionOrigins?: InstanceType<typeof TransactionCreateNestedManyWithoutFromAccountInput>;
    @HideField()
    project?: InstanceType<typeof ProjectCreateNestedOneWithoutAccountInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountCreateWithoutTransactionOriginsInput {
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => UserCreateNestedOneWithoutAccountsInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutAccountsInput>;
    @HideField()
    transactionDestination?: InstanceType<typeof TransactionCreateNestedManyWithoutToAccountInput>;
    @HideField()
    project?: InstanceType<typeof ProjectCreateNestedOneWithoutAccountInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountCreateWithoutUserInput {
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @HideField()
    transactionOrigins?: InstanceType<typeof TransactionCreateNestedManyWithoutFromAccountInput>;
    @HideField()
    transactionDestination?: InstanceType<typeof TransactionCreateNestedManyWithoutToAccountInput>;
    @HideField()
    project?: InstanceType<typeof ProjectCreateNestedOneWithoutAccountInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountCreateInput {
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => UserCreateNestedOneWithoutAccountsInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutAccountsInput>;
    @HideField()
    transactionOrigins?: InstanceType<typeof TransactionCreateNestedManyWithoutFromAccountInput>;
    @HideField()
    transactionDestination?: InstanceType<typeof TransactionCreateNestedManyWithoutToAccountInput>;
    @HideField()
    project?: InstanceType<typeof ProjectCreateNestedOneWithoutAccountInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankCreateNestedOneWithoutAccountInput>;
}

@ArgsType()
export class AccountGroupByArgs {
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
    @Field(() => [AccountOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<AccountOrderByWithAggregationInput>;
    @Field(() => [AccountScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof AccountScalarFieldEnum>;
    @Field(() => AccountScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof AccountScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => AccountCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof AccountCountAggregateInput>;
    @Field(() => AccountAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof AccountAvgAggregateInput>;
    @Field(() => AccountSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof AccountSumAggregateInput>;
    @Field(() => AccountMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof AccountMinAggregateInput>;
    @Field(() => AccountMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof AccountMaxAggregateInput>;
}

@ObjectType()
export class AccountGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => AccountCountAggregate, {nullable:true})
    _count?: InstanceType<typeof AccountCountAggregate>;
    @Field(() => AccountAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof AccountAvgAggregate>;
    @Field(() => AccountSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof AccountSumAggregate>;
    @Field(() => AccountMinAggregate, {nullable:true})
    _min?: InstanceType<typeof AccountMinAggregate>;
    @Field(() => AccountMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof AccountMaxAggregate>;
}

@InputType()
export class AccountListRelationFilter {
    @Field(() => AccountWhereInput, {nullable:true})
    every?: InstanceType<typeof AccountWhereInput>;
    @Field(() => AccountWhereInput, {nullable:true})
    some?: InstanceType<typeof AccountWhereInput>;
    @Field(() => AccountWhereInput, {nullable:true})
    none?: InstanceType<typeof AccountWhereInput>;
}

@InputType()
export class AccountMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @HideField()
    createdAt?: true;
    @HideField()
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    accountCategory?: true;
}

@ObjectType()
export class AccountMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => AccountCategory, {nullable:true})
    accountCategory?: keyof typeof AccountCategory;
}

@InputType()
export class AccountMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountCategory?: keyof typeof SortOrder;
}

@InputType()
export class AccountMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @HideField()
    createdAt?: true;
    @HideField()
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    accountCategory?: true;
}

@ObjectType()
export class AccountMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => AccountCategory, {nullable:true})
    accountCategory?: keyof typeof AccountCategory;
}

@InputType()
export class AccountMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountCategory?: keyof typeof SortOrder;
}

@InputType()
export class AccountOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class AccountOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    accountNumber?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountCategory?: keyof typeof SortOrder;
    @Field(() => AccountCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof AccountCountOrderByAggregateInput>;
    @Field(() => AccountAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof AccountAvgOrderByAggregateInput>;
    @Field(() => AccountMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof AccountMaxOrderByAggregateInput>;
    @Field(() => AccountMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof AccountMinOrderByAggregateInput>;
    @Field(() => AccountSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof AccountSumOrderByAggregateInput>;
}

@InputType()
export class AccountOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    accountNumber?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountCategory?: keyof typeof SortOrder;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    user?: InstanceType<typeof UserOrderByWithRelationInput>;
    @Field(() => TransactionOrderByRelationAggregateInput, {nullable:true})
    transactionOrigins?: InstanceType<typeof TransactionOrderByRelationAggregateInput>;
    @Field(() => TransactionOrderByRelationAggregateInput, {nullable:true})
    transactionDestination?: InstanceType<typeof TransactionOrderByRelationAggregateInput>;
    @HideField()
    project?: InstanceType<typeof ProjectOrderByWithRelationInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankOrderByWithRelationInput>;
}

@InputType()
export class AccountRelationFilter {
    @Field(() => AccountWhereInput, {nullable:true})
    is?: InstanceType<typeof AccountWhereInput>;
    @Field(() => AccountWhereInput, {nullable:true})
    isNot?: InstanceType<typeof AccountWhereInput>;
}

@InputType()
export class AccountScalarWhereWithAggregatesInput {
    @Field(() => [AccountScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<AccountScalarWhereWithAggregatesInput>;
    @Field(() => [AccountScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<AccountScalarWhereWithAggregatesInput>;
    @Field(() => [AccountScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<AccountScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => FloatNullableWithAggregatesFilter, {nullable:true})
    accountNumber?: InstanceType<typeof FloatNullableWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    userId?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => EnumAccountCategoryWithAggregatesFilter, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryWithAggregatesFilter>;
}

@InputType()
export class AccountScalarWhereInput {
    @Field(() => [AccountScalarWhereInput], {nullable:true})
    AND?: Array<AccountScalarWhereInput>;
    @Field(() => [AccountScalarWhereInput], {nullable:true})
    OR?: Array<AccountScalarWhereInput>;
    @Field(() => [AccountScalarWhereInput], {nullable:true})
    NOT?: Array<AccountScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => FloatNullableFilter, {nullable:true})
    accountNumber?: InstanceType<typeof FloatNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => EnumAccountCategoryFilter, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFilter>;
}

@InputType()
export class AccountSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
}

@ObjectType()
export class AccountSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
}

@InputType()
export class AccountSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
}

@InputType()
export class AccountUncheckedCreateNestedManyWithoutUserInput {
    @Field(() => [AccountCreateWithoutUserInput], {nullable:true})
    @Type(() => AccountCreateWithoutUserInput)
    create?: Array<AccountCreateWithoutUserInput>;
    @Field(() => [AccountCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<AccountCreateOrConnectWithoutUserInput>;
    @Field(() => AccountCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => AccountCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof AccountCreateManyUserInputEnvelope>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
}

@InputType()
export class AccountUncheckedCreateWithoutBankAccountInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => TransactionUncheckedCreateNestedManyWithoutFromAccountInput, {nullable:true})
    transactionOrigins?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutFromAccountInput>;
    @Field(() => TransactionUncheckedCreateNestedManyWithoutToAccountInput, {nullable:true})
    transactionDestination?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutToAccountInput>;
    @HideField()
    project?: InstanceType<typeof ProjectUncheckedCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountUncheckedCreateWithoutProjectInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => TransactionUncheckedCreateNestedManyWithoutFromAccountInput, {nullable:true})
    transactionOrigins?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutFromAccountInput>;
    @Field(() => TransactionUncheckedCreateNestedManyWithoutToAccountInput, {nullable:true})
    transactionDestination?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutToAccountInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankUncheckedCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountUncheckedCreateWithoutTransactionDestinationInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => TransactionUncheckedCreateNestedManyWithoutFromAccountInput, {nullable:true})
    transactionOrigins?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutFromAccountInput>;
    @HideField()
    project?: InstanceType<typeof ProjectUncheckedCreateNestedOneWithoutAccountInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankUncheckedCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountUncheckedCreateWithoutTransactionOriginsInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => TransactionUncheckedCreateNestedManyWithoutToAccountInput, {nullable:true})
    transactionDestination?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutToAccountInput>;
    @HideField()
    project?: InstanceType<typeof ProjectUncheckedCreateNestedOneWithoutAccountInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankUncheckedCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountUncheckedCreateWithoutUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => TransactionUncheckedCreateNestedManyWithoutFromAccountInput, {nullable:true})
    transactionOrigins?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutFromAccountInput>;
    @Field(() => TransactionUncheckedCreateNestedManyWithoutToAccountInput, {nullable:true})
    transactionDestination?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutToAccountInput>;
    @HideField()
    project?: InstanceType<typeof ProjectUncheckedCreateNestedOneWithoutAccountInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankUncheckedCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => TransactionUncheckedCreateNestedManyWithoutFromAccountInput, {nullable:true})
    transactionOrigins?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutFromAccountInput>;
    @Field(() => TransactionUncheckedCreateNestedManyWithoutToAccountInput, {nullable:true})
    transactionDestination?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutToAccountInput>;
    @HideField()
    project?: InstanceType<typeof ProjectUncheckedCreateNestedOneWithoutAccountInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankUncheckedCreateNestedOneWithoutAccountInput>;
}

@InputType()
export class AccountUncheckedUpdateManyWithoutUserNestedInput {
    @Field(() => [AccountCreateWithoutUserInput], {nullable:true})
    @Type(() => AccountCreateWithoutUserInput)
    create?: Array<AccountCreateWithoutUserInput>;
    @Field(() => [AccountCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<AccountCreateOrConnectWithoutUserInput>;
    @Field(() => [AccountUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => AccountUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<AccountUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => AccountCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => AccountCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof AccountCreateManyUserInputEnvelope>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    set?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
    @Field(() => [AccountUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => AccountUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<AccountUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [AccountUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => AccountUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<AccountUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [AccountScalarWhereInput], {nullable:true})
    @Type(() => AccountScalarWhereInput)
    deleteMany?: Array<AccountScalarWhereInput>;
}

@InputType()
export class AccountUncheckedUpdateManyWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableFloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableFloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
}

@InputType()
export class AccountUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableFloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableFloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
}

@InputType()
export class AccountUncheckedUpdateWithoutBankAccountInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableFloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableFloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => TransactionUncheckedUpdateManyWithoutFromAccountNestedInput, {nullable:true})
    transactionOrigins?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutFromAccountNestedInput>;
    @Field(() => TransactionUncheckedUpdateManyWithoutToAccountNestedInput, {nullable:true})
    transactionDestination?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutToAccountNestedInput>;
    @HideField()
    project?: InstanceType<typeof ProjectUncheckedUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUncheckedUpdateWithoutProjectInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableFloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableFloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => TransactionUncheckedUpdateManyWithoutFromAccountNestedInput, {nullable:true})
    transactionOrigins?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutFromAccountNestedInput>;
    @Field(() => TransactionUncheckedUpdateManyWithoutToAccountNestedInput, {nullable:true})
    transactionDestination?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutToAccountNestedInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankUncheckedUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUncheckedUpdateWithoutTransactionDestinationInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableFloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableFloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => TransactionUncheckedUpdateManyWithoutFromAccountNestedInput, {nullable:true})
    transactionOrigins?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutFromAccountNestedInput>;
    @HideField()
    project?: InstanceType<typeof ProjectUncheckedUpdateOneWithoutAccountNestedInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankUncheckedUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUncheckedUpdateWithoutTransactionOriginsInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableFloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableFloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => TransactionUncheckedUpdateManyWithoutToAccountNestedInput, {nullable:true})
    transactionDestination?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutToAccountNestedInput>;
    @HideField()
    project?: InstanceType<typeof ProjectUncheckedUpdateOneWithoutAccountNestedInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankUncheckedUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUncheckedUpdateWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableFloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableFloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => TransactionUncheckedUpdateManyWithoutFromAccountNestedInput, {nullable:true})
    transactionOrigins?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutFromAccountNestedInput>;
    @Field(() => TransactionUncheckedUpdateManyWithoutToAccountNestedInput, {nullable:true})
    transactionDestination?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutToAccountNestedInput>;
    @HideField()
    project?: InstanceType<typeof ProjectUncheckedUpdateOneWithoutAccountNestedInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankUncheckedUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableFloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableFloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => TransactionUncheckedUpdateManyWithoutFromAccountNestedInput, {nullable:true})
    transactionOrigins?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutFromAccountNestedInput>;
    @Field(() => TransactionUncheckedUpdateManyWithoutToAccountNestedInput, {nullable:true})
    transactionDestination?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutToAccountNestedInput>;
    @HideField()
    project?: InstanceType<typeof ProjectUncheckedUpdateOneWithoutAccountNestedInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankUncheckedUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUpdateManyMutationInput {
    @Field(() => NullableFloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableFloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
}

@InputType()
export class AccountUpdateManyWithWhereWithoutUserInput {
    @Field(() => AccountScalarWhereInput, {nullable:false})
    @Type(() => AccountScalarWhereInput)
    where!: InstanceType<typeof AccountScalarWhereInput>;
    @Field(() => AccountUpdateManyMutationInput, {nullable:false})
    @Type(() => AccountUpdateManyMutationInput)
    data!: InstanceType<typeof AccountUpdateManyMutationInput>;
}

@InputType()
export class AccountUpdateManyWithoutUserNestedInput {
    @Field(() => [AccountCreateWithoutUserInput], {nullable:true})
    @Type(() => AccountCreateWithoutUserInput)
    create?: Array<AccountCreateWithoutUserInput>;
    @Field(() => [AccountCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<AccountCreateOrConnectWithoutUserInput>;
    @Field(() => [AccountUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => AccountUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<AccountUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => AccountCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => AccountCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof AccountCreateManyUserInputEnvelope>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    set?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
    @Field(() => [AccountWhereUniqueInput], {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AccountWhereUniqueInput, 'id'>>;
    @Field(() => [AccountUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => AccountUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<AccountUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [AccountUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => AccountUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<AccountUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [AccountScalarWhereInput], {nullable:true})
    @Type(() => AccountScalarWhereInput)
    deleteMany?: Array<AccountScalarWhereInput>;
}

@InputType()
export class AccountUpdateOneRequiredWithoutBankAccountNestedInput {
    @Field(() => AccountCreateWithoutBankAccountInput, {nullable:true})
    @Type(() => AccountCreateWithoutBankAccountInput)
    create?: InstanceType<typeof AccountCreateWithoutBankAccountInput>;
    @Field(() => AccountCreateOrConnectWithoutBankAccountInput, {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutBankAccountInput)
    connectOrCreate?: InstanceType<typeof AccountCreateOrConnectWithoutBankAccountInput>;
    @Field(() => AccountUpsertWithoutBankAccountInput, {nullable:true})
    @Type(() => AccountUpsertWithoutBankAccountInput)
    upsert?: InstanceType<typeof AccountUpsertWithoutBankAccountInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountUpdateToOneWithWhereWithoutBankAccountInput, {nullable:true})
    @Type(() => AccountUpdateToOneWithWhereWithoutBankAccountInput)
    update?: InstanceType<typeof AccountUpdateToOneWithWhereWithoutBankAccountInput>;
}

@InputType()
export class AccountUpdateOneRequiredWithoutProjectNestedInput {
    @Field(() => AccountCreateWithoutProjectInput, {nullable:true})
    @Type(() => AccountCreateWithoutProjectInput)
    create?: InstanceType<typeof AccountCreateWithoutProjectInput>;
    @Field(() => AccountCreateOrConnectWithoutProjectInput, {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutProjectInput)
    connectOrCreate?: InstanceType<typeof AccountCreateOrConnectWithoutProjectInput>;
    @Field(() => AccountUpsertWithoutProjectInput, {nullable:true})
    @Type(() => AccountUpsertWithoutProjectInput)
    upsert?: InstanceType<typeof AccountUpsertWithoutProjectInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountUpdateToOneWithWhereWithoutProjectInput, {nullable:true})
    @Type(() => AccountUpdateToOneWithWhereWithoutProjectInput)
    update?: InstanceType<typeof AccountUpdateToOneWithWhereWithoutProjectInput>;
}

@InputType()
export class AccountUpdateOneRequiredWithoutTransactionDestinationNestedInput {
    @Field(() => AccountCreateWithoutTransactionDestinationInput, {nullable:true})
    @Type(() => AccountCreateWithoutTransactionDestinationInput)
    create?: InstanceType<typeof AccountCreateWithoutTransactionDestinationInput>;
    @Field(() => AccountCreateOrConnectWithoutTransactionDestinationInput, {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutTransactionDestinationInput)
    connectOrCreate?: InstanceType<typeof AccountCreateOrConnectWithoutTransactionDestinationInput>;
    @Field(() => AccountUpsertWithoutTransactionDestinationInput, {nullable:true})
    @Type(() => AccountUpsertWithoutTransactionDestinationInput)
    upsert?: InstanceType<typeof AccountUpsertWithoutTransactionDestinationInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountUpdateToOneWithWhereWithoutTransactionDestinationInput, {nullable:true})
    @Type(() => AccountUpdateToOneWithWhereWithoutTransactionDestinationInput)
    update?: InstanceType<typeof AccountUpdateToOneWithWhereWithoutTransactionDestinationInput>;
}

@InputType()
export class AccountUpdateOneRequiredWithoutTransactionOriginsNestedInput {
    @Field(() => AccountCreateWithoutTransactionOriginsInput, {nullable:true})
    @Type(() => AccountCreateWithoutTransactionOriginsInput)
    create?: InstanceType<typeof AccountCreateWithoutTransactionOriginsInput>;
    @Field(() => AccountCreateOrConnectWithoutTransactionOriginsInput, {nullable:true})
    @Type(() => AccountCreateOrConnectWithoutTransactionOriginsInput)
    connectOrCreate?: InstanceType<typeof AccountCreateOrConnectWithoutTransactionOriginsInput>;
    @Field(() => AccountUpsertWithoutTransactionOriginsInput, {nullable:true})
    @Type(() => AccountUpsertWithoutTransactionOriginsInput)
    upsert?: InstanceType<typeof AccountUpsertWithoutTransactionOriginsInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    @Type(() => AccountWhereUniqueInput)
    connect?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountUpdateToOneWithWhereWithoutTransactionOriginsInput, {nullable:true})
    @Type(() => AccountUpdateToOneWithWhereWithoutTransactionOriginsInput)
    update?: InstanceType<typeof AccountUpdateToOneWithWhereWithoutTransactionOriginsInput>;
}

@InputType()
export class AccountUpdateToOneWithWhereWithoutBankAccountInput {
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
    @Field(() => AccountUpdateWithoutBankAccountInput, {nullable:false})
    @Type(() => AccountUpdateWithoutBankAccountInput)
    data!: InstanceType<typeof AccountUpdateWithoutBankAccountInput>;
}

@InputType()
export class AccountUpdateToOneWithWhereWithoutProjectInput {
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
    @Field(() => AccountUpdateWithoutProjectInput, {nullable:false})
    @Type(() => AccountUpdateWithoutProjectInput)
    data!: InstanceType<typeof AccountUpdateWithoutProjectInput>;
}

@InputType()
export class AccountUpdateToOneWithWhereWithoutTransactionDestinationInput {
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
    @Field(() => AccountUpdateWithoutTransactionDestinationInput, {nullable:false})
    @Type(() => AccountUpdateWithoutTransactionDestinationInput)
    data!: InstanceType<typeof AccountUpdateWithoutTransactionDestinationInput>;
}

@InputType()
export class AccountUpdateToOneWithWhereWithoutTransactionOriginsInput {
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
    @Field(() => AccountUpdateWithoutTransactionOriginsInput, {nullable:false})
    @Type(() => AccountUpdateWithoutTransactionOriginsInput)
    data!: InstanceType<typeof AccountUpdateWithoutTransactionOriginsInput>;
}

@InputType()
export class AccountUpdateWithWhereUniqueWithoutUserInput {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountUpdateWithoutUserInput, {nullable:false})
    @Type(() => AccountUpdateWithoutUserInput)
    data!: InstanceType<typeof AccountUpdateWithoutUserInput>;
}

@InputType()
export class AccountUpdateWithoutBankAccountInput {
    @Field(() => NullableFloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableFloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutAccountsNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutAccountsNestedInput>;
    @Field(() => TransactionUpdateManyWithoutFromAccountNestedInput, {nullable:true})
    transactionOrigins?: InstanceType<typeof TransactionUpdateManyWithoutFromAccountNestedInput>;
    @Field(() => TransactionUpdateManyWithoutToAccountNestedInput, {nullable:true})
    transactionDestination?: InstanceType<typeof TransactionUpdateManyWithoutToAccountNestedInput>;
    @HideField()
    project?: InstanceType<typeof ProjectUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUpdateWithoutProjectInput {
    @Field(() => NullableFloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableFloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutAccountsNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutAccountsNestedInput>;
    @Field(() => TransactionUpdateManyWithoutFromAccountNestedInput, {nullable:true})
    transactionOrigins?: InstanceType<typeof TransactionUpdateManyWithoutFromAccountNestedInput>;
    @Field(() => TransactionUpdateManyWithoutToAccountNestedInput, {nullable:true})
    transactionDestination?: InstanceType<typeof TransactionUpdateManyWithoutToAccountNestedInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUpdateWithoutTransactionDestinationInput {
    @Field(() => NullableFloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableFloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutAccountsNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutAccountsNestedInput>;
    @Field(() => TransactionUpdateManyWithoutFromAccountNestedInput, {nullable:true})
    transactionOrigins?: InstanceType<typeof TransactionUpdateManyWithoutFromAccountNestedInput>;
    @HideField()
    project?: InstanceType<typeof ProjectUpdateOneWithoutAccountNestedInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUpdateWithoutTransactionOriginsInput {
    @Field(() => NullableFloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableFloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutAccountsNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutAccountsNestedInput>;
    @Field(() => TransactionUpdateManyWithoutToAccountNestedInput, {nullable:true})
    transactionDestination?: InstanceType<typeof TransactionUpdateManyWithoutToAccountNestedInput>;
    @HideField()
    project?: InstanceType<typeof ProjectUpdateOneWithoutAccountNestedInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUpdateWithoutUserInput {
    @Field(() => NullableFloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableFloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => TransactionUpdateManyWithoutFromAccountNestedInput, {nullable:true})
    transactionOrigins?: InstanceType<typeof TransactionUpdateManyWithoutFromAccountNestedInput>;
    @Field(() => TransactionUpdateManyWithoutToAccountNestedInput, {nullable:true})
    transactionDestination?: InstanceType<typeof TransactionUpdateManyWithoutToAccountNestedInput>;
    @HideField()
    project?: InstanceType<typeof ProjectUpdateOneWithoutAccountNestedInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUpdateInput {
    @Field(() => NullableFloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof NullableFloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumAccountCategoryFieldUpdateOperationsInput, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutAccountsNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutAccountsNestedInput>;
    @Field(() => TransactionUpdateManyWithoutFromAccountNestedInput, {nullable:true})
    transactionOrigins?: InstanceType<typeof TransactionUpdateManyWithoutFromAccountNestedInput>;
    @Field(() => TransactionUpdateManyWithoutToAccountNestedInput, {nullable:true})
    transactionDestination?: InstanceType<typeof TransactionUpdateManyWithoutToAccountNestedInput>;
    @HideField()
    project?: InstanceType<typeof ProjectUpdateOneWithoutAccountNestedInput>;
    @HideField()
    bankAccount?: InstanceType<typeof BankUpdateOneWithoutAccountNestedInput>;
}

@InputType()
export class AccountUpsertWithWhereUniqueWithoutUserInput {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountUpdateWithoutUserInput, {nullable:false})
    @Type(() => AccountUpdateWithoutUserInput)
    update!: InstanceType<typeof AccountUpdateWithoutUserInput>;
    @Field(() => AccountCreateWithoutUserInput, {nullable:false})
    @Type(() => AccountCreateWithoutUserInput)
    create!: InstanceType<typeof AccountCreateWithoutUserInput>;
}

@InputType()
export class AccountUpsertWithoutBankAccountInput {
    @Field(() => AccountUpdateWithoutBankAccountInput, {nullable:false})
    @Type(() => AccountUpdateWithoutBankAccountInput)
    update!: InstanceType<typeof AccountUpdateWithoutBankAccountInput>;
    @Field(() => AccountCreateWithoutBankAccountInput, {nullable:false})
    @Type(() => AccountCreateWithoutBankAccountInput)
    create!: InstanceType<typeof AccountCreateWithoutBankAccountInput>;
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
}

@InputType()
export class AccountUpsertWithoutProjectInput {
    @Field(() => AccountUpdateWithoutProjectInput, {nullable:false})
    @Type(() => AccountUpdateWithoutProjectInput)
    update!: InstanceType<typeof AccountUpdateWithoutProjectInput>;
    @Field(() => AccountCreateWithoutProjectInput, {nullable:false})
    @Type(() => AccountCreateWithoutProjectInput)
    create!: InstanceType<typeof AccountCreateWithoutProjectInput>;
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
}

@InputType()
export class AccountUpsertWithoutTransactionDestinationInput {
    @Field(() => AccountUpdateWithoutTransactionDestinationInput, {nullable:false})
    @Type(() => AccountUpdateWithoutTransactionDestinationInput)
    update!: InstanceType<typeof AccountUpdateWithoutTransactionDestinationInput>;
    @Field(() => AccountCreateWithoutTransactionDestinationInput, {nullable:false})
    @Type(() => AccountCreateWithoutTransactionDestinationInput)
    create!: InstanceType<typeof AccountCreateWithoutTransactionDestinationInput>;
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
}

@InputType()
export class AccountUpsertWithoutTransactionOriginsInput {
    @Field(() => AccountUpdateWithoutTransactionOriginsInput, {nullable:false})
    @Type(() => AccountUpdateWithoutTransactionOriginsInput)
    update!: InstanceType<typeof AccountUpdateWithoutTransactionOriginsInput>;
    @Field(() => AccountCreateWithoutTransactionOriginsInput, {nullable:false})
    @Type(() => AccountCreateWithoutTransactionOriginsInput)
    create!: InstanceType<typeof AccountCreateWithoutTransactionOriginsInput>;
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
}

@InputType()
export class AccountWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [AccountWhereInput], {nullable:true})
    AND?: Array<AccountWhereInput>;
    @Field(() => [AccountWhereInput], {nullable:true})
    OR?: Array<AccountWhereInput>;
    @Field(() => [AccountWhereInput], {nullable:true})
    NOT?: Array<AccountWhereInput>;
    @Field(() => FloatNullableFilter, {nullable:true})
    accountNumber?: InstanceType<typeof FloatNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => EnumAccountCategoryFilter, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
    @Field(() => TransactionListRelationFilter, {nullable:true})
    transactionOrigins?: InstanceType<typeof TransactionListRelationFilter>;
    @Field(() => TransactionListRelationFilter, {nullable:true})
    transactionDestination?: InstanceType<typeof TransactionListRelationFilter>;
    @HideField()
    project?: InstanceType<typeof ProjectNullableRelationFilter>;
    @HideField()
    bankAccount?: InstanceType<typeof BankNullableRelationFilter>;
}

@InputType()
export class AccountWhereInput {
    @Field(() => [AccountWhereInput], {nullable:true})
    AND?: Array<AccountWhereInput>;
    @Field(() => [AccountWhereInput], {nullable:true})
    OR?: Array<AccountWhereInput>;
    @Field(() => [AccountWhereInput], {nullable:true})
    NOT?: Array<AccountWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => FloatNullableFilter, {nullable:true})
    accountNumber?: InstanceType<typeof FloatNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => EnumAccountCategoryFilter, {nullable:true})
    accountCategory?: InstanceType<typeof EnumAccountCategoryFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
    @Field(() => TransactionListRelationFilter, {nullable:true})
    transactionOrigins?: InstanceType<typeof TransactionListRelationFilter>;
    @Field(() => TransactionListRelationFilter, {nullable:true})
    transactionDestination?: InstanceType<typeof TransactionListRelationFilter>;
    @HideField()
    project?: InstanceType<typeof ProjectNullableRelationFilter>;
    @HideField()
    bankAccount?: InstanceType<typeof BankNullableRelationFilter>;
}

@ObjectType()
export class Account {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Float, {nullable:true})
    accountNumber!: number | null;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => AccountCategory, {nullable:false})
    accountCategory!: keyof typeof AccountCategory;
    @Field(() => User, {nullable:false})
    user?: InstanceType<typeof User>;
    @Field(() => [Transaction], {nullable:true})
    transactionOrigins?: Array<Transaction>;
    @Field(() => [Transaction], {nullable:true})
    transactionDestination?: Array<Transaction>;
    @Field(() => Project, {nullable:true})
    project?: InstanceType<typeof Project> | null;
    @Field(() => Bank, {nullable:true})
    bankAccount?: InstanceType<typeof Bank> | null;
    @Field(() => AccountCount, {nullable:false})
    _count?: InstanceType<typeof AccountCount>;
}

@ObjectType()
export class AggregateAccount {
    @Field(() => AccountCountAggregate, {nullable:true})
    _count?: InstanceType<typeof AccountCountAggregate>;
    @Field(() => AccountAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof AccountAvgAggregate>;
    @Field(() => AccountSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof AccountSumAggregate>;
    @Field(() => AccountMinAggregate, {nullable:true})
    _min?: InstanceType<typeof AccountMinAggregate>;
    @Field(() => AccountMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof AccountMaxAggregate>;
}

@ArgsType()
export class CreateManyAccountArgs {
    @Field(() => [AccountCreateManyInput], {nullable:false})
    @Type(() => AccountCreateManyInput)
    data!: Array<AccountCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneAccountArgs {
    @Field(() => AccountCreateInput, {nullable:false})
    @Type(() => AccountCreateInput)
    data!: InstanceType<typeof AccountCreateInput>;
}

@ArgsType()
export class DeleteManyAccountArgs {
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
}

@ArgsType()
export class DeleteOneAccountArgs {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstAccountOrThrowArgs {
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
    @Field(() => [AccountOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<AccountOrderByWithRelationInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [AccountScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof AccountScalarFieldEnum>;
}

@ArgsType()
export class FindFirstAccountArgs {
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
    @Field(() => [AccountOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<AccountOrderByWithRelationInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [AccountScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof AccountScalarFieldEnum>;
}

@ArgsType()
export class FindManyAccountArgs {
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
    @Field(() => [AccountOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<AccountOrderByWithRelationInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [AccountScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof AccountScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueAccountOrThrowArgs {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueAccountArgs {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpdateManyAccountArgs {
    @Field(() => AccountUpdateManyMutationInput, {nullable:false})
    @Type(() => AccountUpdateManyMutationInput)
    data!: InstanceType<typeof AccountUpdateManyMutationInput>;
    @Field(() => AccountWhereInput, {nullable:true})
    @Type(() => AccountWhereInput)
    where?: InstanceType<typeof AccountWhereInput>;
}

@ArgsType()
export class UpdateOneAccountArgs {
    @Field(() => AccountUpdateInput, {nullable:false})
    @Type(() => AccountUpdateInput)
    data!: InstanceType<typeof AccountUpdateInput>;
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneAccountArgs {
    @Field(() => AccountWhereUniqueInput, {nullable:false})
    @Type(() => AccountWhereUniqueInput)
    where!: Prisma.AtLeast<AccountWhereUniqueInput, 'id'>;
    @Field(() => AccountCreateInput, {nullable:false})
    @Type(() => AccountCreateInput)
    create!: InstanceType<typeof AccountCreateInput>;
    @Field(() => AccountUpdateInput, {nullable:false})
    @Type(() => AccountUpdateInput)
    update!: InstanceType<typeof AccountUpdateInput>;
}

@ArgsType()
export class AddressAggregateArgs {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
    @Field(() => [AddressOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<AddressOrderByWithRelationInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => AddressCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof AddressCountAggregateInput>;
    @Field(() => AddressAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof AddressAvgAggregateInput>;
    @Field(() => AddressSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof AddressSumAggregateInput>;
    @Field(() => AddressMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof AddressMinAggregateInput>;
    @Field(() => AddressMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof AddressMaxAggregateInput>;
}

@InputType()
export class AddressAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    subdistrictId?: true;
}

@ObjectType()
export class AddressAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    subdistrictId?: number;
}

@InputType()
export class AddressAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    subdistrictId?: keyof typeof SortOrder;
}

@InputType()
export class AddressCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    subdistrictId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class AddressCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    subdistrictId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class AddressCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    subdistrictId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class AddressCreateManySubdistrictInputEnvelope {
    @Field(() => [AddressCreateManySubdistrictInput], {nullable:false})
    @Type(() => AddressCreateManySubdistrictInput)
    data!: Array<AddressCreateManySubdistrictInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class AddressCreateManySubdistrictInput {
    @HideField()
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class AddressCreateManyInput {
    @HideField()
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    subdistrictId!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class AddressCreateNestedManyWithoutSubdistrictInput {
    @Field(() => [AddressCreateWithoutSubdistrictInput], {nullable:true})
    @Type(() => AddressCreateWithoutSubdistrictInput)
    create?: Array<AddressCreateWithoutSubdistrictInput>;
    @Field(() => [AddressCreateOrConnectWithoutSubdistrictInput], {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutSubdistrictInput)
    connectOrCreate?: Array<AddressCreateOrConnectWithoutSubdistrictInput>;
    @Field(() => AddressCreateManySubdistrictInputEnvelope, {nullable:true})
    @Type(() => AddressCreateManySubdistrictInputEnvelope)
    createMany?: InstanceType<typeof AddressCreateManySubdistrictInputEnvelope>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
}

@InputType()
export class AddressCreateNestedOneWithoutHotelInput {
    @Field(() => AddressCreateWithoutHotelInput, {nullable:true})
    @Type(() => AddressCreateWithoutHotelInput)
    create?: InstanceType<typeof AddressCreateWithoutHotelInput>;
    @Field(() => AddressCreateOrConnectWithoutHotelInput, {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutHotelInput)
    connectOrCreate?: InstanceType<typeof AddressCreateOrConnectWithoutHotelInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
}

@InputType()
export class AddressCreateNestedOneWithoutSchoolInput {
    @Field(() => AddressCreateWithoutSchoolInput, {nullable:true})
    @Type(() => AddressCreateWithoutSchoolInput)
    create?: InstanceType<typeof AddressCreateWithoutSchoolInput>;
    @Field(() => AddressCreateOrConnectWithoutSchoolInput, {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutSchoolInput)
    connectOrCreate?: InstanceType<typeof AddressCreateOrConnectWithoutSchoolInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
}

@InputType()
export class AddressCreateNestedOneWithoutShippingInput {
    @Field(() => AddressCreateWithoutShippingInput, {nullable:true})
    @Type(() => AddressCreateWithoutShippingInput)
    create?: InstanceType<typeof AddressCreateWithoutShippingInput>;
    @Field(() => AddressCreateOrConnectWithoutShippingInput, {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutShippingInput)
    connectOrCreate?: InstanceType<typeof AddressCreateOrConnectWithoutShippingInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
}

@InputType()
export class AddressCreateNestedOneWithoutUserInput {
    @Field(() => AddressCreateWithoutUserInput, {nullable:true})
    @Type(() => AddressCreateWithoutUserInput)
    create?: InstanceType<typeof AddressCreateWithoutUserInput>;
    @Field(() => AddressCreateOrConnectWithoutUserInput, {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutUserInput)
    connectOrCreate?: InstanceType<typeof AddressCreateOrConnectWithoutUserInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
}

@InputType()
export class AddressCreateOrConnectWithoutHotelInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressCreateWithoutHotelInput, {nullable:false})
    @Type(() => AddressCreateWithoutHotelInput)
    create!: InstanceType<typeof AddressCreateWithoutHotelInput>;
}

@InputType()
export class AddressCreateOrConnectWithoutSchoolInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressCreateWithoutSchoolInput, {nullable:false})
    @Type(() => AddressCreateWithoutSchoolInput)
    create!: InstanceType<typeof AddressCreateWithoutSchoolInput>;
}

@InputType()
export class AddressCreateOrConnectWithoutShippingInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressCreateWithoutShippingInput, {nullable:false})
    @Type(() => AddressCreateWithoutShippingInput)
    create!: InstanceType<typeof AddressCreateWithoutShippingInput>;
}

@InputType()
export class AddressCreateOrConnectWithoutSubdistrictInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressCreateWithoutSubdistrictInput, {nullable:false})
    @Type(() => AddressCreateWithoutSubdistrictInput)
    create!: InstanceType<typeof AddressCreateWithoutSubdistrictInput>;
}

@InputType()
export class AddressCreateOrConnectWithoutUserInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressCreateWithoutUserInput, {nullable:false})
    @Type(() => AddressCreateWithoutUserInput)
    create!: InstanceType<typeof AddressCreateWithoutUserInput>;
}

@InputType()
export class AddressCreateWithoutHotelInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => SubdistrictCreateNestedOneWithoutAddressInput, {nullable:false})
    subdistrict!: InstanceType<typeof SubdistrictCreateNestedOneWithoutAddressInput>;
    @HideField()
    user?: InstanceType<typeof UserCreateNestedOneWithoutAddressInput>;
    @HideField()
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutAddressInput>;
    @HideField()
    Shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressCreateWithoutSchoolInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => SubdistrictCreateNestedOneWithoutAddressInput, {nullable:false})
    subdistrict!: InstanceType<typeof SubdistrictCreateNestedOneWithoutAddressInput>;
    @HideField()
    user?: InstanceType<typeof UserCreateNestedOneWithoutAddressInput>;
    @HideField()
    hotel?: InstanceType<typeof HotelCreateNestedOneWithoutAddressInput>;
    @HideField()
    Shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressCreateWithoutShippingInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => SubdistrictCreateNestedOneWithoutAddressInput, {nullable:false})
    subdistrict!: InstanceType<typeof SubdistrictCreateNestedOneWithoutAddressInput>;
    @HideField()
    user?: InstanceType<typeof UserCreateNestedOneWithoutAddressInput>;
    @HideField()
    hotel?: InstanceType<typeof HotelCreateNestedOneWithoutAddressInput>;
    @HideField()
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressCreateWithoutSubdistrictInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    user?: InstanceType<typeof UserCreateNestedOneWithoutAddressInput>;
    @HideField()
    hotel?: InstanceType<typeof HotelCreateNestedOneWithoutAddressInput>;
    @HideField()
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutAddressInput>;
    @HideField()
    Shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressCreateWithoutUserInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => SubdistrictCreateNestedOneWithoutAddressInput, {nullable:false})
    subdistrict!: InstanceType<typeof SubdistrictCreateNestedOneWithoutAddressInput>;
    @HideField()
    hotel?: InstanceType<typeof HotelCreateNestedOneWithoutAddressInput>;
    @HideField()
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutAddressInput>;
    @HideField()
    Shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => SubdistrictCreateNestedOneWithoutAddressInput, {nullable:false})
    subdistrict!: InstanceType<typeof SubdistrictCreateNestedOneWithoutAddressInput>;
    @HideField()
    user?: InstanceType<typeof UserCreateNestedOneWithoutAddressInput>;
    @HideField()
    hotel?: InstanceType<typeof HotelCreateNestedOneWithoutAddressInput>;
    @HideField()
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutAddressInput>;
    @HideField()
    Shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutAddressInput>;
}

@ArgsType()
export class AddressGroupByArgs {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
    @Field(() => [AddressOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<AddressOrderByWithAggregationInput>;
    @Field(() => [AddressScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof AddressScalarFieldEnum>;
    @Field(() => AddressScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof AddressScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => AddressCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof AddressCountAggregateInput>;
    @Field(() => AddressAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof AddressAvgAggregateInput>;
    @Field(() => AddressSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof AddressSumAggregateInput>;
    @Field(() => AddressMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof AddressMinAggregateInput>;
    @Field(() => AddressMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof AddressMaxAggregateInput>;
}

@ObjectType()
export class AddressGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    subdistrictId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => AddressCountAggregate, {nullable:true})
    _count?: InstanceType<typeof AddressCountAggregate>;
    @Field(() => AddressAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof AddressAvgAggregate>;
    @Field(() => AddressSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof AddressSumAggregate>;
    @Field(() => AddressMinAggregate, {nullable:true})
    _min?: InstanceType<typeof AddressMinAggregate>;
    @Field(() => AddressMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof AddressMaxAggregate>;
}

@InputType()
export class AddressListRelationFilter {
    @Field(() => AddressWhereInput, {nullable:true})
    every?: InstanceType<typeof AddressWhereInput>;
    @Field(() => AddressWhereInput, {nullable:true})
    some?: InstanceType<typeof AddressWhereInput>;
    @Field(() => AddressWhereInput, {nullable:true})
    none?: InstanceType<typeof AddressWhereInput>;
}

@InputType()
export class AddressMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    subdistrictId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class AddressMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Int, {nullable:true})
    subdistrictId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class AddressMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    subdistrictId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class AddressMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    subdistrictId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class AddressMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Int, {nullable:true})
    subdistrictId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class AddressMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    subdistrictId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class AddressOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class AddressOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    subdistrictId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => AddressCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof AddressCountOrderByAggregateInput>;
    @Field(() => AddressAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof AddressAvgOrderByAggregateInput>;
    @Field(() => AddressMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof AddressMaxOrderByAggregateInput>;
    @Field(() => AddressMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof AddressMinOrderByAggregateInput>;
    @Field(() => AddressSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof AddressSumOrderByAggregateInput>;
}

@InputType()
export class AddressOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    subdistrictId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SubdistrictOrderByWithRelationInput, {nullable:true})
    subdistrict?: InstanceType<typeof SubdistrictOrderByWithRelationInput>;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    user?: InstanceType<typeof UserOrderByWithRelationInput>;
    @Field(() => HotelOrderByWithRelationInput, {nullable:true})
    hotel?: InstanceType<typeof HotelOrderByWithRelationInput>;
    @Field(() => SchoolOrderByWithRelationInput, {nullable:true})
    school?: InstanceType<typeof SchoolOrderByWithRelationInput>;
    @Field(() => ShippingOrderByWithRelationInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingOrderByWithRelationInput>;
}

@InputType()
export class AddressRelationFilter {
    @Field(() => AddressWhereInput, {nullable:true})
    is?: InstanceType<typeof AddressWhereInput>;
    @Field(() => AddressWhereInput, {nullable:true})
    isNot?: InstanceType<typeof AddressWhereInput>;
}

@InputType()
export class AddressScalarWhereWithAggregatesInput {
    @Field(() => [AddressScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<AddressScalarWhereWithAggregatesInput>;
    @Field(() => [AddressScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<AddressScalarWhereWithAggregatesInput>;
    @Field(() => [AddressScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<AddressScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    subdistrictId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class AddressScalarWhereInput {
    @Field(() => [AddressScalarWhereInput], {nullable:true})
    AND?: Array<AddressScalarWhereInput>;
    @Field(() => [AddressScalarWhereInput], {nullable:true})
    OR?: Array<AddressScalarWhereInput>;
    @Field(() => [AddressScalarWhereInput], {nullable:true})
    NOT?: Array<AddressScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    subdistrictId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class AddressSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    subdistrictId?: true;
}

@ObjectType()
export class AddressSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    subdistrictId?: number;
}

@InputType()
export class AddressSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    subdistrictId?: keyof typeof SortOrder;
}

@InputType()
export class AddressUncheckedCreateNestedManyWithoutSubdistrictInput {
    @Field(() => [AddressCreateWithoutSubdistrictInput], {nullable:true})
    @Type(() => AddressCreateWithoutSubdistrictInput)
    create?: Array<AddressCreateWithoutSubdistrictInput>;
    @Field(() => [AddressCreateOrConnectWithoutSubdistrictInput], {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutSubdistrictInput)
    connectOrCreate?: Array<AddressCreateOrConnectWithoutSubdistrictInput>;
    @Field(() => AddressCreateManySubdistrictInputEnvelope, {nullable:true})
    @Type(() => AddressCreateManySubdistrictInputEnvelope)
    createMany?: InstanceType<typeof AddressCreateManySubdistrictInputEnvelope>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
}

@InputType()
export class AddressUncheckedCreateWithoutHotelInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    subdistrictId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => SchoolUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressUncheckedCreateWithoutSchoolInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    subdistrictId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => HotelUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressUncheckedCreateWithoutShippingInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    subdistrictId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => HotelUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => SchoolUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressUncheckedCreateWithoutSubdistrictInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => HotelUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => SchoolUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressUncheckedCreateWithoutUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    subdistrictId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => HotelUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => SchoolUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    subdistrictId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => HotelUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => SchoolUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedCreateNestedOneWithoutAddressInput>;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutAddressInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutAddressInput>;
}

@InputType()
export class AddressUncheckedUpdateManyWithoutSubdistrictNestedInput {
    @Field(() => [AddressCreateWithoutSubdistrictInput], {nullable:true})
    @Type(() => AddressCreateWithoutSubdistrictInput)
    create?: Array<AddressCreateWithoutSubdistrictInput>;
    @Field(() => [AddressCreateOrConnectWithoutSubdistrictInput], {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutSubdistrictInput)
    connectOrCreate?: Array<AddressCreateOrConnectWithoutSubdistrictInput>;
    @Field(() => [AddressUpsertWithWhereUniqueWithoutSubdistrictInput], {nullable:true})
    @Type(() => AddressUpsertWithWhereUniqueWithoutSubdistrictInput)
    upsert?: Array<AddressUpsertWithWhereUniqueWithoutSubdistrictInput>;
    @Field(() => AddressCreateManySubdistrictInputEnvelope, {nullable:true})
    @Type(() => AddressCreateManySubdistrictInputEnvelope)
    createMany?: InstanceType<typeof AddressCreateManySubdistrictInputEnvelope>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    set?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressUpdateWithWhereUniqueWithoutSubdistrictInput], {nullable:true})
    @Type(() => AddressUpdateWithWhereUniqueWithoutSubdistrictInput)
    update?: Array<AddressUpdateWithWhereUniqueWithoutSubdistrictInput>;
    @Field(() => [AddressUpdateManyWithWhereWithoutSubdistrictInput], {nullable:true})
    @Type(() => AddressUpdateManyWithWhereWithoutSubdistrictInput)
    updateMany?: Array<AddressUpdateManyWithWhereWithoutSubdistrictInput>;
    @Field(() => [AddressScalarWhereInput], {nullable:true})
    @Type(() => AddressScalarWhereInput)
    deleteMany?: Array<AddressScalarWhereInput>;
}

@InputType()
export class AddressUncheckedUpdateManyWithoutSubdistrictInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class AddressUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    subdistrictId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class AddressUncheckedUpdateWithoutHotelInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    subdistrictId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUncheckedUpdateWithoutSchoolInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    subdistrictId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUncheckedUpdateWithoutShippingInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    subdistrictId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUncheckedUpdateWithoutSubdistrictInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUncheckedUpdateWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    subdistrictId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => HotelUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    subdistrictId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUncheckedUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class AddressUpdateManyWithWhereWithoutSubdistrictInput {
    @Field(() => AddressScalarWhereInput, {nullable:false})
    @Type(() => AddressScalarWhereInput)
    where!: InstanceType<typeof AddressScalarWhereInput>;
    @Field(() => AddressUpdateManyMutationInput, {nullable:false})
    @Type(() => AddressUpdateManyMutationInput)
    data!: InstanceType<typeof AddressUpdateManyMutationInput>;
}

@InputType()
export class AddressUpdateManyWithoutSubdistrictNestedInput {
    @Field(() => [AddressCreateWithoutSubdistrictInput], {nullable:true})
    @Type(() => AddressCreateWithoutSubdistrictInput)
    create?: Array<AddressCreateWithoutSubdistrictInput>;
    @Field(() => [AddressCreateOrConnectWithoutSubdistrictInput], {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutSubdistrictInput)
    connectOrCreate?: Array<AddressCreateOrConnectWithoutSubdistrictInput>;
    @Field(() => [AddressUpsertWithWhereUniqueWithoutSubdistrictInput], {nullable:true})
    @Type(() => AddressUpsertWithWhereUniqueWithoutSubdistrictInput)
    upsert?: Array<AddressUpsertWithWhereUniqueWithoutSubdistrictInput>;
    @Field(() => AddressCreateManySubdistrictInputEnvelope, {nullable:true})
    @Type(() => AddressCreateManySubdistrictInputEnvelope)
    createMany?: InstanceType<typeof AddressCreateManySubdistrictInputEnvelope>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    set?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressWhereUniqueInput], {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<AddressWhereUniqueInput, 'id'>>;
    @Field(() => [AddressUpdateWithWhereUniqueWithoutSubdistrictInput], {nullable:true})
    @Type(() => AddressUpdateWithWhereUniqueWithoutSubdistrictInput)
    update?: Array<AddressUpdateWithWhereUniqueWithoutSubdistrictInput>;
    @Field(() => [AddressUpdateManyWithWhereWithoutSubdistrictInput], {nullable:true})
    @Type(() => AddressUpdateManyWithWhereWithoutSubdistrictInput)
    updateMany?: Array<AddressUpdateManyWithWhereWithoutSubdistrictInput>;
    @Field(() => [AddressScalarWhereInput], {nullable:true})
    @Type(() => AddressScalarWhereInput)
    deleteMany?: Array<AddressScalarWhereInput>;
}

@InputType()
export class AddressUpdateOneRequiredWithoutHotelNestedInput {
    @Field(() => AddressCreateWithoutHotelInput, {nullable:true})
    @Type(() => AddressCreateWithoutHotelInput)
    create?: InstanceType<typeof AddressCreateWithoutHotelInput>;
    @Field(() => AddressCreateOrConnectWithoutHotelInput, {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutHotelInput)
    connectOrCreate?: InstanceType<typeof AddressCreateOrConnectWithoutHotelInput>;
    @Field(() => AddressUpsertWithoutHotelInput, {nullable:true})
    @Type(() => AddressUpsertWithoutHotelInput)
    upsert?: InstanceType<typeof AddressUpsertWithoutHotelInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressUpdateToOneWithWhereWithoutHotelInput, {nullable:true})
    @Type(() => AddressUpdateToOneWithWhereWithoutHotelInput)
    update?: InstanceType<typeof AddressUpdateToOneWithWhereWithoutHotelInput>;
}

@InputType()
export class AddressUpdateOneRequiredWithoutSchoolNestedInput {
    @Field(() => AddressCreateWithoutSchoolInput, {nullable:true})
    @Type(() => AddressCreateWithoutSchoolInput)
    create?: InstanceType<typeof AddressCreateWithoutSchoolInput>;
    @Field(() => AddressCreateOrConnectWithoutSchoolInput, {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutSchoolInput)
    connectOrCreate?: InstanceType<typeof AddressCreateOrConnectWithoutSchoolInput>;
    @Field(() => AddressUpsertWithoutSchoolInput, {nullable:true})
    @Type(() => AddressUpsertWithoutSchoolInput)
    upsert?: InstanceType<typeof AddressUpsertWithoutSchoolInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressUpdateToOneWithWhereWithoutSchoolInput, {nullable:true})
    @Type(() => AddressUpdateToOneWithWhereWithoutSchoolInput)
    update?: InstanceType<typeof AddressUpdateToOneWithWhereWithoutSchoolInput>;
}

@InputType()
export class AddressUpdateOneRequiredWithoutShippingNestedInput {
    @Field(() => AddressCreateWithoutShippingInput, {nullable:true})
    @Type(() => AddressCreateWithoutShippingInput)
    create?: InstanceType<typeof AddressCreateWithoutShippingInput>;
    @Field(() => AddressCreateOrConnectWithoutShippingInput, {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutShippingInput)
    connectOrCreate?: InstanceType<typeof AddressCreateOrConnectWithoutShippingInput>;
    @Field(() => AddressUpsertWithoutShippingInput, {nullable:true})
    @Type(() => AddressUpsertWithoutShippingInput)
    upsert?: InstanceType<typeof AddressUpsertWithoutShippingInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressUpdateToOneWithWhereWithoutShippingInput, {nullable:true})
    @Type(() => AddressUpdateToOneWithWhereWithoutShippingInput)
    update?: InstanceType<typeof AddressUpdateToOneWithWhereWithoutShippingInput>;
}

@InputType()
export class AddressUpdateOneRequiredWithoutUserNestedInput {
    @Field(() => AddressCreateWithoutUserInput, {nullable:true})
    @Type(() => AddressCreateWithoutUserInput)
    create?: InstanceType<typeof AddressCreateWithoutUserInput>;
    @Field(() => AddressCreateOrConnectWithoutUserInput, {nullable:true})
    @Type(() => AddressCreateOrConnectWithoutUserInput)
    connectOrCreate?: InstanceType<typeof AddressCreateOrConnectWithoutUserInput>;
    @Field(() => AddressUpsertWithoutUserInput, {nullable:true})
    @Type(() => AddressUpsertWithoutUserInput)
    upsert?: InstanceType<typeof AddressUpsertWithoutUserInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    @Type(() => AddressWhereUniqueInput)
    connect?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressUpdateToOneWithWhereWithoutUserInput, {nullable:true})
    @Type(() => AddressUpdateToOneWithWhereWithoutUserInput)
    update?: InstanceType<typeof AddressUpdateToOneWithWhereWithoutUserInput>;
}

@InputType()
export class AddressUpdateToOneWithWhereWithoutHotelInput {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
    @Field(() => AddressUpdateWithoutHotelInput, {nullable:false})
    @Type(() => AddressUpdateWithoutHotelInput)
    data!: InstanceType<typeof AddressUpdateWithoutHotelInput>;
}

@InputType()
export class AddressUpdateToOneWithWhereWithoutSchoolInput {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
    @Field(() => AddressUpdateWithoutSchoolInput, {nullable:false})
    @Type(() => AddressUpdateWithoutSchoolInput)
    data!: InstanceType<typeof AddressUpdateWithoutSchoolInput>;
}

@InputType()
export class AddressUpdateToOneWithWhereWithoutShippingInput {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
    @Field(() => AddressUpdateWithoutShippingInput, {nullable:false})
    @Type(() => AddressUpdateWithoutShippingInput)
    data!: InstanceType<typeof AddressUpdateWithoutShippingInput>;
}

@InputType()
export class AddressUpdateToOneWithWhereWithoutUserInput {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
    @Field(() => AddressUpdateWithoutUserInput, {nullable:false})
    @Type(() => AddressUpdateWithoutUserInput)
    data!: InstanceType<typeof AddressUpdateWithoutUserInput>;
}

@InputType()
export class AddressUpdateWithWhereUniqueWithoutSubdistrictInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressUpdateWithoutSubdistrictInput, {nullable:false})
    @Type(() => AddressUpdateWithoutSubdistrictInput)
    data!: InstanceType<typeof AddressUpdateWithoutSubdistrictInput>;
}

@InputType()
export class AddressUpdateWithoutHotelInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => SubdistrictUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    subdistrict?: InstanceType<typeof SubdistrictUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => UserUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUpdateWithoutSchoolInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => SubdistrictUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    subdistrict?: InstanceType<typeof SubdistrictUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => UserUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUpdateWithoutShippingInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => SubdistrictUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    subdistrict?: InstanceType<typeof SubdistrictUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => UserUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUpdateWithoutSubdistrictInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUpdateWithoutUserInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => SubdistrictUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    subdistrict?: InstanceType<typeof SubdistrictUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => HotelUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => SubdistrictUpdateOneRequiredWithoutAddressNestedInput, {nullable:true})
    subdistrict?: InstanceType<typeof SubdistrictUpdateOneRequiredWithoutAddressNestedInput>;
    @Field(() => UserUpdateOneWithoutAddressNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneWithoutAddressNestedInput>;
    @Field(() => HotelUpdateOneWithoutAddressNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUpdateOneWithoutAddressNestedInput>;
    @Field(() => SchoolUpdateOneWithoutAddressNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutAddressNestedInput>;
    @Field(() => ShippingUpdateOneWithoutAddressNestedInput, {nullable:true})
    Shipping?: InstanceType<typeof ShippingUpdateOneWithoutAddressNestedInput>;
}

@InputType()
export class AddressUpsertWithWhereUniqueWithoutSubdistrictInput {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressUpdateWithoutSubdistrictInput, {nullable:false})
    @Type(() => AddressUpdateWithoutSubdistrictInput)
    update!: InstanceType<typeof AddressUpdateWithoutSubdistrictInput>;
    @Field(() => AddressCreateWithoutSubdistrictInput, {nullable:false})
    @Type(() => AddressCreateWithoutSubdistrictInput)
    create!: InstanceType<typeof AddressCreateWithoutSubdistrictInput>;
}

@InputType()
export class AddressUpsertWithoutHotelInput {
    @Field(() => AddressUpdateWithoutHotelInput, {nullable:false})
    @Type(() => AddressUpdateWithoutHotelInput)
    update!: InstanceType<typeof AddressUpdateWithoutHotelInput>;
    @Field(() => AddressCreateWithoutHotelInput, {nullable:false})
    @Type(() => AddressCreateWithoutHotelInput)
    create!: InstanceType<typeof AddressCreateWithoutHotelInput>;
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
}

@InputType()
export class AddressUpsertWithoutSchoolInput {
    @Field(() => AddressUpdateWithoutSchoolInput, {nullable:false})
    @Type(() => AddressUpdateWithoutSchoolInput)
    update!: InstanceType<typeof AddressUpdateWithoutSchoolInput>;
    @Field(() => AddressCreateWithoutSchoolInput, {nullable:false})
    @Type(() => AddressCreateWithoutSchoolInput)
    create!: InstanceType<typeof AddressCreateWithoutSchoolInput>;
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
}

@InputType()
export class AddressUpsertWithoutShippingInput {
    @Field(() => AddressUpdateWithoutShippingInput, {nullable:false})
    @Type(() => AddressUpdateWithoutShippingInput)
    update!: InstanceType<typeof AddressUpdateWithoutShippingInput>;
    @Field(() => AddressCreateWithoutShippingInput, {nullable:false})
    @Type(() => AddressCreateWithoutShippingInput)
    create!: InstanceType<typeof AddressCreateWithoutShippingInput>;
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
}

@InputType()
export class AddressUpsertWithoutUserInput {
    @Field(() => AddressUpdateWithoutUserInput, {nullable:false})
    @Type(() => AddressUpdateWithoutUserInput)
    update!: InstanceType<typeof AddressUpdateWithoutUserInput>;
    @Field(() => AddressCreateWithoutUserInput, {nullable:false})
    @Type(() => AddressCreateWithoutUserInput)
    create!: InstanceType<typeof AddressCreateWithoutUserInput>;
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
}

@InputType()
export class AddressWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [AddressWhereInput], {nullable:true})
    AND?: Array<AddressWhereInput>;
    @Field(() => [AddressWhereInput], {nullable:true})
    OR?: Array<AddressWhereInput>;
    @Field(() => [AddressWhereInput], {nullable:true})
    NOT?: Array<AddressWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    subdistrictId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => SubdistrictRelationFilter, {nullable:true})
    subdistrict?: InstanceType<typeof SubdistrictRelationFilter>;
    @Field(() => UserNullableRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserNullableRelationFilter>;
    @Field(() => HotelNullableRelationFilter, {nullable:true})
    hotel?: InstanceType<typeof HotelNullableRelationFilter>;
    @Field(() => SchoolNullableRelationFilter, {nullable:true})
    school?: InstanceType<typeof SchoolNullableRelationFilter>;
    @Field(() => ShippingNullableRelationFilter, {nullable:true})
    Shipping?: InstanceType<typeof ShippingNullableRelationFilter>;
}

@InputType()
export class AddressWhereInput {
    @Field(() => [AddressWhereInput], {nullable:true})
    AND?: Array<AddressWhereInput>;
    @Field(() => [AddressWhereInput], {nullable:true})
    OR?: Array<AddressWhereInput>;
    @Field(() => [AddressWhereInput], {nullable:true})
    NOT?: Array<AddressWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    subdistrictId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => SubdistrictRelationFilter, {nullable:true})
    subdistrict?: InstanceType<typeof SubdistrictRelationFilter>;
    @Field(() => UserNullableRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserNullableRelationFilter>;
    @Field(() => HotelNullableRelationFilter, {nullable:true})
    hotel?: InstanceType<typeof HotelNullableRelationFilter>;
    @Field(() => SchoolNullableRelationFilter, {nullable:true})
    school?: InstanceType<typeof SchoolNullableRelationFilter>;
    @Field(() => ShippingNullableRelationFilter, {nullable:true})
    Shipping?: InstanceType<typeof ShippingNullableRelationFilter>;
}

@ObjectType()
export class Address {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    subdistrictId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => Subdistrict, {nullable:false})
    subdistrict?: InstanceType<typeof Subdistrict>;
    @Field(() => User, {nullable:true})
    user?: InstanceType<typeof User> | null;
    @Field(() => Hotel, {nullable:true})
    hotel?: InstanceType<typeof Hotel> | null;
    @Field(() => School, {nullable:true})
    school?: InstanceType<typeof School> | null;
    @Field(() => Shipping, {nullable:true})
    Shipping?: InstanceType<typeof Shipping> | null;
}

@ObjectType()
export class AggregateAddress {
    @Field(() => AddressCountAggregate, {nullable:true})
    _count?: InstanceType<typeof AddressCountAggregate>;
    @Field(() => AddressAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof AddressAvgAggregate>;
    @Field(() => AddressSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof AddressSumAggregate>;
    @Field(() => AddressMinAggregate, {nullable:true})
    _min?: InstanceType<typeof AddressMinAggregate>;
    @Field(() => AddressMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof AddressMaxAggregate>;
}

@ArgsType()
export class CreateManyAddressArgs {
    @Field(() => [AddressCreateManyInput], {nullable:false})
    @Type(() => AddressCreateManyInput)
    data!: Array<AddressCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneAddressArgs {
    @Field(() => AddressCreateInput, {nullable:false})
    @Type(() => AddressCreateInput)
    data!: InstanceType<typeof AddressCreateInput>;
}

@ArgsType()
export class DeleteManyAddressArgs {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
}

@ArgsType()
export class DeleteOneAddressArgs {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstAddressOrThrowArgs {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
    @Field(() => [AddressOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<AddressOrderByWithRelationInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [AddressScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof AddressScalarFieldEnum>;
}

@ArgsType()
export class FindFirstAddressArgs {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
    @Field(() => [AddressOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<AddressOrderByWithRelationInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [AddressScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof AddressScalarFieldEnum>;
}

@ArgsType()
export class FindManyAddressArgs {
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
    @Field(() => [AddressOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<AddressOrderByWithRelationInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [AddressScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof AddressScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueAddressOrThrowArgs {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueAddressArgs {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpdateManyAddressArgs {
    @Field(() => AddressUpdateManyMutationInput, {nullable:false})
    @Type(() => AddressUpdateManyMutationInput)
    data!: InstanceType<typeof AddressUpdateManyMutationInput>;
    @Field(() => AddressWhereInput, {nullable:true})
    @Type(() => AddressWhereInput)
    where?: InstanceType<typeof AddressWhereInput>;
}

@ArgsType()
export class UpdateOneAddressArgs {
    @Field(() => AddressUpdateInput, {nullable:false})
    @Type(() => AddressUpdateInput)
    data!: InstanceType<typeof AddressUpdateInput>;
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneAddressArgs {
    @Field(() => AddressWhereUniqueInput, {nullable:false})
    @Type(() => AddressWhereUniqueInput)
    where!: Prisma.AtLeast<AddressWhereUniqueInput, 'id'>;
    @Field(() => AddressCreateInput, {nullable:false})
    @Type(() => AddressCreateInput)
    create!: InstanceType<typeof AddressCreateInput>;
    @Field(() => AddressUpdateInput, {nullable:false})
    @Type(() => AddressUpdateInput)
    update!: InstanceType<typeof AddressUpdateInput>;
}

@ObjectType()
export class AggregateBank {
    @Field(() => BankCountAggregate, {nullable:true})
    _count?: InstanceType<typeof BankCountAggregate>;
    @Field(() => BankAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof BankAvgAggregate>;
    @Field(() => BankSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof BankSumAggregate>;
    @Field(() => BankMinAggregate, {nullable:true})
    _min?: InstanceType<typeof BankMinAggregate>;
    @Field(() => BankMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof BankMaxAggregate>;
}

@ArgsType()
export class BankAggregateArgs {
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    where?: InstanceType<typeof BankWhereInput>;
    @Field(() => [BankOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<BankOrderByWithRelationInput>;
    @Field(() => BankWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => BankCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof BankCountAggregateInput>;
    @Field(() => BankAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof BankAvgAggregateInput>;
    @Field(() => BankSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof BankSumAggregateInput>;
    @Field(() => BankMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof BankMinAggregateInput>;
    @Field(() => BankMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof BankMaxAggregateInput>;
}

@InputType()
export class BankAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
    @HideField()
    accountId?: true;
}

@ObjectType()
export class BankAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => Float, {nullable:true})
    accountId?: number;
}

@InputType()
export class BankAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @HideField()
    accountId?: keyof typeof SortOrder;
}

@InputType()
export class BankCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    logoUrl?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
    @HideField()
    accountId?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class BankCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    logoUrl!: number;
    @Field(() => Int, {nullable:false})
    accountNumber!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class BankCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logoUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @HideField()
    accountId?: keyof typeof SortOrder;
}

@InputType()
export class BankCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(1)
    @Validator.MaxLength(10)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    @Validator.IsNotEmpty()
    logoUrl!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    accountNumber!: number;
    @HideField()
    accountId!: number;
}

@InputType()
export class BankCreateNestedOneWithoutAccountInput {
    @Field(() => BankCreateWithoutAccountInput, {nullable:true})
    @Type(() => BankCreateWithoutAccountInput)
    create?: InstanceType<typeof BankCreateWithoutAccountInput>;
    @Field(() => BankCreateOrConnectWithoutAccountInput, {nullable:true})
    @Type(() => BankCreateOrConnectWithoutAccountInput)
    connectOrCreate?: InstanceType<typeof BankCreateOrConnectWithoutAccountInput>;
    @Field(() => BankWhereUniqueInput, {nullable:true})
    @Type(() => BankWhereUniqueInput)
    connect?: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
}

@InputType()
export class BankCreateOrConnectWithoutAccountInput {
    @Field(() => BankWhereUniqueInput, {nullable:false})
    @Type(() => BankWhereUniqueInput)
    where!: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => BankCreateWithoutAccountInput, {nullable:false})
    @Type(() => BankCreateWithoutAccountInput)
    create!: InstanceType<typeof BankCreateWithoutAccountInput>;
}

@InputType()
export class BankCreateWithoutAccountInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(1)
    @Validator.MaxLength(10)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    @Validator.IsNotEmpty()
    logoUrl!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    accountNumber!: number;
}

@InputType()
export class BankCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(1)
    @Validator.MaxLength(10)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    @Validator.IsNotEmpty()
    logoUrl!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    accountNumber!: number;
    @HideField()
    account!: InstanceType<typeof AccountCreateNestedOneWithoutBankAccountInput>;
}

@ArgsType()
export class BankGroupByArgs {
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    where?: InstanceType<typeof BankWhereInput>;
    @Field(() => [BankOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<BankOrderByWithAggregationInput>;
    @Field(() => [BankScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof BankScalarFieldEnum>;
    @Field(() => BankScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof BankScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => BankCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof BankCountAggregateInput>;
    @Field(() => BankAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof BankAvgAggregateInput>;
    @Field(() => BankSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof BankSumAggregateInput>;
    @Field(() => BankMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof BankMinAggregateInput>;
    @Field(() => BankMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof BankMaxAggregateInput>;
}

@ObjectType()
export class BankGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    logoUrl!: string;
    @Field(() => Float, {nullable:false})
    accountNumber!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => BankCountAggregate, {nullable:true})
    _count?: InstanceType<typeof BankCountAggregate>;
    @Field(() => BankAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof BankAvgAggregate>;
    @Field(() => BankSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof BankSumAggregate>;
    @Field(() => BankMinAggregate, {nullable:true})
    _min?: InstanceType<typeof BankMinAggregate>;
    @Field(() => BankMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof BankMaxAggregate>;
}

@InputType()
export class BankMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    logoUrl?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
    @HideField()
    accountId?: true;
}

@ObjectType()
export class BankMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    logoUrl?: string;
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => Int, {nullable:true})
    accountId?: number;
}

@InputType()
export class BankMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logoUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @HideField()
    accountId?: keyof typeof SortOrder;
}

@InputType()
export class BankMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    logoUrl?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
    @HideField()
    accountId?: true;
}

@ObjectType()
export class BankMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    logoUrl?: string;
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => Int, {nullable:true})
    accountId?: number;
}

@InputType()
export class BankMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logoUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @HideField()
    accountId?: keyof typeof SortOrder;
}

@InputType()
export class BankNullableRelationFilter {
    @Field(() => BankWhereInput, {nullable:true})
    is?: InstanceType<typeof BankWhereInput>;
    @Field(() => BankWhereInput, {nullable:true})
    isNot?: InstanceType<typeof BankWhereInput>;
}

@InputType()
export class BankOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logoUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @HideField()
    accountId?: keyof typeof SortOrder;
    @Field(() => BankCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof BankCountOrderByAggregateInput>;
    @Field(() => BankAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof BankAvgOrderByAggregateInput>;
    @Field(() => BankMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof BankMaxOrderByAggregateInput>;
    @Field(() => BankMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof BankMinOrderByAggregateInput>;
    @Field(() => BankSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof BankSumOrderByAggregateInput>;
}

@InputType()
export class BankOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logoUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @HideField()
    accountId?: keyof typeof SortOrder;
    @HideField()
    account?: InstanceType<typeof AccountOrderByWithRelationInput>;
}

@InputType()
export class BankScalarWhereWithAggregatesInput {
    @Field(() => [BankScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<BankScalarWhereWithAggregatesInput>;
    @Field(() => [BankScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<BankScalarWhereWithAggregatesInput>;
    @Field(() => [BankScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<BankScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    logoUrl?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    accountNumber?: InstanceType<typeof FloatWithAggregatesFilter>;
    @HideField()
    accountId?: InstanceType<typeof IntWithAggregatesFilter>;
}

@InputType()
export class BankSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    accountNumber?: true;
    @HideField()
    accountId?: true;
}

@ObjectType()
export class BankSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    accountNumber?: number;
    @Field(() => Int, {nullable:true})
    accountId?: number;
}

@InputType()
export class BankSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountNumber?: keyof typeof SortOrder;
    @HideField()
    accountId?: keyof typeof SortOrder;
}

@InputType()
export class BankUncheckedCreateNestedOneWithoutAccountInput {
    @Field(() => BankCreateWithoutAccountInput, {nullable:true})
    @Type(() => BankCreateWithoutAccountInput)
    create?: InstanceType<typeof BankCreateWithoutAccountInput>;
    @Field(() => BankCreateOrConnectWithoutAccountInput, {nullable:true})
    @Type(() => BankCreateOrConnectWithoutAccountInput)
    connectOrCreate?: InstanceType<typeof BankCreateOrConnectWithoutAccountInput>;
    @Field(() => BankWhereUniqueInput, {nullable:true})
    @Type(() => BankWhereUniqueInput)
    connect?: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
}

@InputType()
export class BankUncheckedCreateWithoutAccountInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(1)
    @Validator.MaxLength(10)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    @Validator.IsNotEmpty()
    logoUrl!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    accountNumber!: number;
}

@InputType()
export class BankUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(1)
    @Validator.MaxLength(10)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    @Validator.IsNotEmpty()
    logoUrl!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    accountNumber!: number;
    @HideField()
    accountId!: number;
}

@InputType()
export class BankUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logoUrl?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @HideField()
    accountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class BankUncheckedUpdateOneWithoutAccountNestedInput {
    @Field(() => BankCreateWithoutAccountInput, {nullable:true})
    @Type(() => BankCreateWithoutAccountInput)
    create?: InstanceType<typeof BankCreateWithoutAccountInput>;
    @Field(() => BankCreateOrConnectWithoutAccountInput, {nullable:true})
    @Type(() => BankCreateOrConnectWithoutAccountInput)
    connectOrCreate?: InstanceType<typeof BankCreateOrConnectWithoutAccountInput>;
    @Field(() => BankUpsertWithoutAccountInput, {nullable:true})
    @Type(() => BankUpsertWithoutAccountInput)
    upsert?: InstanceType<typeof BankUpsertWithoutAccountInput>;
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    disconnect?: InstanceType<typeof BankWhereInput>;
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    delete?: InstanceType<typeof BankWhereInput>;
    @Field(() => BankWhereUniqueInput, {nullable:true})
    @Type(() => BankWhereUniqueInput)
    connect?: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => BankUpdateToOneWithWhereWithoutAccountInput, {nullable:true})
    @Type(() => BankUpdateToOneWithWhereWithoutAccountInput)
    update?: InstanceType<typeof BankUpdateToOneWithWhereWithoutAccountInput>;
}

@InputType()
export class BankUncheckedUpdateWithoutAccountInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logoUrl?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
}

@InputType()
export class BankUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logoUrl?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @HideField()
    accountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class BankUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logoUrl?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
}

@InputType()
export class BankUpdateOneWithoutAccountNestedInput {
    @Field(() => BankCreateWithoutAccountInput, {nullable:true})
    @Type(() => BankCreateWithoutAccountInput)
    create?: InstanceType<typeof BankCreateWithoutAccountInput>;
    @Field(() => BankCreateOrConnectWithoutAccountInput, {nullable:true})
    @Type(() => BankCreateOrConnectWithoutAccountInput)
    connectOrCreate?: InstanceType<typeof BankCreateOrConnectWithoutAccountInput>;
    @Field(() => BankUpsertWithoutAccountInput, {nullable:true})
    @Type(() => BankUpsertWithoutAccountInput)
    upsert?: InstanceType<typeof BankUpsertWithoutAccountInput>;
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    disconnect?: InstanceType<typeof BankWhereInput>;
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    delete?: InstanceType<typeof BankWhereInput>;
    @Field(() => BankWhereUniqueInput, {nullable:true})
    @Type(() => BankWhereUniqueInput)
    connect?: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => BankUpdateToOneWithWhereWithoutAccountInput, {nullable:true})
    @Type(() => BankUpdateToOneWithWhereWithoutAccountInput)
    update?: InstanceType<typeof BankUpdateToOneWithWhereWithoutAccountInput>;
}

@InputType()
export class BankUpdateToOneWithWhereWithoutAccountInput {
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    where?: InstanceType<typeof BankWhereInput>;
    @Field(() => BankUpdateWithoutAccountInput, {nullable:false})
    @Type(() => BankUpdateWithoutAccountInput)
    data!: InstanceType<typeof BankUpdateWithoutAccountInput>;
}

@InputType()
export class BankUpdateWithoutAccountInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logoUrl?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
}

@InputType()
export class BankUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logoUrl?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    accountNumber?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @HideField()
    account?: InstanceType<typeof AccountUpdateOneRequiredWithoutBankAccountNestedInput>;
}

@InputType()
export class BankUpsertWithoutAccountInput {
    @Field(() => BankUpdateWithoutAccountInput, {nullable:false})
    @Type(() => BankUpdateWithoutAccountInput)
    update!: InstanceType<typeof BankUpdateWithoutAccountInput>;
    @Field(() => BankCreateWithoutAccountInput, {nullable:false})
    @Type(() => BankCreateWithoutAccountInput)
    create!: InstanceType<typeof BankCreateWithoutAccountInput>;
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    where?: InstanceType<typeof BankWhereInput>;
}

@InputType()
export class BankWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @HideField()
    accountId?: number;
    @Field(() => [BankWhereInput], {nullable:true})
    AND?: Array<BankWhereInput>;
    @Field(() => [BankWhereInput], {nullable:true})
    OR?: Array<BankWhereInput>;
    @Field(() => [BankWhereInput], {nullable:true})
    NOT?: Array<BankWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    logoUrl?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    accountNumber?: InstanceType<typeof FloatFilter>;
    @HideField()
    account?: InstanceType<typeof AccountRelationFilter>;
}

@InputType()
export class BankWhereInput {
    @Field(() => [BankWhereInput], {nullable:true})
    AND?: Array<BankWhereInput>;
    @Field(() => [BankWhereInput], {nullable:true})
    OR?: Array<BankWhereInput>;
    @Field(() => [BankWhereInput], {nullable:true})
    NOT?: Array<BankWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    logoUrl?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    accountNumber?: InstanceType<typeof FloatFilter>;
    @HideField()
    accountId?: InstanceType<typeof IntFilter>;
    @HideField()
    account?: InstanceType<typeof AccountRelationFilter>;
}

@ObjectType()
export class Bank {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    logoUrl!: string;
    @Field(() => Float, {nullable:false})
    accountNumber!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Account, {nullable:false})
    account?: InstanceType<typeof Account>;
}

@ArgsType()
export class CreateManyBankArgs {
    @Field(() => [BankCreateManyInput], {nullable:false})
    @Type(() => BankCreateManyInput)
    data!: Array<BankCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneBankArgs {
    @Field(() => BankCreateInput, {nullable:false})
    @Type(() => BankCreateInput)
    data!: InstanceType<typeof BankCreateInput>;
}

@ArgsType()
export class DeleteManyBankArgs {
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    where?: InstanceType<typeof BankWhereInput>;
}

@ArgsType()
export class DeleteOneBankArgs {
    @Field(() => BankWhereUniqueInput, {nullable:false})
    @Type(() => BankWhereUniqueInput)
    where!: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
}

@ArgsType()
export class FindFirstBankOrThrowArgs {
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    where?: InstanceType<typeof BankWhereInput>;
    @Field(() => [BankOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<BankOrderByWithRelationInput>;
    @Field(() => BankWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [BankScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof BankScalarFieldEnum>;
}

@ArgsType()
export class FindFirstBankArgs {
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    where?: InstanceType<typeof BankWhereInput>;
    @Field(() => [BankOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<BankOrderByWithRelationInput>;
    @Field(() => BankWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [BankScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof BankScalarFieldEnum>;
}

@ArgsType()
export class FindManyBankArgs {
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    where?: InstanceType<typeof BankWhereInput>;
    @Field(() => [BankOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<BankOrderByWithRelationInput>;
    @Field(() => BankWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [BankScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof BankScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueBankOrThrowArgs {
    @Field(() => BankWhereUniqueInput, {nullable:false})
    @Type(() => BankWhereUniqueInput)
    where!: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
}

@ArgsType()
export class FindUniqueBankArgs {
    @Field(() => BankWhereUniqueInput, {nullable:false})
    @Type(() => BankWhereUniqueInput)
    where!: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
}

@ArgsType()
export class UpdateManyBankArgs {
    @Field(() => BankUpdateManyMutationInput, {nullable:false})
    @Type(() => BankUpdateManyMutationInput)
    data!: InstanceType<typeof BankUpdateManyMutationInput>;
    @Field(() => BankWhereInput, {nullable:true})
    @Type(() => BankWhereInput)
    where?: InstanceType<typeof BankWhereInput>;
}

@ArgsType()
export class UpdateOneBankArgs {
    @Field(() => BankUpdateInput, {nullable:false})
    @Type(() => BankUpdateInput)
    data!: InstanceType<typeof BankUpdateInput>;
    @Field(() => BankWhereUniqueInput, {nullable:false})
    @Type(() => BankWhereUniqueInput)
    where!: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
}

@ArgsType()
export class UpsertOneBankArgs {
    @Field(() => BankWhereUniqueInput, {nullable:false})
    @Type(() => BankWhereUniqueInput)
    where!: Prisma.AtLeast<BankWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => BankCreateInput, {nullable:false})
    @Type(() => BankCreateInput)
    create!: InstanceType<typeof BankCreateInput>;
    @Field(() => BankUpdateInput, {nullable:false})
    @Type(() => BankUpdateInput)
    update!: InstanceType<typeof BankUpdateInput>;
}

@ObjectType()
export class AggregateCart {
    @Field(() => CartCountAggregate, {nullable:true})
    _count?: InstanceType<typeof CartCountAggregate>;
    @Field(() => CartAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof CartAvgAggregate>;
    @Field(() => CartSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof CartSumAggregate>;
    @Field(() => CartMinAggregate, {nullable:true})
    _min?: InstanceType<typeof CartMinAggregate>;
    @Field(() => CartMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof CartMaxAggregate>;
}

@ArgsType()
export class CartAggregateArgs {
    @Field(() => CartWhereInput, {nullable:true})
    @Type(() => CartWhereInput)
    where?: InstanceType<typeof CartWhereInput>;
    @Field(() => [CartOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CartOrderByWithRelationInput>;
    @Field(() => CartWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CartWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => CartCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof CartCountAggregateInput>;
    @Field(() => CartAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof CartAvgAggregateInput>;
    @Field(() => CartSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof CartSumAggregateInput>;
    @Field(() => CartMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof CartMinAggregateInput>;
    @Field(() => CartMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof CartMaxAggregateInput>;
}

@InputType()
export class CartAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
    @Field(() => Boolean, {nullable:true})
    membershipItemId?: true;
    @Field(() => Boolean, {nullable:true})
    projectItemId?: true;
    @Field(() => Boolean, {nullable:true})
    quantity?: true;
    @Field(() => Boolean, {nullable:true})
    price?: true;
    @Field(() => Boolean, {nullable:true})
    cost?: true;
}

@ObjectType()
export class CartAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    orderId?: number;
    @Field(() => Float, {nullable:true})
    membershipItemId?: number;
    @Field(() => Float, {nullable:true})
    projectItemId?: number;
    @Field(() => Float, {nullable:true})
    quantity?: number;
    @Field(() => Float, {nullable:true})
    price?: number;
    @Field(() => Float, {nullable:true})
    cost?: number;
}

@InputType()
export class CartAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    membershipItemId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectItemId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    quantity?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
}

@InputType()
export class CartCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
    @Field(() => Boolean, {nullable:true})
    membershipItemId?: true;
    @Field(() => Boolean, {nullable:true})
    projectItemId?: true;
    @Field(() => Boolean, {nullable:true})
    quantity?: true;
    @Field(() => Boolean, {nullable:true})
    price?: true;
    @Field(() => Boolean, {nullable:true})
    cost?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class CartCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Int, {nullable:false})
    membershipItemId!: number;
    @Field(() => Int, {nullable:false})
    projectItemId!: number;
    @Field(() => Int, {nullable:false})
    quantity!: number;
    @Field(() => Int, {nullable:false})
    price!: number;
    @Field(() => Int, {nullable:false})
    cost!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class CartCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    membershipItemId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectItemId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    quantity?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class CartCreateManyMembershipItemInputEnvelope {
    @Field(() => [CartCreateManyMembershipItemInput], {nullable:false})
    @Type(() => CartCreateManyMembershipItemInput)
    data!: Array<CartCreateManyMembershipItemInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class CartCreateManyMembershipItemInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Int, {nullable:true})
    projectItemId?: number;
    @Field(() => Int, {nullable:false})
    quantity!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    price!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    cost!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CartCreateManyOrderInputEnvelope {
    @Field(() => [CartCreateManyOrderInput], {nullable:false})
    @Type(() => CartCreateManyOrderInput)
    data!: Array<CartCreateManyOrderInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class CartCreateManyOrderInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    membershipItemId?: number;
    @Field(() => Int, {nullable:true})
    projectItemId?: number;
    @Field(() => Int, {nullable:false})
    quantity!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    price!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    cost!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CartCreateManyProjectItemInputEnvelope {
    @Field(() => [CartCreateManyProjectItemInput], {nullable:false})
    @Type(() => CartCreateManyProjectItemInput)
    data!: Array<CartCreateManyProjectItemInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class CartCreateManyProjectItemInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Int, {nullable:true})
    membershipItemId?: number;
    @Field(() => Int, {nullable:false})
    quantity!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    price!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    cost!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CartCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Int, {nullable:true})
    membershipItemId?: number;
    @Field(() => Int, {nullable:true})
    projectItemId?: number;
    @Field(() => Int, {nullable:false})
    quantity!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    price!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    cost!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CartCreateNestedManyWithoutMembershipItemInput {
    @Field(() => [CartCreateWithoutMembershipItemInput], {nullable:true})
    @Type(() => CartCreateWithoutMembershipItemInput)
    create?: Array<CartCreateWithoutMembershipItemInput>;
    @Field(() => [CartCreateOrConnectWithoutMembershipItemInput], {nullable:true})
    @Type(() => CartCreateOrConnectWithoutMembershipItemInput)
    connectOrCreate?: Array<CartCreateOrConnectWithoutMembershipItemInput>;
    @Field(() => CartCreateManyMembershipItemInputEnvelope, {nullable:true})
    @Type(() => CartCreateManyMembershipItemInputEnvelope)
    createMany?: InstanceType<typeof CartCreateManyMembershipItemInputEnvelope>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
}

@InputType()
export class CartCreateNestedManyWithoutOrderInput {
    @Field(() => [CartCreateWithoutOrderInput], {nullable:true})
    @Type(() => CartCreateWithoutOrderInput)
    create?: Array<CartCreateWithoutOrderInput>;
    @Field(() => [CartCreateOrConnectWithoutOrderInput], {nullable:true})
    @Type(() => CartCreateOrConnectWithoutOrderInput)
    connectOrCreate?: Array<CartCreateOrConnectWithoutOrderInput>;
    @Field(() => CartCreateManyOrderInputEnvelope, {nullable:true})
    @Type(() => CartCreateManyOrderInputEnvelope)
    createMany?: InstanceType<typeof CartCreateManyOrderInputEnvelope>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
}

@InputType()
export class CartCreateNestedManyWithoutProjectItemInput {
    @Field(() => [CartCreateWithoutProjectItemInput], {nullable:true})
    @Type(() => CartCreateWithoutProjectItemInput)
    create?: Array<CartCreateWithoutProjectItemInput>;
    @Field(() => [CartCreateOrConnectWithoutProjectItemInput], {nullable:true})
    @Type(() => CartCreateOrConnectWithoutProjectItemInput)
    connectOrCreate?: Array<CartCreateOrConnectWithoutProjectItemInput>;
    @Field(() => CartCreateManyProjectItemInputEnvelope, {nullable:true})
    @Type(() => CartCreateManyProjectItemInputEnvelope)
    createMany?: InstanceType<typeof CartCreateManyProjectItemInputEnvelope>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
}

@InputType()
export class CartCreateOrConnectWithoutMembershipItemInput {
    @Field(() => CartWhereUniqueInput, {nullable:false})
    @Type(() => CartWhereUniqueInput)
    where!: Prisma.AtLeast<CartWhereUniqueInput, 'id'>;
    @Field(() => CartCreateWithoutMembershipItemInput, {nullable:false})
    @Type(() => CartCreateWithoutMembershipItemInput)
    create!: InstanceType<typeof CartCreateWithoutMembershipItemInput>;
}

@InputType()
export class CartCreateOrConnectWithoutOrderInput {
    @Field(() => CartWhereUniqueInput, {nullable:false})
    @Type(() => CartWhereUniqueInput)
    where!: Prisma.AtLeast<CartWhereUniqueInput, 'id'>;
    @Field(() => CartCreateWithoutOrderInput, {nullable:false})
    @Type(() => CartCreateWithoutOrderInput)
    create!: InstanceType<typeof CartCreateWithoutOrderInput>;
}

@InputType()
export class CartCreateOrConnectWithoutProjectItemInput {
    @Field(() => CartWhereUniqueInput, {nullable:false})
    @Type(() => CartWhereUniqueInput)
    where!: Prisma.AtLeast<CartWhereUniqueInput, 'id'>;
    @Field(() => CartCreateWithoutProjectItemInput, {nullable:false})
    @Type(() => CartCreateWithoutProjectItemInput)
    create!: InstanceType<typeof CartCreateWithoutProjectItemInput>;
}

@InputType()
export class CartCreateWithoutMembershipItemInput {
    @Field(() => Int, {nullable:false})
    quantity!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    price!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    cost!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => OrderCreateNestedOneWithoutCartInput, {nullable:false})
    order!: InstanceType<typeof OrderCreateNestedOneWithoutCartInput>;
    @Field(() => ProjectCreateNestedOneWithoutOrderCartInput, {nullable:true})
    projectItem?: InstanceType<typeof ProjectCreateNestedOneWithoutOrderCartInput>;
}

@InputType()
export class CartCreateWithoutOrderInput {
    @Field(() => Int, {nullable:false})
    quantity!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    price!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    cost!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ItemCreateNestedOneWithoutCartInput, {nullable:true})
    membershipItem?: InstanceType<typeof ItemCreateNestedOneWithoutCartInput>;
    @Field(() => ProjectCreateNestedOneWithoutOrderCartInput, {nullable:true})
    projectItem?: InstanceType<typeof ProjectCreateNestedOneWithoutOrderCartInput>;
}

@InputType()
export class CartCreateWithoutProjectItemInput {
    @Field(() => Int, {nullable:false})
    quantity!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    price!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    cost!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => OrderCreateNestedOneWithoutCartInput, {nullable:false})
    order!: InstanceType<typeof OrderCreateNestedOneWithoutCartInput>;
    @Field(() => ItemCreateNestedOneWithoutCartInput, {nullable:true})
    membershipItem?: InstanceType<typeof ItemCreateNestedOneWithoutCartInput>;
}

@InputType()
export class CartCreateInput {
    @Field(() => Int, {nullable:false})
    quantity!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    price!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    cost!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => OrderCreateNestedOneWithoutCartInput, {nullable:false})
    order!: InstanceType<typeof OrderCreateNestedOneWithoutCartInput>;
    @Field(() => ItemCreateNestedOneWithoutCartInput, {nullable:true})
    membershipItem?: InstanceType<typeof ItemCreateNestedOneWithoutCartInput>;
    @Field(() => ProjectCreateNestedOneWithoutOrderCartInput, {nullable:true})
    projectItem?: InstanceType<typeof ProjectCreateNestedOneWithoutOrderCartInput>;
}

@ArgsType()
export class CartGroupByArgs {
    @Field(() => CartWhereInput, {nullable:true})
    @Type(() => CartWhereInput)
    where?: InstanceType<typeof CartWhereInput>;
    @Field(() => [CartOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<CartOrderByWithAggregationInput>;
    @Field(() => [CartScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof CartScalarFieldEnum>;
    @Field(() => CartScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof CartScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => CartCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof CartCountAggregateInput>;
    @Field(() => CartAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof CartAvgAggregateInput>;
    @Field(() => CartSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof CartSumAggregateInput>;
    @Field(() => CartMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof CartMinAggregateInput>;
    @Field(() => CartMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof CartMaxAggregateInput>;
}

@ObjectType()
export class CartGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Int, {nullable:true})
    membershipItemId?: number;
    @Field(() => Int, {nullable:true})
    projectItemId?: number;
    @Field(() => Int, {nullable:false})
    quantity!: number;
    @Field(() => Float, {nullable:false})
    price!: number;
    @Field(() => Float, {nullable:false})
    cost!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => CartCountAggregate, {nullable:true})
    _count?: InstanceType<typeof CartCountAggregate>;
    @Field(() => CartAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof CartAvgAggregate>;
    @Field(() => CartSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof CartSumAggregate>;
    @Field(() => CartMinAggregate, {nullable:true})
    _min?: InstanceType<typeof CartMinAggregate>;
    @Field(() => CartMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof CartMaxAggregate>;
}

@InputType()
export class CartListRelationFilter {
    @Field(() => CartWhereInput, {nullable:true})
    every?: InstanceType<typeof CartWhereInput>;
    @Field(() => CartWhereInput, {nullable:true})
    some?: InstanceType<typeof CartWhereInput>;
    @Field(() => CartWhereInput, {nullable:true})
    none?: InstanceType<typeof CartWhereInput>;
}

@InputType()
export class CartMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
    @Field(() => Boolean, {nullable:true})
    membershipItemId?: true;
    @Field(() => Boolean, {nullable:true})
    projectItemId?: true;
    @Field(() => Boolean, {nullable:true})
    quantity?: true;
    @Field(() => Boolean, {nullable:true})
    price?: true;
    @Field(() => Boolean, {nullable:true})
    cost?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class CartMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    orderId?: number;
    @Field(() => Int, {nullable:true})
    membershipItemId?: number;
    @Field(() => Int, {nullable:true})
    projectItemId?: number;
    @Field(() => Int, {nullable:true})
    quantity?: number;
    @Field(() => Float, {nullable:true})
    price?: number;
    @Field(() => Float, {nullable:true})
    cost?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CartMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    membershipItemId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectItemId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    quantity?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class CartMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
    @Field(() => Boolean, {nullable:true})
    membershipItemId?: true;
    @Field(() => Boolean, {nullable:true})
    projectItemId?: true;
    @Field(() => Boolean, {nullable:true})
    quantity?: true;
    @Field(() => Boolean, {nullable:true})
    price?: true;
    @Field(() => Boolean, {nullable:true})
    cost?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class CartMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    orderId?: number;
    @Field(() => Int, {nullable:true})
    membershipItemId?: number;
    @Field(() => Int, {nullable:true})
    projectItemId?: number;
    @Field(() => Int, {nullable:true})
    quantity?: number;
    @Field(() => Float, {nullable:true})
    price?: number;
    @Field(() => Float, {nullable:true})
    cost?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CartMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    membershipItemId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectItemId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    quantity?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class CartOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class CartOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    membershipItemId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    projectItemId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    quantity?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => CartCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof CartCountOrderByAggregateInput>;
    @Field(() => CartAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof CartAvgOrderByAggregateInput>;
    @Field(() => CartMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof CartMaxOrderByAggregateInput>;
    @Field(() => CartMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof CartMinOrderByAggregateInput>;
    @Field(() => CartSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof CartSumOrderByAggregateInput>;
}

@InputType()
export class CartOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    membershipItemId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    projectItemId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    quantity?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => OrderOrderByWithRelationInput, {nullable:true})
    order?: InstanceType<typeof OrderOrderByWithRelationInput>;
    @Field(() => ItemOrderByWithRelationInput, {nullable:true})
    membershipItem?: InstanceType<typeof ItemOrderByWithRelationInput>;
    @Field(() => ProjectOrderByWithRelationInput, {nullable:true})
    projectItem?: InstanceType<typeof ProjectOrderByWithRelationInput>;
}

@InputType()
export class CartScalarWhereWithAggregatesInput {
    @Field(() => [CartScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<CartScalarWhereWithAggregatesInput>;
    @Field(() => [CartScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<CartScalarWhereWithAggregatesInput>;
    @Field(() => [CartScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<CartScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    orderId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => IntNullableWithAggregatesFilter, {nullable:true})
    membershipItemId?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => IntNullableWithAggregatesFilter, {nullable:true})
    projectItemId?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    quantity?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    price?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    cost?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class CartScalarWhereInput {
    @Field(() => [CartScalarWhereInput], {nullable:true})
    AND?: Array<CartScalarWhereInput>;
    @Field(() => [CartScalarWhereInput], {nullable:true})
    OR?: Array<CartScalarWhereInput>;
    @Field(() => [CartScalarWhereInput], {nullable:true})
    NOT?: Array<CartScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    orderId?: InstanceType<typeof IntFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    membershipItemId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    projectItemId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntFilter, {nullable:true})
    quantity?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    price?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    cost?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class CartSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
    @Field(() => Boolean, {nullable:true})
    membershipItemId?: true;
    @Field(() => Boolean, {nullable:true})
    projectItemId?: true;
    @Field(() => Boolean, {nullable:true})
    quantity?: true;
    @Field(() => Boolean, {nullable:true})
    price?: true;
    @Field(() => Boolean, {nullable:true})
    cost?: true;
}

@ObjectType()
export class CartSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    orderId?: number;
    @Field(() => Int, {nullable:true})
    membershipItemId?: number;
    @Field(() => Int, {nullable:true})
    projectItemId?: number;
    @Field(() => Int, {nullable:true})
    quantity?: number;
    @Field(() => Float, {nullable:true})
    price?: number;
    @Field(() => Float, {nullable:true})
    cost?: number;
}

@InputType()
export class CartSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    membershipItemId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectItemId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    quantity?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
}

@InputType()
export class CartUncheckedCreateNestedManyWithoutMembershipItemInput {
    @Field(() => [CartCreateWithoutMembershipItemInput], {nullable:true})
    @Type(() => CartCreateWithoutMembershipItemInput)
    create?: Array<CartCreateWithoutMembershipItemInput>;
    @Field(() => [CartCreateOrConnectWithoutMembershipItemInput], {nullable:true})
    @Type(() => CartCreateOrConnectWithoutMembershipItemInput)
    connectOrCreate?: Array<CartCreateOrConnectWithoutMembershipItemInput>;
    @Field(() => CartCreateManyMembershipItemInputEnvelope, {nullable:true})
    @Type(() => CartCreateManyMembershipItemInputEnvelope)
    createMany?: InstanceType<typeof CartCreateManyMembershipItemInputEnvelope>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
}

@InputType()
export class CartUncheckedCreateNestedManyWithoutOrderInput {
    @Field(() => [CartCreateWithoutOrderInput], {nullable:true})
    @Type(() => CartCreateWithoutOrderInput)
    create?: Array<CartCreateWithoutOrderInput>;
    @Field(() => [CartCreateOrConnectWithoutOrderInput], {nullable:true})
    @Type(() => CartCreateOrConnectWithoutOrderInput)
    connectOrCreate?: Array<CartCreateOrConnectWithoutOrderInput>;
    @Field(() => CartCreateManyOrderInputEnvelope, {nullable:true})
    @Type(() => CartCreateManyOrderInputEnvelope)
    createMany?: InstanceType<typeof CartCreateManyOrderInputEnvelope>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
}

@InputType()
export class CartUncheckedCreateNestedManyWithoutProjectItemInput {
    @Field(() => [CartCreateWithoutProjectItemInput], {nullable:true})
    @Type(() => CartCreateWithoutProjectItemInput)
    create?: Array<CartCreateWithoutProjectItemInput>;
    @Field(() => [CartCreateOrConnectWithoutProjectItemInput], {nullable:true})
    @Type(() => CartCreateOrConnectWithoutProjectItemInput)
    connectOrCreate?: Array<CartCreateOrConnectWithoutProjectItemInput>;
    @Field(() => CartCreateManyProjectItemInputEnvelope, {nullable:true})
    @Type(() => CartCreateManyProjectItemInputEnvelope)
    createMany?: InstanceType<typeof CartCreateManyProjectItemInputEnvelope>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
}

@InputType()
export class CartUncheckedCreateWithoutMembershipItemInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Int, {nullable:true})
    projectItemId?: number;
    @Field(() => Int, {nullable:false})
    quantity!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    price!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    cost!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CartUncheckedCreateWithoutOrderInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    membershipItemId?: number;
    @Field(() => Int, {nullable:true})
    projectItemId?: number;
    @Field(() => Int, {nullable:false})
    quantity!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    price!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    cost!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CartUncheckedCreateWithoutProjectItemInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Int, {nullable:true})
    membershipItemId?: number;
    @Field(() => Int, {nullable:false})
    quantity!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    price!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    cost!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CartUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Int, {nullable:true})
    membershipItemId?: number;
    @Field(() => Int, {nullable:true})
    projectItemId?: number;
    @Field(() => Int, {nullable:false})
    quantity!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    price!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    cost!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CartUncheckedUpdateManyWithoutMembershipItemNestedInput {
    @Field(() => [CartCreateWithoutMembershipItemInput], {nullable:true})
    @Type(() => CartCreateWithoutMembershipItemInput)
    create?: Array<CartCreateWithoutMembershipItemInput>;
    @Field(() => [CartCreateOrConnectWithoutMembershipItemInput], {nullable:true})
    @Type(() => CartCreateOrConnectWithoutMembershipItemInput)
    connectOrCreate?: Array<CartCreateOrConnectWithoutMembershipItemInput>;
    @Field(() => [CartUpsertWithWhereUniqueWithoutMembershipItemInput], {nullable:true})
    @Type(() => CartUpsertWithWhereUniqueWithoutMembershipItemInput)
    upsert?: Array<CartUpsertWithWhereUniqueWithoutMembershipItemInput>;
    @Field(() => CartCreateManyMembershipItemInputEnvelope, {nullable:true})
    @Type(() => CartCreateManyMembershipItemInputEnvelope)
    createMany?: InstanceType<typeof CartCreateManyMembershipItemInputEnvelope>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    set?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartUpdateWithWhereUniqueWithoutMembershipItemInput], {nullable:true})
    @Type(() => CartUpdateWithWhereUniqueWithoutMembershipItemInput)
    update?: Array<CartUpdateWithWhereUniqueWithoutMembershipItemInput>;
    @Field(() => [CartUpdateManyWithWhereWithoutMembershipItemInput], {nullable:true})
    @Type(() => CartUpdateManyWithWhereWithoutMembershipItemInput)
    updateMany?: Array<CartUpdateManyWithWhereWithoutMembershipItemInput>;
    @Field(() => [CartScalarWhereInput], {nullable:true})
    @Type(() => CartScalarWhereInput)
    deleteMany?: Array<CartScalarWhereInput>;
}

@InputType()
export class CartUncheckedUpdateManyWithoutMembershipItemInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    orderId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectItemId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quantity?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CartUncheckedUpdateManyWithoutOrderNestedInput {
    @Field(() => [CartCreateWithoutOrderInput], {nullable:true})
    @Type(() => CartCreateWithoutOrderInput)
    create?: Array<CartCreateWithoutOrderInput>;
    @Field(() => [CartCreateOrConnectWithoutOrderInput], {nullable:true})
    @Type(() => CartCreateOrConnectWithoutOrderInput)
    connectOrCreate?: Array<CartCreateOrConnectWithoutOrderInput>;
    @Field(() => [CartUpsertWithWhereUniqueWithoutOrderInput], {nullable:true})
    @Type(() => CartUpsertWithWhereUniqueWithoutOrderInput)
    upsert?: Array<CartUpsertWithWhereUniqueWithoutOrderInput>;
    @Field(() => CartCreateManyOrderInputEnvelope, {nullable:true})
    @Type(() => CartCreateManyOrderInputEnvelope)
    createMany?: InstanceType<typeof CartCreateManyOrderInputEnvelope>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    set?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartUpdateWithWhereUniqueWithoutOrderInput], {nullable:true})
    @Type(() => CartUpdateWithWhereUniqueWithoutOrderInput)
    update?: Array<CartUpdateWithWhereUniqueWithoutOrderInput>;
    @Field(() => [CartUpdateManyWithWhereWithoutOrderInput], {nullable:true})
    @Type(() => CartUpdateManyWithWhereWithoutOrderInput)
    updateMany?: Array<CartUpdateManyWithWhereWithoutOrderInput>;
    @Field(() => [CartScalarWhereInput], {nullable:true})
    @Type(() => CartScalarWhereInput)
    deleteMany?: Array<CartScalarWhereInput>;
}

@InputType()
export class CartUncheckedUpdateManyWithoutOrderInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    membershipItemId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectItemId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quantity?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CartUncheckedUpdateManyWithoutProjectItemNestedInput {
    @Field(() => [CartCreateWithoutProjectItemInput], {nullable:true})
    @Type(() => CartCreateWithoutProjectItemInput)
    create?: Array<CartCreateWithoutProjectItemInput>;
    @Field(() => [CartCreateOrConnectWithoutProjectItemInput], {nullable:true})
    @Type(() => CartCreateOrConnectWithoutProjectItemInput)
    connectOrCreate?: Array<CartCreateOrConnectWithoutProjectItemInput>;
    @Field(() => [CartUpsertWithWhereUniqueWithoutProjectItemInput], {nullable:true})
    @Type(() => CartUpsertWithWhereUniqueWithoutProjectItemInput)
    upsert?: Array<CartUpsertWithWhereUniqueWithoutProjectItemInput>;
    @Field(() => CartCreateManyProjectItemInputEnvelope, {nullable:true})
    @Type(() => CartCreateManyProjectItemInputEnvelope)
    createMany?: InstanceType<typeof CartCreateManyProjectItemInputEnvelope>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    set?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartUpdateWithWhereUniqueWithoutProjectItemInput], {nullable:true})
    @Type(() => CartUpdateWithWhereUniqueWithoutProjectItemInput)
    update?: Array<CartUpdateWithWhereUniqueWithoutProjectItemInput>;
    @Field(() => [CartUpdateManyWithWhereWithoutProjectItemInput], {nullable:true})
    @Type(() => CartUpdateManyWithWhereWithoutProjectItemInput)
    updateMany?: Array<CartUpdateManyWithWhereWithoutProjectItemInput>;
    @Field(() => [CartScalarWhereInput], {nullable:true})
    @Type(() => CartScalarWhereInput)
    deleteMany?: Array<CartScalarWhereInput>;
}

@InputType()
export class CartUncheckedUpdateManyWithoutProjectItemInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    orderId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    membershipItemId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quantity?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CartUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    orderId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    membershipItemId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectItemId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quantity?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CartUncheckedUpdateWithoutMembershipItemInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    orderId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectItemId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quantity?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CartUncheckedUpdateWithoutOrderInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    membershipItemId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectItemId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quantity?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CartUncheckedUpdateWithoutProjectItemInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    orderId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    membershipItemId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quantity?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CartUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    orderId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    membershipItemId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectItemId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quantity?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CartUpdateManyMutationInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quantity?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CartUpdateManyWithWhereWithoutMembershipItemInput {
    @Field(() => CartScalarWhereInput, {nullable:false})
    @Type(() => CartScalarWhereInput)
    where!: InstanceType<typeof CartScalarWhereInput>;
    @Field(() => CartUpdateManyMutationInput, {nullable:false})
    @Type(() => CartUpdateManyMutationInput)
    data!: InstanceType<typeof CartUpdateManyMutationInput>;
}

@InputType()
export class CartUpdateManyWithWhereWithoutOrderInput {
    @Field(() => CartScalarWhereInput, {nullable:false})
    @Type(() => CartScalarWhereInput)
    where!: InstanceType<typeof CartScalarWhereInput>;
    @Field(() => CartUpdateManyMutationInput, {nullable:false})
    @Type(() => CartUpdateManyMutationInput)
    data!: InstanceType<typeof CartUpdateManyMutationInput>;
}

@InputType()
export class CartUpdateManyWithWhereWithoutProjectItemInput {
    @Field(() => CartScalarWhereInput, {nullable:false})
    @Type(() => CartScalarWhereInput)
    where!: InstanceType<typeof CartScalarWhereInput>;
    @Field(() => CartUpdateManyMutationInput, {nullable:false})
    @Type(() => CartUpdateManyMutationInput)
    data!: InstanceType<typeof CartUpdateManyMutationInput>;
}

@InputType()
export class CartUpdateManyWithoutMembershipItemNestedInput {
    @Field(() => [CartCreateWithoutMembershipItemInput], {nullable:true})
    @Type(() => CartCreateWithoutMembershipItemInput)
    create?: Array<CartCreateWithoutMembershipItemInput>;
    @Field(() => [CartCreateOrConnectWithoutMembershipItemInput], {nullable:true})
    @Type(() => CartCreateOrConnectWithoutMembershipItemInput)
    connectOrCreate?: Array<CartCreateOrConnectWithoutMembershipItemInput>;
    @Field(() => [CartUpsertWithWhereUniqueWithoutMembershipItemInput], {nullable:true})
    @Type(() => CartUpsertWithWhereUniqueWithoutMembershipItemInput)
    upsert?: Array<CartUpsertWithWhereUniqueWithoutMembershipItemInput>;
    @Field(() => CartCreateManyMembershipItemInputEnvelope, {nullable:true})
    @Type(() => CartCreateManyMembershipItemInputEnvelope)
    createMany?: InstanceType<typeof CartCreateManyMembershipItemInputEnvelope>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    set?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartUpdateWithWhereUniqueWithoutMembershipItemInput], {nullable:true})
    @Type(() => CartUpdateWithWhereUniqueWithoutMembershipItemInput)
    update?: Array<CartUpdateWithWhereUniqueWithoutMembershipItemInput>;
    @Field(() => [CartUpdateManyWithWhereWithoutMembershipItemInput], {nullable:true})
    @Type(() => CartUpdateManyWithWhereWithoutMembershipItemInput)
    updateMany?: Array<CartUpdateManyWithWhereWithoutMembershipItemInput>;
    @Field(() => [CartScalarWhereInput], {nullable:true})
    @Type(() => CartScalarWhereInput)
    deleteMany?: Array<CartScalarWhereInput>;
}

@InputType()
export class CartUpdateManyWithoutOrderNestedInput {
    @Field(() => [CartCreateWithoutOrderInput], {nullable:true})
    @Type(() => CartCreateWithoutOrderInput)
    create?: Array<CartCreateWithoutOrderInput>;
    @Field(() => [CartCreateOrConnectWithoutOrderInput], {nullable:true})
    @Type(() => CartCreateOrConnectWithoutOrderInput)
    connectOrCreate?: Array<CartCreateOrConnectWithoutOrderInput>;
    @Field(() => [CartUpsertWithWhereUniqueWithoutOrderInput], {nullable:true})
    @Type(() => CartUpsertWithWhereUniqueWithoutOrderInput)
    upsert?: Array<CartUpsertWithWhereUniqueWithoutOrderInput>;
    @Field(() => CartCreateManyOrderInputEnvelope, {nullable:true})
    @Type(() => CartCreateManyOrderInputEnvelope)
    createMany?: InstanceType<typeof CartCreateManyOrderInputEnvelope>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    set?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartUpdateWithWhereUniqueWithoutOrderInput], {nullable:true})
    @Type(() => CartUpdateWithWhereUniqueWithoutOrderInput)
    update?: Array<CartUpdateWithWhereUniqueWithoutOrderInput>;
    @Field(() => [CartUpdateManyWithWhereWithoutOrderInput], {nullable:true})
    @Type(() => CartUpdateManyWithWhereWithoutOrderInput)
    updateMany?: Array<CartUpdateManyWithWhereWithoutOrderInput>;
    @Field(() => [CartScalarWhereInput], {nullable:true})
    @Type(() => CartScalarWhereInput)
    deleteMany?: Array<CartScalarWhereInput>;
}

@InputType()
export class CartUpdateManyWithoutProjectItemNestedInput {
    @Field(() => [CartCreateWithoutProjectItemInput], {nullable:true})
    @Type(() => CartCreateWithoutProjectItemInput)
    create?: Array<CartCreateWithoutProjectItemInput>;
    @Field(() => [CartCreateOrConnectWithoutProjectItemInput], {nullable:true})
    @Type(() => CartCreateOrConnectWithoutProjectItemInput)
    connectOrCreate?: Array<CartCreateOrConnectWithoutProjectItemInput>;
    @Field(() => [CartUpsertWithWhereUniqueWithoutProjectItemInput], {nullable:true})
    @Type(() => CartUpsertWithWhereUniqueWithoutProjectItemInput)
    upsert?: Array<CartUpsertWithWhereUniqueWithoutProjectItemInput>;
    @Field(() => CartCreateManyProjectItemInputEnvelope, {nullable:true})
    @Type(() => CartCreateManyProjectItemInputEnvelope)
    createMany?: InstanceType<typeof CartCreateManyProjectItemInputEnvelope>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    set?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartWhereUniqueInput], {nullable:true})
    @Type(() => CartWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CartWhereUniqueInput, 'id'>>;
    @Field(() => [CartUpdateWithWhereUniqueWithoutProjectItemInput], {nullable:true})
    @Type(() => CartUpdateWithWhereUniqueWithoutProjectItemInput)
    update?: Array<CartUpdateWithWhereUniqueWithoutProjectItemInput>;
    @Field(() => [CartUpdateManyWithWhereWithoutProjectItemInput], {nullable:true})
    @Type(() => CartUpdateManyWithWhereWithoutProjectItemInput)
    updateMany?: Array<CartUpdateManyWithWhereWithoutProjectItemInput>;
    @Field(() => [CartScalarWhereInput], {nullable:true})
    @Type(() => CartScalarWhereInput)
    deleteMany?: Array<CartScalarWhereInput>;
}

@InputType()
export class CartUpdateWithWhereUniqueWithoutMembershipItemInput {
    @Field(() => CartWhereUniqueInput, {nullable:false})
    @Type(() => CartWhereUniqueInput)
    where!: Prisma.AtLeast<CartWhereUniqueInput, 'id'>;
    @Field(() => CartUpdateWithoutMembershipItemInput, {nullable:false})
    @Type(() => CartUpdateWithoutMembershipItemInput)
    data!: InstanceType<typeof CartUpdateWithoutMembershipItemInput>;
}

@InputType()
export class CartUpdateWithWhereUniqueWithoutOrderInput {
    @Field(() => CartWhereUniqueInput, {nullable:false})
    @Type(() => CartWhereUniqueInput)
    where!: Prisma.AtLeast<CartWhereUniqueInput, 'id'>;
    @Field(() => CartUpdateWithoutOrderInput, {nullable:false})
    @Type(() => CartUpdateWithoutOrderInput)
    data!: InstanceType<typeof CartUpdateWithoutOrderInput>;
}

@InputType()
export class CartUpdateWithWhereUniqueWithoutProjectItemInput {
    @Field(() => CartWhereUniqueInput, {nullable:false})
    @Type(() => CartWhereUniqueInput)
    where!: Prisma.AtLeast<CartWhereUniqueInput, 'id'>;
    @Field(() => CartUpdateWithoutProjectItemInput, {nullable:false})
    @Type(() => CartUpdateWithoutProjectItemInput)
    data!: InstanceType<typeof CartUpdateWithoutProjectItemInput>;
}

@InputType()
export class CartUpdateWithoutMembershipItemInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quantity?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => OrderUpdateOneRequiredWithoutCartNestedInput, {nullable:true})
    order?: InstanceType<typeof OrderUpdateOneRequiredWithoutCartNestedInput>;
    @Field(() => ProjectUpdateOneWithoutOrderCartNestedInput, {nullable:true})
    projectItem?: InstanceType<typeof ProjectUpdateOneWithoutOrderCartNestedInput>;
}

@InputType()
export class CartUpdateWithoutOrderInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quantity?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ItemUpdateOneWithoutCartNestedInput, {nullable:true})
    membershipItem?: InstanceType<typeof ItemUpdateOneWithoutCartNestedInput>;
    @Field(() => ProjectUpdateOneWithoutOrderCartNestedInput, {nullable:true})
    projectItem?: InstanceType<typeof ProjectUpdateOneWithoutOrderCartNestedInput>;
}

@InputType()
export class CartUpdateWithoutProjectItemInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quantity?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => OrderUpdateOneRequiredWithoutCartNestedInput, {nullable:true})
    order?: InstanceType<typeof OrderUpdateOneRequiredWithoutCartNestedInput>;
    @Field(() => ItemUpdateOneWithoutCartNestedInput, {nullable:true})
    membershipItem?: InstanceType<typeof ItemUpdateOneWithoutCartNestedInput>;
}

@InputType()
export class CartUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quantity?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => OrderUpdateOneRequiredWithoutCartNestedInput, {nullable:true})
    order?: InstanceType<typeof OrderUpdateOneRequiredWithoutCartNestedInput>;
    @Field(() => ItemUpdateOneWithoutCartNestedInput, {nullable:true})
    membershipItem?: InstanceType<typeof ItemUpdateOneWithoutCartNestedInput>;
    @Field(() => ProjectUpdateOneWithoutOrderCartNestedInput, {nullable:true})
    projectItem?: InstanceType<typeof ProjectUpdateOneWithoutOrderCartNestedInput>;
}

@InputType()
export class CartUpsertWithWhereUniqueWithoutMembershipItemInput {
    @Field(() => CartWhereUniqueInput, {nullable:false})
    @Type(() => CartWhereUniqueInput)
    where!: Prisma.AtLeast<CartWhereUniqueInput, 'id'>;
    @Field(() => CartUpdateWithoutMembershipItemInput, {nullable:false})
    @Type(() => CartUpdateWithoutMembershipItemInput)
    update!: InstanceType<typeof CartUpdateWithoutMembershipItemInput>;
    @Field(() => CartCreateWithoutMembershipItemInput, {nullable:false})
    @Type(() => CartCreateWithoutMembershipItemInput)
    create!: InstanceType<typeof CartCreateWithoutMembershipItemInput>;
}

@InputType()
export class CartUpsertWithWhereUniqueWithoutOrderInput {
    @Field(() => CartWhereUniqueInput, {nullable:false})
    @Type(() => CartWhereUniqueInput)
    where!: Prisma.AtLeast<CartWhereUniqueInput, 'id'>;
    @Field(() => CartUpdateWithoutOrderInput, {nullable:false})
    @Type(() => CartUpdateWithoutOrderInput)
    update!: InstanceType<typeof CartUpdateWithoutOrderInput>;
    @Field(() => CartCreateWithoutOrderInput, {nullable:false})
    @Type(() => CartCreateWithoutOrderInput)
    create!: InstanceType<typeof CartCreateWithoutOrderInput>;
}

@InputType()
export class CartUpsertWithWhereUniqueWithoutProjectItemInput {
    @Field(() => CartWhereUniqueInput, {nullable:false})
    @Type(() => CartWhereUniqueInput)
    where!: Prisma.AtLeast<CartWhereUniqueInput, 'id'>;
    @Field(() => CartUpdateWithoutProjectItemInput, {nullable:false})
    @Type(() => CartUpdateWithoutProjectItemInput)
    update!: InstanceType<typeof CartUpdateWithoutProjectItemInput>;
    @Field(() => CartCreateWithoutProjectItemInput, {nullable:false})
    @Type(() => CartCreateWithoutProjectItemInput)
    create!: InstanceType<typeof CartCreateWithoutProjectItemInput>;
}

@InputType()
export class CartWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [CartWhereInput], {nullable:true})
    AND?: Array<CartWhereInput>;
    @Field(() => [CartWhereInput], {nullable:true})
    OR?: Array<CartWhereInput>;
    @Field(() => [CartWhereInput], {nullable:true})
    NOT?: Array<CartWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    orderId?: InstanceType<typeof IntFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    membershipItemId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    projectItemId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntFilter, {nullable:true})
    quantity?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    price?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    cost?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => OrderRelationFilter, {nullable:true})
    order?: InstanceType<typeof OrderRelationFilter>;
    @Field(() => ItemNullableRelationFilter, {nullable:true})
    membershipItem?: InstanceType<typeof ItemNullableRelationFilter>;
    @Field(() => ProjectNullableRelationFilter, {nullable:true})
    projectItem?: InstanceType<typeof ProjectNullableRelationFilter>;
}

@InputType()
export class CartWhereInput {
    @Field(() => [CartWhereInput], {nullable:true})
    AND?: Array<CartWhereInput>;
    @Field(() => [CartWhereInput], {nullable:true})
    OR?: Array<CartWhereInput>;
    @Field(() => [CartWhereInput], {nullable:true})
    NOT?: Array<CartWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    orderId?: InstanceType<typeof IntFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    membershipItemId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    projectItemId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntFilter, {nullable:true})
    quantity?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    price?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    cost?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => OrderRelationFilter, {nullable:true})
    order?: InstanceType<typeof OrderRelationFilter>;
    @Field(() => ItemNullableRelationFilter, {nullable:true})
    membershipItem?: InstanceType<typeof ItemNullableRelationFilter>;
    @Field(() => ProjectNullableRelationFilter, {nullable:true})
    projectItem?: InstanceType<typeof ProjectNullableRelationFilter>;
}

@ObjectType()
export class Cart {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Int, {nullable:true})
    membershipItemId!: number | null;
    @Field(() => Int, {nullable:true})
    projectItemId!: number | null;
    @Field(() => Int, {nullable:false})
    quantity!: number;
    @Field(() => Float, {nullable:false})
    price!: number;
    @Field(() => Float, {nullable:false})
    cost!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => Order, {nullable:false})
    order?: InstanceType<typeof Order>;
    @Field(() => Item, {nullable:true})
    membershipItem?: InstanceType<typeof Item> | null;
    @Field(() => Project, {nullable:true})
    projectItem?: InstanceType<typeof Project> | null;
}

@ArgsType()
export class CreateManyCartArgs {
    @Field(() => [CartCreateManyInput], {nullable:false})
    @Type(() => CartCreateManyInput)
    data!: Array<CartCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneCartArgs {
    @Field(() => CartCreateInput, {nullable:false})
    @Type(() => CartCreateInput)
    data!: InstanceType<typeof CartCreateInput>;
}

@ArgsType()
export class DeleteManyCartArgs {
    @Field(() => CartWhereInput, {nullable:true})
    @Type(() => CartWhereInput)
    where?: InstanceType<typeof CartWhereInput>;
}

@ArgsType()
export class DeleteOneCartArgs {
    @Field(() => CartWhereUniqueInput, {nullable:false})
    @Type(() => CartWhereUniqueInput)
    where!: Prisma.AtLeast<CartWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstCartOrThrowArgs {
    @Field(() => CartWhereInput, {nullable:true})
    @Type(() => CartWhereInput)
    where?: InstanceType<typeof CartWhereInput>;
    @Field(() => [CartOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CartOrderByWithRelationInput>;
    @Field(() => CartWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CartWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [CartScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof CartScalarFieldEnum>;
}

@ArgsType()
export class FindFirstCartArgs {
    @Field(() => CartWhereInput, {nullable:true})
    @Type(() => CartWhereInput)
    where?: InstanceType<typeof CartWhereInput>;
    @Field(() => [CartOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CartOrderByWithRelationInput>;
    @Field(() => CartWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CartWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [CartScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof CartScalarFieldEnum>;
}

@ArgsType()
export class FindManyCartArgs {
    @Field(() => CartWhereInput, {nullable:true})
    @Type(() => CartWhereInput)
    where?: InstanceType<typeof CartWhereInput>;
    @Field(() => [CartOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CartOrderByWithRelationInput>;
    @Field(() => CartWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CartWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [CartScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof CartScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueCartOrThrowArgs {
    @Field(() => CartWhereUniqueInput, {nullable:false})
    @Type(() => CartWhereUniqueInput)
    where!: Prisma.AtLeast<CartWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueCartArgs {
    @Field(() => CartWhereUniqueInput, {nullable:false})
    @Type(() => CartWhereUniqueInput)
    where!: Prisma.AtLeast<CartWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpdateManyCartArgs {
    @Field(() => CartUpdateManyMutationInput, {nullable:false})
    @Type(() => CartUpdateManyMutationInput)
    data!: InstanceType<typeof CartUpdateManyMutationInput>;
    @Field(() => CartWhereInput, {nullable:true})
    @Type(() => CartWhereInput)
    where?: InstanceType<typeof CartWhereInput>;
}

@ArgsType()
export class UpdateOneCartArgs {
    @Field(() => CartUpdateInput, {nullable:false})
    @Type(() => CartUpdateInput)
    data!: InstanceType<typeof CartUpdateInput>;
    @Field(() => CartWhereUniqueInput, {nullable:false})
    @Type(() => CartWhereUniqueInput)
    where!: Prisma.AtLeast<CartWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneCartArgs {
    @Field(() => CartWhereUniqueInput, {nullable:false})
    @Type(() => CartWhereUniqueInput)
    where!: Prisma.AtLeast<CartWhereUniqueInput, 'id'>;
    @Field(() => CartCreateInput, {nullable:false})
    @Type(() => CartCreateInput)
    create!: InstanceType<typeof CartCreateInput>;
    @Field(() => CartUpdateInput, {nullable:false})
    @Type(() => CartUpdateInput)
    update!: InstanceType<typeof CartUpdateInput>;
}

@ObjectType()
export class AggregateCheckIn {
    @Field(() => CheckInCountAggregate, {nullable:true})
    _count?: InstanceType<typeof CheckInCountAggregate>;
    @Field(() => CheckInAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof CheckInAvgAggregate>;
    @Field(() => CheckInSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof CheckInSumAggregate>;
    @Field(() => CheckInMinAggregate, {nullable:true})
    _min?: InstanceType<typeof CheckInMinAggregate>;
    @Field(() => CheckInMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof CheckInMaxAggregate>;
}

@ArgsType()
export class CheckInAggregateArgs {
    @Field(() => CheckInWhereInput, {nullable:true})
    @Type(() => CheckInWhereInput)
    where?: InstanceType<typeof CheckInWhereInput>;
    @Field(() => [CheckInOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CheckInOrderByWithRelationInput>;
    @Field(() => CheckInWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => CheckInCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof CheckInCountAggregateInput>;
    @Field(() => CheckInAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof CheckInAvgAggregateInput>;
    @Field(() => CheckInSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof CheckInSumAggregateInput>;
    @Field(() => CheckInMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof CheckInMinAggregateInput>;
    @Field(() => CheckInMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof CheckInMaxAggregateInput>;
}

@InputType()
export class CheckInAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    hotelId?: true;
}

@ObjectType()
export class CheckInAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    hotelId?: number;
}

@InputType()
export class CheckInAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelId?: keyof typeof SortOrder;
}

@InputType()
export class CheckInCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    hotelId?: true;
    @Field(() => Boolean, {nullable:true})
    checkInAt?: true;
    @HideField()
    createdAt?: true;
    @HideField()
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class CheckInCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    userId!: number;
    @Field(() => Int, {nullable:false})
    hotelId!: number;
    @Field(() => Int, {nullable:false})
    checkInAt!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class CheckInCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    checkInAt?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class CheckInCreateManyHotelInputEnvelope {
    @Field(() => [CheckInCreateManyHotelInput], {nullable:false})
    @Type(() => CheckInCreateManyHotelInput)
    data!: Array<CheckInCreateManyHotelInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class CheckInCreateManyHotelInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class CheckInCreateManyUserInputEnvelope {
    @Field(() => [CheckInCreateManyUserInput], {nullable:false})
    @Type(() => CheckInCreateManyUserInput)
    data!: Array<CheckInCreateManyUserInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class CheckInCreateManyUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    hotelId!: number;
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class CheckInCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Int, {nullable:false})
    hotelId!: number;
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class CheckInCreateNestedManyWithoutHotelInput {
    @Field(() => [CheckInCreateWithoutHotelInput], {nullable:true})
    @Type(() => CheckInCreateWithoutHotelInput)
    create?: Array<CheckInCreateWithoutHotelInput>;
    @Field(() => [CheckInCreateOrConnectWithoutHotelInput], {nullable:true})
    @Type(() => CheckInCreateOrConnectWithoutHotelInput)
    connectOrCreate?: Array<CheckInCreateOrConnectWithoutHotelInput>;
    @Field(() => CheckInCreateManyHotelInputEnvelope, {nullable:true})
    @Type(() => CheckInCreateManyHotelInputEnvelope)
    createMany?: InstanceType<typeof CheckInCreateManyHotelInputEnvelope>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
}

@InputType()
export class CheckInCreateNestedManyWithoutUserInput {
    @Field(() => [CheckInCreateWithoutUserInput], {nullable:true})
    @Type(() => CheckInCreateWithoutUserInput)
    create?: Array<CheckInCreateWithoutUserInput>;
    @Field(() => [CheckInCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => CheckInCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<CheckInCreateOrConnectWithoutUserInput>;
    @Field(() => CheckInCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => CheckInCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof CheckInCreateManyUserInputEnvelope>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
}

@InputType()
export class CheckInCreateOrConnectWithoutHotelInput {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => CheckInCreateWithoutHotelInput, {nullable:false})
    @Type(() => CheckInCreateWithoutHotelInput)
    create!: InstanceType<typeof CheckInCreateWithoutHotelInput>;
}

@InputType()
export class CheckInCreateOrConnectWithoutUserInput {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => CheckInCreateWithoutUserInput, {nullable:false})
    @Type(() => CheckInCreateWithoutUserInput)
    create!: InstanceType<typeof CheckInCreateWithoutUserInput>;
}

@InputType()
export class CheckInCreateWithoutHotelInput {
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutCheckInsInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutCheckInsInput>;
}

@InputType()
export class CheckInCreateWithoutUserInput {
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => HotelCreateNestedOneWithoutCheckInsInput, {nullable:false})
    hotel!: InstanceType<typeof HotelCreateNestedOneWithoutCheckInsInput>;
}

@InputType()
export class CheckInCreateInput {
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutCheckInsInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutCheckInsInput>;
    @Field(() => HotelCreateNestedOneWithoutCheckInsInput, {nullable:false})
    hotel!: InstanceType<typeof HotelCreateNestedOneWithoutCheckInsInput>;
}

@ArgsType()
export class CheckInGroupByArgs {
    @Field(() => CheckInWhereInput, {nullable:true})
    @Type(() => CheckInWhereInput)
    where?: InstanceType<typeof CheckInWhereInput>;
    @Field(() => [CheckInOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<CheckInOrderByWithAggregationInput>;
    @Field(() => [CheckInScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof CheckInScalarFieldEnum>;
    @Field(() => CheckInScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof CheckInScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => CheckInCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof CheckInCountAggregateInput>;
    @Field(() => CheckInAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof CheckInAvgAggregateInput>;
    @Field(() => CheckInSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof CheckInSumAggregateInput>;
    @Field(() => CheckInMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof CheckInMinAggregateInput>;
    @Field(() => CheckInMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof CheckInMaxAggregateInput>;
}

@ObjectType()
export class CheckInGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Int, {nullable:false})
    hotelId!: number;
    @Field(() => Date, {nullable:false})
    checkInAt!: Date | string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => CheckInCountAggregate, {nullable:true})
    _count?: InstanceType<typeof CheckInCountAggregate>;
    @Field(() => CheckInAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof CheckInAvgAggregate>;
    @Field(() => CheckInSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof CheckInSumAggregate>;
    @Field(() => CheckInMinAggregate, {nullable:true})
    _min?: InstanceType<typeof CheckInMinAggregate>;
    @Field(() => CheckInMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof CheckInMaxAggregate>;
}

@InputType()
export class CheckInListRelationFilter {
    @Field(() => CheckInWhereInput, {nullable:true})
    every?: InstanceType<typeof CheckInWhereInput>;
    @Field(() => CheckInWhereInput, {nullable:true})
    some?: InstanceType<typeof CheckInWhereInput>;
    @Field(() => CheckInWhereInput, {nullable:true})
    none?: InstanceType<typeof CheckInWhereInput>;
}

@InputType()
export class CheckInMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    hotelId?: true;
    @Field(() => Boolean, {nullable:true})
    checkInAt?: true;
    @HideField()
    createdAt?: true;
    @HideField()
    updatedAt?: true;
}

@ObjectType()
export class CheckInMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => Int, {nullable:true})
    hotelId?: number;
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CheckInMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    checkInAt?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class CheckInMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    hotelId?: true;
    @Field(() => Boolean, {nullable:true})
    checkInAt?: true;
    @HideField()
    createdAt?: true;
    @HideField()
    updatedAt?: true;
}

@ObjectType()
export class CheckInMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => Int, {nullable:true})
    hotelId?: number;
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class CheckInMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    checkInAt?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class CheckInOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class CheckInOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    checkInAt?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
    @Field(() => CheckInCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof CheckInCountOrderByAggregateInput>;
    @Field(() => CheckInAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof CheckInAvgOrderByAggregateInput>;
    @Field(() => CheckInMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof CheckInMaxOrderByAggregateInput>;
    @Field(() => CheckInMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof CheckInMinOrderByAggregateInput>;
    @Field(() => CheckInSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof CheckInSumOrderByAggregateInput>;
}

@InputType()
export class CheckInOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    checkInAt?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    user?: InstanceType<typeof UserOrderByWithRelationInput>;
    @Field(() => HotelOrderByWithRelationInput, {nullable:true})
    hotel?: InstanceType<typeof HotelOrderByWithRelationInput>;
}

@InputType()
export class CheckInScalarWhereWithAggregatesInput {
    @Field(() => [CheckInScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<CheckInScalarWhereWithAggregatesInput>;
    @Field(() => [CheckInScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<CheckInScalarWhereWithAggregatesInput>;
    @Field(() => [CheckInScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<CheckInScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    userId?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    hotelId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class CheckInScalarWhereInput {
    @Field(() => [CheckInScalarWhereInput], {nullable:true})
    AND?: Array<CheckInScalarWhereInput>;
    @Field(() => [CheckInScalarWhereInput], {nullable:true})
    OR?: Array<CheckInScalarWhereInput>;
    @Field(() => [CheckInScalarWhereInput], {nullable:true})
    NOT?: Array<CheckInScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    hotelId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFilter>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class CheckInSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    hotelId?: true;
}

@ObjectType()
export class CheckInSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    hotelId?: number;
}

@InputType()
export class CheckInSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelId?: keyof typeof SortOrder;
}

@InputType()
export class CheckInUncheckedCreateNestedManyWithoutHotelInput {
    @Field(() => [CheckInCreateWithoutHotelInput], {nullable:true})
    @Type(() => CheckInCreateWithoutHotelInput)
    create?: Array<CheckInCreateWithoutHotelInput>;
    @Field(() => [CheckInCreateOrConnectWithoutHotelInput], {nullable:true})
    @Type(() => CheckInCreateOrConnectWithoutHotelInput)
    connectOrCreate?: Array<CheckInCreateOrConnectWithoutHotelInput>;
    @Field(() => CheckInCreateManyHotelInputEnvelope, {nullable:true})
    @Type(() => CheckInCreateManyHotelInputEnvelope)
    createMany?: InstanceType<typeof CheckInCreateManyHotelInputEnvelope>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
}

@InputType()
export class CheckInUncheckedCreateNestedManyWithoutUserInput {
    @Field(() => [CheckInCreateWithoutUserInput], {nullable:true})
    @Type(() => CheckInCreateWithoutUserInput)
    create?: Array<CheckInCreateWithoutUserInput>;
    @Field(() => [CheckInCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => CheckInCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<CheckInCreateOrConnectWithoutUserInput>;
    @Field(() => CheckInCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => CheckInCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof CheckInCreateManyUserInputEnvelope>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
}

@InputType()
export class CheckInUncheckedCreateWithoutHotelInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class CheckInUncheckedCreateWithoutUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    hotelId!: number;
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class CheckInUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Int, {nullable:false})
    hotelId!: number;
    @Field(() => Date, {nullable:true})
    checkInAt?: Date | string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class CheckInUncheckedUpdateManyWithoutHotelNestedInput {
    @Field(() => [CheckInCreateWithoutHotelInput], {nullable:true})
    @Type(() => CheckInCreateWithoutHotelInput)
    create?: Array<CheckInCreateWithoutHotelInput>;
    @Field(() => [CheckInCreateOrConnectWithoutHotelInput], {nullable:true})
    @Type(() => CheckInCreateOrConnectWithoutHotelInput)
    connectOrCreate?: Array<CheckInCreateOrConnectWithoutHotelInput>;
    @Field(() => [CheckInUpsertWithWhereUniqueWithoutHotelInput], {nullable:true})
    @Type(() => CheckInUpsertWithWhereUniqueWithoutHotelInput)
    upsert?: Array<CheckInUpsertWithWhereUniqueWithoutHotelInput>;
    @Field(() => CheckInCreateManyHotelInputEnvelope, {nullable:true})
    @Type(() => CheckInCreateManyHotelInputEnvelope)
    createMany?: InstanceType<typeof CheckInCreateManyHotelInputEnvelope>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    set?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInUpdateWithWhereUniqueWithoutHotelInput], {nullable:true})
    @Type(() => CheckInUpdateWithWhereUniqueWithoutHotelInput)
    update?: Array<CheckInUpdateWithWhereUniqueWithoutHotelInput>;
    @Field(() => [CheckInUpdateManyWithWhereWithoutHotelInput], {nullable:true})
    @Type(() => CheckInUpdateManyWithWhereWithoutHotelInput)
    updateMany?: Array<CheckInUpdateManyWithWhereWithoutHotelInput>;
    @Field(() => [CheckInScalarWhereInput], {nullable:true})
    @Type(() => CheckInScalarWhereInput)
    deleteMany?: Array<CheckInScalarWhereInput>;
}

@InputType()
export class CheckInUncheckedUpdateManyWithoutHotelInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CheckInUncheckedUpdateManyWithoutUserNestedInput {
    @Field(() => [CheckInCreateWithoutUserInput], {nullable:true})
    @Type(() => CheckInCreateWithoutUserInput)
    create?: Array<CheckInCreateWithoutUserInput>;
    @Field(() => [CheckInCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => CheckInCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<CheckInCreateOrConnectWithoutUserInput>;
    @Field(() => [CheckInUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => CheckInUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<CheckInUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => CheckInCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => CheckInCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof CheckInCreateManyUserInputEnvelope>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    set?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => CheckInUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<CheckInUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [CheckInUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => CheckInUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<CheckInUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [CheckInScalarWhereInput], {nullable:true})
    @Type(() => CheckInScalarWhereInput)
    deleteMany?: Array<CheckInScalarWhereInput>;
}

@InputType()
export class CheckInUncheckedUpdateManyWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    hotelId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CheckInUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    hotelId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CheckInUncheckedUpdateWithoutHotelInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CheckInUncheckedUpdateWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    hotelId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CheckInUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    hotelId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CheckInUpdateManyMutationInput {
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class CheckInUpdateManyWithWhereWithoutHotelInput {
    @Field(() => CheckInScalarWhereInput, {nullable:false})
    @Type(() => CheckInScalarWhereInput)
    where!: InstanceType<typeof CheckInScalarWhereInput>;
    @Field(() => CheckInUpdateManyMutationInput, {nullable:false})
    @Type(() => CheckInUpdateManyMutationInput)
    data!: InstanceType<typeof CheckInUpdateManyMutationInput>;
}

@InputType()
export class CheckInUpdateManyWithWhereWithoutUserInput {
    @Field(() => CheckInScalarWhereInput, {nullable:false})
    @Type(() => CheckInScalarWhereInput)
    where!: InstanceType<typeof CheckInScalarWhereInput>;
    @Field(() => CheckInUpdateManyMutationInput, {nullable:false})
    @Type(() => CheckInUpdateManyMutationInput)
    data!: InstanceType<typeof CheckInUpdateManyMutationInput>;
}

@InputType()
export class CheckInUpdateManyWithoutHotelNestedInput {
    @Field(() => [CheckInCreateWithoutHotelInput], {nullable:true})
    @Type(() => CheckInCreateWithoutHotelInput)
    create?: Array<CheckInCreateWithoutHotelInput>;
    @Field(() => [CheckInCreateOrConnectWithoutHotelInput], {nullable:true})
    @Type(() => CheckInCreateOrConnectWithoutHotelInput)
    connectOrCreate?: Array<CheckInCreateOrConnectWithoutHotelInput>;
    @Field(() => [CheckInUpsertWithWhereUniqueWithoutHotelInput], {nullable:true})
    @Type(() => CheckInUpsertWithWhereUniqueWithoutHotelInput)
    upsert?: Array<CheckInUpsertWithWhereUniqueWithoutHotelInput>;
    @Field(() => CheckInCreateManyHotelInputEnvelope, {nullable:true})
    @Type(() => CheckInCreateManyHotelInputEnvelope)
    createMany?: InstanceType<typeof CheckInCreateManyHotelInputEnvelope>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    set?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInUpdateWithWhereUniqueWithoutHotelInput], {nullable:true})
    @Type(() => CheckInUpdateWithWhereUniqueWithoutHotelInput)
    update?: Array<CheckInUpdateWithWhereUniqueWithoutHotelInput>;
    @Field(() => [CheckInUpdateManyWithWhereWithoutHotelInput], {nullable:true})
    @Type(() => CheckInUpdateManyWithWhereWithoutHotelInput)
    updateMany?: Array<CheckInUpdateManyWithWhereWithoutHotelInput>;
    @Field(() => [CheckInScalarWhereInput], {nullable:true})
    @Type(() => CheckInScalarWhereInput)
    deleteMany?: Array<CheckInScalarWhereInput>;
}

@InputType()
export class CheckInUpdateManyWithoutUserNestedInput {
    @Field(() => [CheckInCreateWithoutUserInput], {nullable:true})
    @Type(() => CheckInCreateWithoutUserInput)
    create?: Array<CheckInCreateWithoutUserInput>;
    @Field(() => [CheckInCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => CheckInCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<CheckInCreateOrConnectWithoutUserInput>;
    @Field(() => [CheckInUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => CheckInUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<CheckInUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => CheckInCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => CheckInCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof CheckInCreateManyUserInputEnvelope>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    set?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInWhereUniqueInput], {nullable:true})
    @Type(() => CheckInWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>>;
    @Field(() => [CheckInUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => CheckInUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<CheckInUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [CheckInUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => CheckInUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<CheckInUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [CheckInScalarWhereInput], {nullable:true})
    @Type(() => CheckInScalarWhereInput)
    deleteMany?: Array<CheckInScalarWhereInput>;
}

@InputType()
export class CheckInUpdateWithWhereUniqueWithoutHotelInput {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => CheckInUpdateWithoutHotelInput, {nullable:false})
    @Type(() => CheckInUpdateWithoutHotelInput)
    data!: InstanceType<typeof CheckInUpdateWithoutHotelInput>;
}

@InputType()
export class CheckInUpdateWithWhereUniqueWithoutUserInput {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => CheckInUpdateWithoutUserInput, {nullable:false})
    @Type(() => CheckInUpdateWithoutUserInput)
    data!: InstanceType<typeof CheckInUpdateWithoutUserInput>;
}

@InputType()
export class CheckInUpdateWithoutHotelInput {
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutCheckInsNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutCheckInsNestedInput>;
}

@InputType()
export class CheckInUpdateWithoutUserInput {
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => HotelUpdateOneRequiredWithoutCheckInsNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUpdateOneRequiredWithoutCheckInsNestedInput>;
}

@InputType()
export class CheckInUpdateInput {
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutCheckInsNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutCheckInsNestedInput>;
    @Field(() => HotelUpdateOneRequiredWithoutCheckInsNestedInput, {nullable:true})
    hotel?: InstanceType<typeof HotelUpdateOneRequiredWithoutCheckInsNestedInput>;
}

@InputType()
export class CheckInUpsertWithWhereUniqueWithoutHotelInput {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => CheckInUpdateWithoutHotelInput, {nullable:false})
    @Type(() => CheckInUpdateWithoutHotelInput)
    update!: InstanceType<typeof CheckInUpdateWithoutHotelInput>;
    @Field(() => CheckInCreateWithoutHotelInput, {nullable:false})
    @Type(() => CheckInCreateWithoutHotelInput)
    create!: InstanceType<typeof CheckInCreateWithoutHotelInput>;
}

@InputType()
export class CheckInUpsertWithWhereUniqueWithoutUserInput {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => CheckInUpdateWithoutUserInput, {nullable:false})
    @Type(() => CheckInUpdateWithoutUserInput)
    update!: InstanceType<typeof CheckInUpdateWithoutUserInput>;
    @Field(() => CheckInCreateWithoutUserInput, {nullable:false})
    @Type(() => CheckInCreateWithoutUserInput)
    create!: InstanceType<typeof CheckInCreateWithoutUserInput>;
}

@InputType()
export class CheckInWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [CheckInWhereInput], {nullable:true})
    AND?: Array<CheckInWhereInput>;
    @Field(() => [CheckInWhereInput], {nullable:true})
    OR?: Array<CheckInWhereInput>;
    @Field(() => [CheckInWhereInput], {nullable:true})
    NOT?: Array<CheckInWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    hotelId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFilter>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
    @Field(() => HotelRelationFilter, {nullable:true})
    hotel?: InstanceType<typeof HotelRelationFilter>;
}

@InputType()
export class CheckInWhereInput {
    @Field(() => [CheckInWhereInput], {nullable:true})
    AND?: Array<CheckInWhereInput>;
    @Field(() => [CheckInWhereInput], {nullable:true})
    OR?: Array<CheckInWhereInput>;
    @Field(() => [CheckInWhereInput], {nullable:true})
    NOT?: Array<CheckInWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    hotelId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    checkInAt?: InstanceType<typeof DateTimeFilter>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
    @Field(() => HotelRelationFilter, {nullable:true})
    hotel?: InstanceType<typeof HotelRelationFilter>;
}

@ObjectType()
export class CheckIn {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Int, {nullable:false})
    hotelId!: number;
    @Field(() => Date, {nullable:false})
    checkInAt!: Date;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => User, {nullable:false})
    user?: InstanceType<typeof User>;
    @Field(() => Hotel, {nullable:false})
    hotel?: InstanceType<typeof Hotel>;
}

@ArgsType()
export class CreateManyCheckInArgs {
    @Field(() => [CheckInCreateManyInput], {nullable:false})
    @Type(() => CheckInCreateManyInput)
    data!: Array<CheckInCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneCheckInArgs {
    @Field(() => CheckInCreateInput, {nullable:false})
    @Type(() => CheckInCreateInput)
    data!: InstanceType<typeof CheckInCreateInput>;
}

@ArgsType()
export class DeleteManyCheckInArgs {
    @Field(() => CheckInWhereInput, {nullable:true})
    @Type(() => CheckInWhereInput)
    where?: InstanceType<typeof CheckInWhereInput>;
}

@ArgsType()
export class DeleteOneCheckInArgs {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstCheckInOrThrowArgs {
    @Field(() => CheckInWhereInput, {nullable:true})
    @Type(() => CheckInWhereInput)
    where?: InstanceType<typeof CheckInWhereInput>;
    @Field(() => [CheckInOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CheckInOrderByWithRelationInput>;
    @Field(() => CheckInWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [CheckInScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof CheckInScalarFieldEnum>;
}

@ArgsType()
export class FindFirstCheckInArgs {
    @Field(() => CheckInWhereInput, {nullable:true})
    @Type(() => CheckInWhereInput)
    where?: InstanceType<typeof CheckInWhereInput>;
    @Field(() => [CheckInOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CheckInOrderByWithRelationInput>;
    @Field(() => CheckInWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [CheckInScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof CheckInScalarFieldEnum>;
}

@ArgsType()
export class FindManyCheckInArgs {
    @Field(() => CheckInWhereInput, {nullable:true})
    @Type(() => CheckInWhereInput)
    where?: InstanceType<typeof CheckInWhereInput>;
    @Field(() => [CheckInOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CheckInOrderByWithRelationInput>;
    @Field(() => CheckInWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [CheckInScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof CheckInScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueCheckInOrThrowArgs {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueCheckInArgs {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpdateManyCheckInArgs {
    @Field(() => CheckInUpdateManyMutationInput, {nullable:false})
    @Type(() => CheckInUpdateManyMutationInput)
    data!: InstanceType<typeof CheckInUpdateManyMutationInput>;
    @Field(() => CheckInWhereInput, {nullable:true})
    @Type(() => CheckInWhereInput)
    where?: InstanceType<typeof CheckInWhereInput>;
}

@ArgsType()
export class UpdateOneCheckInArgs {
    @Field(() => CheckInUpdateInput, {nullable:false})
    @Type(() => CheckInUpdateInput)
    data!: InstanceType<typeof CheckInUpdateInput>;
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneCheckInArgs {
    @Field(() => CheckInWhereUniqueInput, {nullable:false})
    @Type(() => CheckInWhereUniqueInput)
    where!: Prisma.AtLeast<CheckInWhereUniqueInput, 'id'>;
    @Field(() => CheckInCreateInput, {nullable:false})
    @Type(() => CheckInCreateInput)
    create!: InstanceType<typeof CheckInCreateInput>;
    @Field(() => CheckInUpdateInput, {nullable:false})
    @Type(() => CheckInUpdateInput)
    update!: InstanceType<typeof CheckInUpdateInput>;
}

@ObjectType()
export class AggregateCity {
    @Field(() => CityCountAggregate, {nullable:true})
    _count?: InstanceType<typeof CityCountAggregate>;
    @Field(() => CityAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof CityAvgAggregate>;
    @Field(() => CitySumAggregate, {nullable:true})
    _sum?: InstanceType<typeof CitySumAggregate>;
    @Field(() => CityMinAggregate, {nullable:true})
    _min?: InstanceType<typeof CityMinAggregate>;
    @Field(() => CityMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof CityMaxAggregate>;
}

@ArgsType()
export class CityAggregateArgs {
    @Field(() => CityWhereInput, {nullable:true})
    @Type(() => CityWhereInput)
    where?: InstanceType<typeof CityWhereInput>;
    @Field(() => [CityOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CityOrderByWithRelationInput>;
    @Field(() => CityWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => CityCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof CityCountAggregateInput>;
    @Field(() => CityAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof CityAvgAggregateInput>;
    @Field(() => CitySumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof CitySumAggregateInput>;
    @Field(() => CityMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof CityMinAggregateInput>;
    @Field(() => CityMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof CityMaxAggregateInput>;
}

@InputType()
export class CityAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    provinceId?: true;
}

@ObjectType()
export class CityAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    provinceId?: number;
}

@InputType()
export class CityAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    provinceId?: keyof typeof SortOrder;
}

@InputType()
export class CityCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    provinceId?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class CityCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    provinceId!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class CityCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    provinceId?: keyof typeof SortOrder;
}

@ObjectType()
export class CityCount {
    @Field(() => Int, {nullable:false})
    districts?: number;
}

@InputType()
export class CityCreateManyProvinceInputEnvelope {
    @Field(() => [CityCreateManyProvinceInput], {nullable:false})
    @Type(() => CityCreateManyProvinceInput)
    data!: Array<CityCreateManyProvinceInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class CityCreateManyProvinceInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
}

@InputType()
export class CityCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    provinceId!: number;
}

@InputType()
export class CityCreateNestedManyWithoutProvinceInput {
    @Field(() => [CityCreateWithoutProvinceInput], {nullable:true})
    @Type(() => CityCreateWithoutProvinceInput)
    create?: Array<CityCreateWithoutProvinceInput>;
    @Field(() => [CityCreateOrConnectWithoutProvinceInput], {nullable:true})
    @Type(() => CityCreateOrConnectWithoutProvinceInput)
    connectOrCreate?: Array<CityCreateOrConnectWithoutProvinceInput>;
    @Field(() => CityCreateManyProvinceInputEnvelope, {nullable:true})
    @Type(() => CityCreateManyProvinceInputEnvelope)
    createMany?: InstanceType<typeof CityCreateManyProvinceInputEnvelope>;
    @Field(() => [CityWhereUniqueInput], {nullable:true})
    @Type(() => CityWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CityWhereUniqueInput, 'id'>>;
}

@InputType()
export class CityCreateNestedOneWithoutDistrictsInput {
    @Field(() => CityCreateWithoutDistrictsInput, {nullable:true})
    @Type(() => CityCreateWithoutDistrictsInput)
    create?: InstanceType<typeof CityCreateWithoutDistrictsInput>;
    @Field(() => CityCreateOrConnectWithoutDistrictsInput, {nullable:true})
    @Type(() => CityCreateOrConnectWithoutDistrictsInput)
    connectOrCreate?: InstanceType<typeof CityCreateOrConnectWithoutDistrictsInput>;
    @Field(() => CityWhereUniqueInput, {nullable:true})
    @Type(() => CityWhereUniqueInput)
    connect?: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
}

@InputType()
export class CityCreateOrConnectWithoutDistrictsInput {
    @Field(() => CityWhereUniqueInput, {nullable:false})
    @Type(() => CityWhereUniqueInput)
    where!: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
    @Field(() => CityCreateWithoutDistrictsInput, {nullable:false})
    @Type(() => CityCreateWithoutDistrictsInput)
    create!: InstanceType<typeof CityCreateWithoutDistrictsInput>;
}

@InputType()
export class CityCreateOrConnectWithoutProvinceInput {
    @Field(() => CityWhereUniqueInput, {nullable:false})
    @Type(() => CityWhereUniqueInput)
    where!: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
    @Field(() => CityCreateWithoutProvinceInput, {nullable:false})
    @Type(() => CityCreateWithoutProvinceInput)
    create!: InstanceType<typeof CityCreateWithoutProvinceInput>;
}

@InputType()
export class CityCreateWithoutDistrictsInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => ProvinceCreateNestedOneWithoutCitiesInput, {nullable:false})
    province!: InstanceType<typeof ProvinceCreateNestedOneWithoutCitiesInput>;
}

@InputType()
export class CityCreateWithoutProvinceInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => DistrictCreateNestedManyWithoutCityInput, {nullable:true})
    districts?: InstanceType<typeof DistrictCreateNestedManyWithoutCityInput>;
}

@InputType()
export class CityCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => ProvinceCreateNestedOneWithoutCitiesInput, {nullable:false})
    province!: InstanceType<typeof ProvinceCreateNestedOneWithoutCitiesInput>;
    @Field(() => DistrictCreateNestedManyWithoutCityInput, {nullable:true})
    districts?: InstanceType<typeof DistrictCreateNestedManyWithoutCityInput>;
}

@ArgsType()
export class CityGroupByArgs {
    @Field(() => CityWhereInput, {nullable:true})
    @Type(() => CityWhereInput)
    where?: InstanceType<typeof CityWhereInput>;
    @Field(() => [CityOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<CityOrderByWithAggregationInput>;
    @Field(() => [CityScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof CityScalarFieldEnum>;
    @Field(() => CityScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof CityScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => CityCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof CityCountAggregateInput>;
    @Field(() => CityAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof CityAvgAggregateInput>;
    @Field(() => CitySumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof CitySumAggregateInput>;
    @Field(() => CityMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof CityMinAggregateInput>;
    @Field(() => CityMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof CityMaxAggregateInput>;
}

@ObjectType()
export class CityGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    provinceId!: number;
    @Field(() => CityCountAggregate, {nullable:true})
    _count?: InstanceType<typeof CityCountAggregate>;
    @Field(() => CityAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof CityAvgAggregate>;
    @Field(() => CitySumAggregate, {nullable:true})
    _sum?: InstanceType<typeof CitySumAggregate>;
    @Field(() => CityMinAggregate, {nullable:true})
    _min?: InstanceType<typeof CityMinAggregate>;
    @Field(() => CityMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof CityMaxAggregate>;
}

@InputType()
export class CityListRelationFilter {
    @Field(() => CityWhereInput, {nullable:true})
    every?: InstanceType<typeof CityWhereInput>;
    @Field(() => CityWhereInput, {nullable:true})
    some?: InstanceType<typeof CityWhereInput>;
    @Field(() => CityWhereInput, {nullable:true})
    none?: InstanceType<typeof CityWhereInput>;
}

@InputType()
export class CityMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    provinceId?: true;
}

@ObjectType()
export class CityMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Int, {nullable:true})
    provinceId?: number;
}

@InputType()
export class CityMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    provinceId?: keyof typeof SortOrder;
}

@InputType()
export class CityMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    provinceId?: true;
}

@ObjectType()
export class CityMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Int, {nullable:true})
    provinceId?: number;
}

@InputType()
export class CityMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    provinceId?: keyof typeof SortOrder;
}

@InputType()
export class CityOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class CityOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    provinceId?: keyof typeof SortOrder;
    @Field(() => CityCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof CityCountOrderByAggregateInput>;
    @Field(() => CityAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof CityAvgOrderByAggregateInput>;
    @Field(() => CityMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof CityMaxOrderByAggregateInput>;
    @Field(() => CityMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof CityMinOrderByAggregateInput>;
    @Field(() => CitySumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof CitySumOrderByAggregateInput>;
}

@InputType()
export class CityOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    provinceId?: keyof typeof SortOrder;
    @Field(() => ProvinceOrderByWithRelationInput, {nullable:true})
    province?: InstanceType<typeof ProvinceOrderByWithRelationInput>;
    @Field(() => DistrictOrderByRelationAggregateInput, {nullable:true})
    districts?: InstanceType<typeof DistrictOrderByRelationAggregateInput>;
}

@InputType()
export class CityRelationFilter {
    @Field(() => CityWhereInput, {nullable:true})
    is?: InstanceType<typeof CityWhereInput>;
    @Field(() => CityWhereInput, {nullable:true})
    isNot?: InstanceType<typeof CityWhereInput>;
}

@InputType()
export class CityScalarWhereWithAggregatesInput {
    @Field(() => [CityScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<CityScalarWhereWithAggregatesInput>;
    @Field(() => [CityScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<CityScalarWhereWithAggregatesInput>;
    @Field(() => [CityScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<CityScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    provinceId?: InstanceType<typeof IntWithAggregatesFilter>;
}

@InputType()
export class CityScalarWhereInput {
    @Field(() => [CityScalarWhereInput], {nullable:true})
    AND?: Array<CityScalarWhereInput>;
    @Field(() => [CityScalarWhereInput], {nullable:true})
    OR?: Array<CityScalarWhereInput>;
    @Field(() => [CityScalarWhereInput], {nullable:true})
    NOT?: Array<CityScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    provinceId?: InstanceType<typeof IntFilter>;
}

@InputType()
export class CitySumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    provinceId?: true;
}

@ObjectType()
export class CitySumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    provinceId?: number;
}

@InputType()
export class CitySumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    provinceId?: keyof typeof SortOrder;
}

@InputType()
export class CityUncheckedCreateNestedManyWithoutProvinceInput {
    @Field(() => [CityCreateWithoutProvinceInput], {nullable:true})
    @Type(() => CityCreateWithoutProvinceInput)
    create?: Array<CityCreateWithoutProvinceInput>;
    @Field(() => [CityCreateOrConnectWithoutProvinceInput], {nullable:true})
    @Type(() => CityCreateOrConnectWithoutProvinceInput)
    connectOrCreate?: Array<CityCreateOrConnectWithoutProvinceInput>;
    @Field(() => CityCreateManyProvinceInputEnvelope, {nullable:true})
    @Type(() => CityCreateManyProvinceInputEnvelope)
    createMany?: InstanceType<typeof CityCreateManyProvinceInputEnvelope>;
    @Field(() => [CityWhereUniqueInput], {nullable:true})
    @Type(() => CityWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CityWhereUniqueInput, 'id'>>;
}

@InputType()
export class CityUncheckedCreateWithoutDistrictsInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    provinceId!: number;
}

@InputType()
export class CityUncheckedCreateWithoutProvinceInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => DistrictUncheckedCreateNestedManyWithoutCityInput, {nullable:true})
    districts?: InstanceType<typeof DistrictUncheckedCreateNestedManyWithoutCityInput>;
}

@InputType()
export class CityUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    provinceId!: number;
    @Field(() => DistrictUncheckedCreateNestedManyWithoutCityInput, {nullable:true})
    districts?: InstanceType<typeof DistrictUncheckedCreateNestedManyWithoutCityInput>;
}

@InputType()
export class CityUncheckedUpdateManyWithoutProvinceNestedInput {
    @Field(() => [CityCreateWithoutProvinceInput], {nullable:true})
    @Type(() => CityCreateWithoutProvinceInput)
    create?: Array<CityCreateWithoutProvinceInput>;
    @Field(() => [CityCreateOrConnectWithoutProvinceInput], {nullable:true})
    @Type(() => CityCreateOrConnectWithoutProvinceInput)
    connectOrCreate?: Array<CityCreateOrConnectWithoutProvinceInput>;
    @Field(() => [CityUpsertWithWhereUniqueWithoutProvinceInput], {nullable:true})
    @Type(() => CityUpsertWithWhereUniqueWithoutProvinceInput)
    upsert?: Array<CityUpsertWithWhereUniqueWithoutProvinceInput>;
    @Field(() => CityCreateManyProvinceInputEnvelope, {nullable:true})
    @Type(() => CityCreateManyProvinceInputEnvelope)
    createMany?: InstanceType<typeof CityCreateManyProvinceInputEnvelope>;
    @Field(() => [CityWhereUniqueInput], {nullable:true})
    @Type(() => CityWhereUniqueInput)
    set?: Array<Prisma.AtLeast<CityWhereUniqueInput, 'id'>>;
    @Field(() => [CityWhereUniqueInput], {nullable:true})
    @Type(() => CityWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<CityWhereUniqueInput, 'id'>>;
    @Field(() => [CityWhereUniqueInput], {nullable:true})
    @Type(() => CityWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<CityWhereUniqueInput, 'id'>>;
    @Field(() => [CityWhereUniqueInput], {nullable:true})
    @Type(() => CityWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CityWhereUniqueInput, 'id'>>;
    @Field(() => [CityUpdateWithWhereUniqueWithoutProvinceInput], {nullable:true})
    @Type(() => CityUpdateWithWhereUniqueWithoutProvinceInput)
    update?: Array<CityUpdateWithWhereUniqueWithoutProvinceInput>;
    @Field(() => [CityUpdateManyWithWhereWithoutProvinceInput], {nullable:true})
    @Type(() => CityUpdateManyWithWhereWithoutProvinceInput)
    updateMany?: Array<CityUpdateManyWithWhereWithoutProvinceInput>;
    @Field(() => [CityScalarWhereInput], {nullable:true})
    @Type(() => CityScalarWhereInput)
    deleteMany?: Array<CityScalarWhereInput>;
}

@InputType()
export class CityUncheckedUpdateManyWithoutProvinceInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class CityUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    provinceId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class CityUncheckedUpdateWithoutDistrictsInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    provinceId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class CityUncheckedUpdateWithoutProvinceInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DistrictUncheckedUpdateManyWithoutCityNestedInput, {nullable:true})
    districts?: InstanceType<typeof DistrictUncheckedUpdateManyWithoutCityNestedInput>;
}

@InputType()
export class CityUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    provinceId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DistrictUncheckedUpdateManyWithoutCityNestedInput, {nullable:true})
    districts?: InstanceType<typeof DistrictUncheckedUpdateManyWithoutCityNestedInput>;
}

@InputType()
export class CityUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class CityUpdateManyWithWhereWithoutProvinceInput {
    @Field(() => CityScalarWhereInput, {nullable:false})
    @Type(() => CityScalarWhereInput)
    where!: InstanceType<typeof CityScalarWhereInput>;
    @Field(() => CityUpdateManyMutationInput, {nullable:false})
    @Type(() => CityUpdateManyMutationInput)
    data!: InstanceType<typeof CityUpdateManyMutationInput>;
}

@InputType()
export class CityUpdateManyWithoutProvinceNestedInput {
    @Field(() => [CityCreateWithoutProvinceInput], {nullable:true})
    @Type(() => CityCreateWithoutProvinceInput)
    create?: Array<CityCreateWithoutProvinceInput>;
    @Field(() => [CityCreateOrConnectWithoutProvinceInput], {nullable:true})
    @Type(() => CityCreateOrConnectWithoutProvinceInput)
    connectOrCreate?: Array<CityCreateOrConnectWithoutProvinceInput>;
    @Field(() => [CityUpsertWithWhereUniqueWithoutProvinceInput], {nullable:true})
    @Type(() => CityUpsertWithWhereUniqueWithoutProvinceInput)
    upsert?: Array<CityUpsertWithWhereUniqueWithoutProvinceInput>;
    @Field(() => CityCreateManyProvinceInputEnvelope, {nullable:true})
    @Type(() => CityCreateManyProvinceInputEnvelope)
    createMany?: InstanceType<typeof CityCreateManyProvinceInputEnvelope>;
    @Field(() => [CityWhereUniqueInput], {nullable:true})
    @Type(() => CityWhereUniqueInput)
    set?: Array<Prisma.AtLeast<CityWhereUniqueInput, 'id'>>;
    @Field(() => [CityWhereUniqueInput], {nullable:true})
    @Type(() => CityWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<CityWhereUniqueInput, 'id'>>;
    @Field(() => [CityWhereUniqueInput], {nullable:true})
    @Type(() => CityWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<CityWhereUniqueInput, 'id'>>;
    @Field(() => [CityWhereUniqueInput], {nullable:true})
    @Type(() => CityWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<CityWhereUniqueInput, 'id'>>;
    @Field(() => [CityUpdateWithWhereUniqueWithoutProvinceInput], {nullable:true})
    @Type(() => CityUpdateWithWhereUniqueWithoutProvinceInput)
    update?: Array<CityUpdateWithWhereUniqueWithoutProvinceInput>;
    @Field(() => [CityUpdateManyWithWhereWithoutProvinceInput], {nullable:true})
    @Type(() => CityUpdateManyWithWhereWithoutProvinceInput)
    updateMany?: Array<CityUpdateManyWithWhereWithoutProvinceInput>;
    @Field(() => [CityScalarWhereInput], {nullable:true})
    @Type(() => CityScalarWhereInput)
    deleteMany?: Array<CityScalarWhereInput>;
}

@InputType()
export class CityUpdateOneRequiredWithoutDistrictsNestedInput {
    @Field(() => CityCreateWithoutDistrictsInput, {nullable:true})
    @Type(() => CityCreateWithoutDistrictsInput)
    create?: InstanceType<typeof CityCreateWithoutDistrictsInput>;
    @Field(() => CityCreateOrConnectWithoutDistrictsInput, {nullable:true})
    @Type(() => CityCreateOrConnectWithoutDistrictsInput)
    connectOrCreate?: InstanceType<typeof CityCreateOrConnectWithoutDistrictsInput>;
    @Field(() => CityUpsertWithoutDistrictsInput, {nullable:true})
    @Type(() => CityUpsertWithoutDistrictsInput)
    upsert?: InstanceType<typeof CityUpsertWithoutDistrictsInput>;
    @Field(() => CityWhereUniqueInput, {nullable:true})
    @Type(() => CityWhereUniqueInput)
    connect?: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
    @Field(() => CityUpdateToOneWithWhereWithoutDistrictsInput, {nullable:true})
    @Type(() => CityUpdateToOneWithWhereWithoutDistrictsInput)
    update?: InstanceType<typeof CityUpdateToOneWithWhereWithoutDistrictsInput>;
}

@InputType()
export class CityUpdateToOneWithWhereWithoutDistrictsInput {
    @Field(() => CityWhereInput, {nullable:true})
    @Type(() => CityWhereInput)
    where?: InstanceType<typeof CityWhereInput>;
    @Field(() => CityUpdateWithoutDistrictsInput, {nullable:false})
    @Type(() => CityUpdateWithoutDistrictsInput)
    data!: InstanceType<typeof CityUpdateWithoutDistrictsInput>;
}

@InputType()
export class CityUpdateWithWhereUniqueWithoutProvinceInput {
    @Field(() => CityWhereUniqueInput, {nullable:false})
    @Type(() => CityWhereUniqueInput)
    where!: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
    @Field(() => CityUpdateWithoutProvinceInput, {nullable:false})
    @Type(() => CityUpdateWithoutProvinceInput)
    data!: InstanceType<typeof CityUpdateWithoutProvinceInput>;
}

@InputType()
export class CityUpdateWithoutDistrictsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => ProvinceUpdateOneRequiredWithoutCitiesNestedInput, {nullable:true})
    province?: InstanceType<typeof ProvinceUpdateOneRequiredWithoutCitiesNestedInput>;
}

@InputType()
export class CityUpdateWithoutProvinceInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DistrictUpdateManyWithoutCityNestedInput, {nullable:true})
    districts?: InstanceType<typeof DistrictUpdateManyWithoutCityNestedInput>;
}

@InputType()
export class CityUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => ProvinceUpdateOneRequiredWithoutCitiesNestedInput, {nullable:true})
    province?: InstanceType<typeof ProvinceUpdateOneRequiredWithoutCitiesNestedInput>;
    @Field(() => DistrictUpdateManyWithoutCityNestedInput, {nullable:true})
    districts?: InstanceType<typeof DistrictUpdateManyWithoutCityNestedInput>;
}

@InputType()
export class CityUpsertWithWhereUniqueWithoutProvinceInput {
    @Field(() => CityWhereUniqueInput, {nullable:false})
    @Type(() => CityWhereUniqueInput)
    where!: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
    @Field(() => CityUpdateWithoutProvinceInput, {nullable:false})
    @Type(() => CityUpdateWithoutProvinceInput)
    update!: InstanceType<typeof CityUpdateWithoutProvinceInput>;
    @Field(() => CityCreateWithoutProvinceInput, {nullable:false})
    @Type(() => CityCreateWithoutProvinceInput)
    create!: InstanceType<typeof CityCreateWithoutProvinceInput>;
}

@InputType()
export class CityUpsertWithoutDistrictsInput {
    @Field(() => CityUpdateWithoutDistrictsInput, {nullable:false})
    @Type(() => CityUpdateWithoutDistrictsInput)
    update!: InstanceType<typeof CityUpdateWithoutDistrictsInput>;
    @Field(() => CityCreateWithoutDistrictsInput, {nullable:false})
    @Type(() => CityCreateWithoutDistrictsInput)
    create!: InstanceType<typeof CityCreateWithoutDistrictsInput>;
    @Field(() => CityWhereInput, {nullable:true})
    @Type(() => CityWhereInput)
    where?: InstanceType<typeof CityWhereInput>;
}

@InputType()
export class CityWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [CityWhereInput], {nullable:true})
    AND?: Array<CityWhereInput>;
    @Field(() => [CityWhereInput], {nullable:true})
    OR?: Array<CityWhereInput>;
    @Field(() => [CityWhereInput], {nullable:true})
    NOT?: Array<CityWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    provinceId?: InstanceType<typeof IntFilter>;
    @Field(() => ProvinceRelationFilter, {nullable:true})
    province?: InstanceType<typeof ProvinceRelationFilter>;
    @Field(() => DistrictListRelationFilter, {nullable:true})
    districts?: InstanceType<typeof DistrictListRelationFilter>;
}

@InputType()
export class CityWhereInput {
    @Field(() => [CityWhereInput], {nullable:true})
    AND?: Array<CityWhereInput>;
    @Field(() => [CityWhereInput], {nullable:true})
    OR?: Array<CityWhereInput>;
    @Field(() => [CityWhereInput], {nullable:true})
    NOT?: Array<CityWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    provinceId?: InstanceType<typeof IntFilter>;
    @Field(() => ProvinceRelationFilter, {nullable:true})
    province?: InstanceType<typeof ProvinceRelationFilter>;
    @Field(() => DistrictListRelationFilter, {nullable:true})
    districts?: InstanceType<typeof DistrictListRelationFilter>;
}

@ObjectType()
export class City {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    provinceId!: number;
    @Field(() => Province, {nullable:false})
    province?: InstanceType<typeof Province>;
    @Field(() => [District], {nullable:true})
    districts?: Array<District>;
    @Field(() => CityCount, {nullable:false})
    _count?: InstanceType<typeof CityCount>;
}

@ArgsType()
export class CreateManyCityArgs {
    @Field(() => [CityCreateManyInput], {nullable:false})
    @Type(() => CityCreateManyInput)
    data!: Array<CityCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneCityArgs {
    @Field(() => CityCreateInput, {nullable:false})
    @Type(() => CityCreateInput)
    data!: InstanceType<typeof CityCreateInput>;
}

@ArgsType()
export class DeleteManyCityArgs {
    @Field(() => CityWhereInput, {nullable:true})
    @Type(() => CityWhereInput)
    where?: InstanceType<typeof CityWhereInput>;
}

@ArgsType()
export class DeleteOneCityArgs {
    @Field(() => CityWhereUniqueInput, {nullable:false})
    @Type(() => CityWhereUniqueInput)
    where!: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstCityOrThrowArgs {
    @Field(() => CityWhereInput, {nullable:true})
    @Type(() => CityWhereInput)
    where?: InstanceType<typeof CityWhereInput>;
    @Field(() => [CityOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CityOrderByWithRelationInput>;
    @Field(() => CityWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [CityScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof CityScalarFieldEnum>;
}

@ArgsType()
export class FindFirstCityArgs {
    @Field(() => CityWhereInput, {nullable:true})
    @Type(() => CityWhereInput)
    where?: InstanceType<typeof CityWhereInput>;
    @Field(() => [CityOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CityOrderByWithRelationInput>;
    @Field(() => CityWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [CityScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof CityScalarFieldEnum>;
}

@ArgsType()
export class FindManyCityArgs {
    @Field(() => CityWhereInput, {nullable:true})
    @Type(() => CityWhereInput)
    where?: InstanceType<typeof CityWhereInput>;
    @Field(() => [CityOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<CityOrderByWithRelationInput>;
    @Field(() => CityWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [CityScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof CityScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueCityOrThrowArgs {
    @Field(() => CityWhereUniqueInput, {nullable:false})
    @Type(() => CityWhereUniqueInput)
    where!: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueCityArgs {
    @Field(() => CityWhereUniqueInput, {nullable:false})
    @Type(() => CityWhereUniqueInput)
    where!: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpdateManyCityArgs {
    @Field(() => CityUpdateManyMutationInput, {nullable:false})
    @Type(() => CityUpdateManyMutationInput)
    data!: InstanceType<typeof CityUpdateManyMutationInput>;
    @Field(() => CityWhereInput, {nullable:true})
    @Type(() => CityWhereInput)
    where?: InstanceType<typeof CityWhereInput>;
}

@ArgsType()
export class UpdateOneCityArgs {
    @Field(() => CityUpdateInput, {nullable:false})
    @Type(() => CityUpdateInput)
    data!: InstanceType<typeof CityUpdateInput>;
    @Field(() => CityWhereUniqueInput, {nullable:false})
    @Type(() => CityWhereUniqueInput)
    where!: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneCityArgs {
    @Field(() => CityWhereUniqueInput, {nullable:false})
    @Type(() => CityWhereUniqueInput)
    where!: Prisma.AtLeast<CityWhereUniqueInput, 'id'>;
    @Field(() => CityCreateInput, {nullable:false})
    @Type(() => CityCreateInput)
    create!: InstanceType<typeof CityCreateInput>;
    @Field(() => CityUpdateInput, {nullable:false})
    @Type(() => CityUpdateInput)
    update!: InstanceType<typeof CityUpdateInput>;
}

@ObjectType()
export class AggregateDistrict {
    @Field(() => DistrictCountAggregate, {nullable:true})
    _count?: InstanceType<typeof DistrictCountAggregate>;
    @Field(() => DistrictAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof DistrictAvgAggregate>;
    @Field(() => DistrictSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof DistrictSumAggregate>;
    @Field(() => DistrictMinAggregate, {nullable:true})
    _min?: InstanceType<typeof DistrictMinAggregate>;
    @Field(() => DistrictMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof DistrictMaxAggregate>;
}

@ArgsType()
export class CreateManyDistrictArgs {
    @Field(() => [DistrictCreateManyInput], {nullable:false})
    @Type(() => DistrictCreateManyInput)
    data!: Array<DistrictCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneDistrictArgs {
    @Field(() => DistrictCreateInput, {nullable:false})
    @Type(() => DistrictCreateInput)
    data!: InstanceType<typeof DistrictCreateInput>;
}

@ArgsType()
export class DeleteManyDistrictArgs {
    @Field(() => DistrictWhereInput, {nullable:true})
    @Type(() => DistrictWhereInput)
    where?: InstanceType<typeof DistrictWhereInput>;
}

@ArgsType()
export class DeleteOneDistrictArgs {
    @Field(() => DistrictWhereUniqueInput, {nullable:false})
    @Type(() => DistrictWhereUniqueInput)
    where!: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
}

@ArgsType()
export class DistrictAggregateArgs {
    @Field(() => DistrictWhereInput, {nullable:true})
    @Type(() => DistrictWhereInput)
    where?: InstanceType<typeof DistrictWhereInput>;
    @Field(() => [DistrictOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<DistrictOrderByWithRelationInput>;
    @Field(() => DistrictWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => DistrictCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof DistrictCountAggregateInput>;
    @Field(() => DistrictAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof DistrictAvgAggregateInput>;
    @Field(() => DistrictSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof DistrictSumAggregateInput>;
    @Field(() => DistrictMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof DistrictMinAggregateInput>;
    @Field(() => DistrictMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof DistrictMaxAggregateInput>;
}

@InputType()
export class DistrictAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    cityId?: true;
}

@ObjectType()
export class DistrictAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    cityId?: number;
}

@InputType()
export class DistrictAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cityId?: keyof typeof SortOrder;
}

@InputType()
export class DistrictCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    cityId?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class DistrictCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    cityId!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class DistrictCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cityId?: keyof typeof SortOrder;
}

@ObjectType()
export class DistrictCount {
    @Field(() => Int, {nullable:false})
    subdistricts?: number;
}

@InputType()
export class DistrictCreateManyCityInputEnvelope {
    @Field(() => [DistrictCreateManyCityInput], {nullable:false})
    @Type(() => DistrictCreateManyCityInput)
    data!: Array<DistrictCreateManyCityInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class DistrictCreateManyCityInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
}

@InputType()
export class DistrictCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    cityId!: number;
}

@InputType()
export class DistrictCreateNestedManyWithoutCityInput {
    @Field(() => [DistrictCreateWithoutCityInput], {nullable:true})
    @Type(() => DistrictCreateWithoutCityInput)
    create?: Array<DistrictCreateWithoutCityInput>;
    @Field(() => [DistrictCreateOrConnectWithoutCityInput], {nullable:true})
    @Type(() => DistrictCreateOrConnectWithoutCityInput)
    connectOrCreate?: Array<DistrictCreateOrConnectWithoutCityInput>;
    @Field(() => DistrictCreateManyCityInputEnvelope, {nullable:true})
    @Type(() => DistrictCreateManyCityInputEnvelope)
    createMany?: InstanceType<typeof DistrictCreateManyCityInputEnvelope>;
    @Field(() => [DistrictWhereUniqueInput], {nullable:true})
    @Type(() => DistrictWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>>;
}

@InputType()
export class DistrictCreateNestedOneWithoutSubdistrictsInput {
    @Field(() => DistrictCreateWithoutSubdistrictsInput, {nullable:true})
    @Type(() => DistrictCreateWithoutSubdistrictsInput)
    create?: InstanceType<typeof DistrictCreateWithoutSubdistrictsInput>;
    @Field(() => DistrictCreateOrConnectWithoutSubdistrictsInput, {nullable:true})
    @Type(() => DistrictCreateOrConnectWithoutSubdistrictsInput)
    connectOrCreate?: InstanceType<typeof DistrictCreateOrConnectWithoutSubdistrictsInput>;
    @Field(() => DistrictWhereUniqueInput, {nullable:true})
    @Type(() => DistrictWhereUniqueInput)
    connect?: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
}

@InputType()
export class DistrictCreateOrConnectWithoutCityInput {
    @Field(() => DistrictWhereUniqueInput, {nullable:false})
    @Type(() => DistrictWhereUniqueInput)
    where!: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
    @Field(() => DistrictCreateWithoutCityInput, {nullable:false})
    @Type(() => DistrictCreateWithoutCityInput)
    create!: InstanceType<typeof DistrictCreateWithoutCityInput>;
}

@InputType()
export class DistrictCreateOrConnectWithoutSubdistrictsInput {
    @Field(() => DistrictWhereUniqueInput, {nullable:false})
    @Type(() => DistrictWhereUniqueInput)
    where!: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
    @Field(() => DistrictCreateWithoutSubdistrictsInput, {nullable:false})
    @Type(() => DistrictCreateWithoutSubdistrictsInput)
    create!: InstanceType<typeof DistrictCreateWithoutSubdistrictsInput>;
}

@InputType()
export class DistrictCreateWithoutCityInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => SubdistrictCreateNestedManyWithoutDistrictInput, {nullable:true})
    subdistricts?: InstanceType<typeof SubdistrictCreateNestedManyWithoutDistrictInput>;
}

@InputType()
export class DistrictCreateWithoutSubdistrictsInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => CityCreateNestedOneWithoutDistrictsInput, {nullable:false})
    city!: InstanceType<typeof CityCreateNestedOneWithoutDistrictsInput>;
}

@InputType()
export class DistrictCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => CityCreateNestedOneWithoutDistrictsInput, {nullable:false})
    city!: InstanceType<typeof CityCreateNestedOneWithoutDistrictsInput>;
    @Field(() => SubdistrictCreateNestedManyWithoutDistrictInput, {nullable:true})
    subdistricts?: InstanceType<typeof SubdistrictCreateNestedManyWithoutDistrictInput>;
}

@ArgsType()
export class DistrictGroupByArgs {
    @Field(() => DistrictWhereInput, {nullable:true})
    @Type(() => DistrictWhereInput)
    where?: InstanceType<typeof DistrictWhereInput>;
    @Field(() => [DistrictOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<DistrictOrderByWithAggregationInput>;
    @Field(() => [DistrictScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof DistrictScalarFieldEnum>;
    @Field(() => DistrictScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof DistrictScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => DistrictCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof DistrictCountAggregateInput>;
    @Field(() => DistrictAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof DistrictAvgAggregateInput>;
    @Field(() => DistrictSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof DistrictSumAggregateInput>;
    @Field(() => DistrictMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof DistrictMinAggregateInput>;
    @Field(() => DistrictMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof DistrictMaxAggregateInput>;
}

@ObjectType()
export class DistrictGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    cityId!: number;
    @Field(() => DistrictCountAggregate, {nullable:true})
    _count?: InstanceType<typeof DistrictCountAggregate>;
    @Field(() => DistrictAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof DistrictAvgAggregate>;
    @Field(() => DistrictSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof DistrictSumAggregate>;
    @Field(() => DistrictMinAggregate, {nullable:true})
    _min?: InstanceType<typeof DistrictMinAggregate>;
    @Field(() => DistrictMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof DistrictMaxAggregate>;
}

@InputType()
export class DistrictListRelationFilter {
    @Field(() => DistrictWhereInput, {nullable:true})
    every?: InstanceType<typeof DistrictWhereInput>;
    @Field(() => DistrictWhereInput, {nullable:true})
    some?: InstanceType<typeof DistrictWhereInput>;
    @Field(() => DistrictWhereInput, {nullable:true})
    none?: InstanceType<typeof DistrictWhereInput>;
}

@InputType()
export class DistrictMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    cityId?: true;
}

@ObjectType()
export class DistrictMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Int, {nullable:true})
    cityId?: number;
}

@InputType()
export class DistrictMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cityId?: keyof typeof SortOrder;
}

@InputType()
export class DistrictMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    cityId?: true;
}

@ObjectType()
export class DistrictMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Int, {nullable:true})
    cityId?: number;
}

@InputType()
export class DistrictMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cityId?: keyof typeof SortOrder;
}

@InputType()
export class DistrictOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class DistrictOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cityId?: keyof typeof SortOrder;
    @Field(() => DistrictCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof DistrictCountOrderByAggregateInput>;
    @Field(() => DistrictAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof DistrictAvgOrderByAggregateInput>;
    @Field(() => DistrictMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof DistrictMaxOrderByAggregateInput>;
    @Field(() => DistrictMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof DistrictMinOrderByAggregateInput>;
    @Field(() => DistrictSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof DistrictSumOrderByAggregateInput>;
}

@InputType()
export class DistrictOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cityId?: keyof typeof SortOrder;
    @Field(() => CityOrderByWithRelationInput, {nullable:true})
    city?: InstanceType<typeof CityOrderByWithRelationInput>;
    @Field(() => SubdistrictOrderByRelationAggregateInput, {nullable:true})
    subdistricts?: InstanceType<typeof SubdistrictOrderByRelationAggregateInput>;
}

@InputType()
export class DistrictRelationFilter {
    @Field(() => DistrictWhereInput, {nullable:true})
    is?: InstanceType<typeof DistrictWhereInput>;
    @Field(() => DistrictWhereInput, {nullable:true})
    isNot?: InstanceType<typeof DistrictWhereInput>;
}

@InputType()
export class DistrictScalarWhereWithAggregatesInput {
    @Field(() => [DistrictScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<DistrictScalarWhereWithAggregatesInput>;
    @Field(() => [DistrictScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<DistrictScalarWhereWithAggregatesInput>;
    @Field(() => [DistrictScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<DistrictScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    cityId?: InstanceType<typeof IntWithAggregatesFilter>;
}

@InputType()
export class DistrictScalarWhereInput {
    @Field(() => [DistrictScalarWhereInput], {nullable:true})
    AND?: Array<DistrictScalarWhereInput>;
    @Field(() => [DistrictScalarWhereInput], {nullable:true})
    OR?: Array<DistrictScalarWhereInput>;
    @Field(() => [DistrictScalarWhereInput], {nullable:true})
    NOT?: Array<DistrictScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    cityId?: InstanceType<typeof IntFilter>;
}

@InputType()
export class DistrictSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    cityId?: true;
}

@ObjectType()
export class DistrictSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    cityId?: number;
}

@InputType()
export class DistrictSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cityId?: keyof typeof SortOrder;
}

@InputType()
export class DistrictUncheckedCreateNestedManyWithoutCityInput {
    @Field(() => [DistrictCreateWithoutCityInput], {nullable:true})
    @Type(() => DistrictCreateWithoutCityInput)
    create?: Array<DistrictCreateWithoutCityInput>;
    @Field(() => [DistrictCreateOrConnectWithoutCityInput], {nullable:true})
    @Type(() => DistrictCreateOrConnectWithoutCityInput)
    connectOrCreate?: Array<DistrictCreateOrConnectWithoutCityInput>;
    @Field(() => DistrictCreateManyCityInputEnvelope, {nullable:true})
    @Type(() => DistrictCreateManyCityInputEnvelope)
    createMany?: InstanceType<typeof DistrictCreateManyCityInputEnvelope>;
    @Field(() => [DistrictWhereUniqueInput], {nullable:true})
    @Type(() => DistrictWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>>;
}

@InputType()
export class DistrictUncheckedCreateWithoutCityInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => SubdistrictUncheckedCreateNestedManyWithoutDistrictInput, {nullable:true})
    subdistricts?: InstanceType<typeof SubdistrictUncheckedCreateNestedManyWithoutDistrictInput>;
}

@InputType()
export class DistrictUncheckedCreateWithoutSubdistrictsInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    cityId!: number;
}

@InputType()
export class DistrictUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Int, {nullable:false})
    cityId!: number;
    @Field(() => SubdistrictUncheckedCreateNestedManyWithoutDistrictInput, {nullable:true})
    subdistricts?: InstanceType<typeof SubdistrictUncheckedCreateNestedManyWithoutDistrictInput>;
}

@InputType()
export class DistrictUncheckedUpdateManyWithoutCityNestedInput {
    @Field(() => [DistrictCreateWithoutCityInput], {nullable:true})
    @Type(() => DistrictCreateWithoutCityInput)
    create?: Array<DistrictCreateWithoutCityInput>;
    @Field(() => [DistrictCreateOrConnectWithoutCityInput], {nullable:true})
    @Type(() => DistrictCreateOrConnectWithoutCityInput)
    connectOrCreate?: Array<DistrictCreateOrConnectWithoutCityInput>;
    @Field(() => [DistrictUpsertWithWhereUniqueWithoutCityInput], {nullable:true})
    @Type(() => DistrictUpsertWithWhereUniqueWithoutCityInput)
    upsert?: Array<DistrictUpsertWithWhereUniqueWithoutCityInput>;
    @Field(() => DistrictCreateManyCityInputEnvelope, {nullable:true})
    @Type(() => DistrictCreateManyCityInputEnvelope)
    createMany?: InstanceType<typeof DistrictCreateManyCityInputEnvelope>;
    @Field(() => [DistrictWhereUniqueInput], {nullable:true})
    @Type(() => DistrictWhereUniqueInput)
    set?: Array<Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>>;
    @Field(() => [DistrictWhereUniqueInput], {nullable:true})
    @Type(() => DistrictWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>>;
    @Field(() => [DistrictWhereUniqueInput], {nullable:true})
    @Type(() => DistrictWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>>;
    @Field(() => [DistrictWhereUniqueInput], {nullable:true})
    @Type(() => DistrictWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>>;
    @Field(() => [DistrictUpdateWithWhereUniqueWithoutCityInput], {nullable:true})
    @Type(() => DistrictUpdateWithWhereUniqueWithoutCityInput)
    update?: Array<DistrictUpdateWithWhereUniqueWithoutCityInput>;
    @Field(() => [DistrictUpdateManyWithWhereWithoutCityInput], {nullable:true})
    @Type(() => DistrictUpdateManyWithWhereWithoutCityInput)
    updateMany?: Array<DistrictUpdateManyWithWhereWithoutCityInput>;
    @Field(() => [DistrictScalarWhereInput], {nullable:true})
    @Type(() => DistrictScalarWhereInput)
    deleteMany?: Array<DistrictScalarWhereInput>;
}

@InputType()
export class DistrictUncheckedUpdateManyWithoutCityInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class DistrictUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    cityId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class DistrictUncheckedUpdateWithoutCityInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => SubdistrictUncheckedUpdateManyWithoutDistrictNestedInput, {nullable:true})
    subdistricts?: InstanceType<typeof SubdistrictUncheckedUpdateManyWithoutDistrictNestedInput>;
}

@InputType()
export class DistrictUncheckedUpdateWithoutSubdistrictsInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    cityId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class DistrictUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    cityId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => SubdistrictUncheckedUpdateManyWithoutDistrictNestedInput, {nullable:true})
    subdistricts?: InstanceType<typeof SubdistrictUncheckedUpdateManyWithoutDistrictNestedInput>;
}

@InputType()
export class DistrictUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class DistrictUpdateManyWithWhereWithoutCityInput {
    @Field(() => DistrictScalarWhereInput, {nullable:false})
    @Type(() => DistrictScalarWhereInput)
    where!: InstanceType<typeof DistrictScalarWhereInput>;
    @Field(() => DistrictUpdateManyMutationInput, {nullable:false})
    @Type(() => DistrictUpdateManyMutationInput)
    data!: InstanceType<typeof DistrictUpdateManyMutationInput>;
}

@InputType()
export class DistrictUpdateManyWithoutCityNestedInput {
    @Field(() => [DistrictCreateWithoutCityInput], {nullable:true})
    @Type(() => DistrictCreateWithoutCityInput)
    create?: Array<DistrictCreateWithoutCityInput>;
    @Field(() => [DistrictCreateOrConnectWithoutCityInput], {nullable:true})
    @Type(() => DistrictCreateOrConnectWithoutCityInput)
    connectOrCreate?: Array<DistrictCreateOrConnectWithoutCityInput>;
    @Field(() => [DistrictUpsertWithWhereUniqueWithoutCityInput], {nullable:true})
    @Type(() => DistrictUpsertWithWhereUniqueWithoutCityInput)
    upsert?: Array<DistrictUpsertWithWhereUniqueWithoutCityInput>;
    @Field(() => DistrictCreateManyCityInputEnvelope, {nullable:true})
    @Type(() => DistrictCreateManyCityInputEnvelope)
    createMany?: InstanceType<typeof DistrictCreateManyCityInputEnvelope>;
    @Field(() => [DistrictWhereUniqueInput], {nullable:true})
    @Type(() => DistrictWhereUniqueInput)
    set?: Array<Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>>;
    @Field(() => [DistrictWhereUniqueInput], {nullable:true})
    @Type(() => DistrictWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>>;
    @Field(() => [DistrictWhereUniqueInput], {nullable:true})
    @Type(() => DistrictWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>>;
    @Field(() => [DistrictWhereUniqueInput], {nullable:true})
    @Type(() => DistrictWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>>;
    @Field(() => [DistrictUpdateWithWhereUniqueWithoutCityInput], {nullable:true})
    @Type(() => DistrictUpdateWithWhereUniqueWithoutCityInput)
    update?: Array<DistrictUpdateWithWhereUniqueWithoutCityInput>;
    @Field(() => [DistrictUpdateManyWithWhereWithoutCityInput], {nullable:true})
    @Type(() => DistrictUpdateManyWithWhereWithoutCityInput)
    updateMany?: Array<DistrictUpdateManyWithWhereWithoutCityInput>;
    @Field(() => [DistrictScalarWhereInput], {nullable:true})
    @Type(() => DistrictScalarWhereInput)
    deleteMany?: Array<DistrictScalarWhereInput>;
}

@InputType()
export class DistrictUpdateOneRequiredWithoutSubdistrictsNestedInput {
    @Field(() => DistrictCreateWithoutSubdistrictsInput, {nullable:true})
    @Type(() => DistrictCreateWithoutSubdistrictsInput)
    create?: InstanceType<typeof DistrictCreateWithoutSubdistrictsInput>;
    @Field(() => DistrictCreateOrConnectWithoutSubdistrictsInput, {nullable:true})
    @Type(() => DistrictCreateOrConnectWithoutSubdistrictsInput)
    connectOrCreate?: InstanceType<typeof DistrictCreateOrConnectWithoutSubdistrictsInput>;
    @Field(() => DistrictUpsertWithoutSubdistrictsInput, {nullable:true})
    @Type(() => DistrictUpsertWithoutSubdistrictsInput)
    upsert?: InstanceType<typeof DistrictUpsertWithoutSubdistrictsInput>;
    @Field(() => DistrictWhereUniqueInput, {nullable:true})
    @Type(() => DistrictWhereUniqueInput)
    connect?: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
    @Field(() => DistrictUpdateToOneWithWhereWithoutSubdistrictsInput, {nullable:true})
    @Type(() => DistrictUpdateToOneWithWhereWithoutSubdistrictsInput)
    update?: InstanceType<typeof DistrictUpdateToOneWithWhereWithoutSubdistrictsInput>;
}

@InputType()
export class DistrictUpdateToOneWithWhereWithoutSubdistrictsInput {
    @Field(() => DistrictWhereInput, {nullable:true})
    @Type(() => DistrictWhereInput)
    where?: InstanceType<typeof DistrictWhereInput>;
    @Field(() => DistrictUpdateWithoutSubdistrictsInput, {nullable:false})
    @Type(() => DistrictUpdateWithoutSubdistrictsInput)
    data!: InstanceType<typeof DistrictUpdateWithoutSubdistrictsInput>;
}

@InputType()
export class DistrictUpdateWithWhereUniqueWithoutCityInput {
    @Field(() => DistrictWhereUniqueInput, {nullable:false})
    @Type(() => DistrictWhereUniqueInput)
    where!: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
    @Field(() => DistrictUpdateWithoutCityInput, {nullable:false})
    @Type(() => DistrictUpdateWithoutCityInput)
    data!: InstanceType<typeof DistrictUpdateWithoutCityInput>;
}

@InputType()
export class DistrictUpdateWithoutCityInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => SubdistrictUpdateManyWithoutDistrictNestedInput, {nullable:true})
    subdistricts?: InstanceType<typeof SubdistrictUpdateManyWithoutDistrictNestedInput>;
}

@InputType()
export class DistrictUpdateWithoutSubdistrictsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => CityUpdateOneRequiredWithoutDistrictsNestedInput, {nullable:true})
    city?: InstanceType<typeof CityUpdateOneRequiredWithoutDistrictsNestedInput>;
}

@InputType()
export class DistrictUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => CityUpdateOneRequiredWithoutDistrictsNestedInput, {nullable:true})
    city?: InstanceType<typeof CityUpdateOneRequiredWithoutDistrictsNestedInput>;
    @Field(() => SubdistrictUpdateManyWithoutDistrictNestedInput, {nullable:true})
    subdistricts?: InstanceType<typeof SubdistrictUpdateManyWithoutDistrictNestedInput>;
}

@InputType()
export class DistrictUpsertWithWhereUniqueWithoutCityInput {
    @Field(() => DistrictWhereUniqueInput, {nullable:false})
    @Type(() => DistrictWhereUniqueInput)
    where!: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
    @Field(() => DistrictUpdateWithoutCityInput, {nullable:false})
    @Type(() => DistrictUpdateWithoutCityInput)
    update!: InstanceType<typeof DistrictUpdateWithoutCityInput>;
    @Field(() => DistrictCreateWithoutCityInput, {nullable:false})
    @Type(() => DistrictCreateWithoutCityInput)
    create!: InstanceType<typeof DistrictCreateWithoutCityInput>;
}

@InputType()
export class DistrictUpsertWithoutSubdistrictsInput {
    @Field(() => DistrictUpdateWithoutSubdistrictsInput, {nullable:false})
    @Type(() => DistrictUpdateWithoutSubdistrictsInput)
    update!: InstanceType<typeof DistrictUpdateWithoutSubdistrictsInput>;
    @Field(() => DistrictCreateWithoutSubdistrictsInput, {nullable:false})
    @Type(() => DistrictCreateWithoutSubdistrictsInput)
    create!: InstanceType<typeof DistrictCreateWithoutSubdistrictsInput>;
    @Field(() => DistrictWhereInput, {nullable:true})
    @Type(() => DistrictWhereInput)
    where?: InstanceType<typeof DistrictWhereInput>;
}

@InputType()
export class DistrictWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [DistrictWhereInput], {nullable:true})
    AND?: Array<DistrictWhereInput>;
    @Field(() => [DistrictWhereInput], {nullable:true})
    OR?: Array<DistrictWhereInput>;
    @Field(() => [DistrictWhereInput], {nullable:true})
    NOT?: Array<DistrictWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    cityId?: InstanceType<typeof IntFilter>;
    @Field(() => CityRelationFilter, {nullable:true})
    city?: InstanceType<typeof CityRelationFilter>;
    @Field(() => SubdistrictListRelationFilter, {nullable:true})
    subdistricts?: InstanceType<typeof SubdistrictListRelationFilter>;
}

@InputType()
export class DistrictWhereInput {
    @Field(() => [DistrictWhereInput], {nullable:true})
    AND?: Array<DistrictWhereInput>;
    @Field(() => [DistrictWhereInput], {nullable:true})
    OR?: Array<DistrictWhereInput>;
    @Field(() => [DistrictWhereInput], {nullable:true})
    NOT?: Array<DistrictWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    cityId?: InstanceType<typeof IntFilter>;
    @Field(() => CityRelationFilter, {nullable:true})
    city?: InstanceType<typeof CityRelationFilter>;
    @Field(() => SubdistrictListRelationFilter, {nullable:true})
    subdistricts?: InstanceType<typeof SubdistrictListRelationFilter>;
}

@ObjectType()
export class District {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    cityId!: number;
    @Field(() => City, {nullable:false})
    city?: InstanceType<typeof City>;
    @Field(() => [Subdistrict], {nullable:true})
    subdistricts?: Array<Subdistrict>;
    @Field(() => DistrictCount, {nullable:false})
    _count?: InstanceType<typeof DistrictCount>;
}

@ArgsType()
export class FindFirstDistrictOrThrowArgs {
    @Field(() => DistrictWhereInput, {nullable:true})
    @Type(() => DistrictWhereInput)
    where?: InstanceType<typeof DistrictWhereInput>;
    @Field(() => [DistrictOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<DistrictOrderByWithRelationInput>;
    @Field(() => DistrictWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [DistrictScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof DistrictScalarFieldEnum>;
}

@ArgsType()
export class FindFirstDistrictArgs {
    @Field(() => DistrictWhereInput, {nullable:true})
    @Type(() => DistrictWhereInput)
    where?: InstanceType<typeof DistrictWhereInput>;
    @Field(() => [DistrictOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<DistrictOrderByWithRelationInput>;
    @Field(() => DistrictWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [DistrictScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof DistrictScalarFieldEnum>;
}

@ArgsType()
export class FindManyDistrictArgs {
    @Field(() => DistrictWhereInput, {nullable:true})
    @Type(() => DistrictWhereInput)
    where?: InstanceType<typeof DistrictWhereInput>;
    @Field(() => [DistrictOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<DistrictOrderByWithRelationInput>;
    @Field(() => DistrictWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [DistrictScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof DistrictScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueDistrictOrThrowArgs {
    @Field(() => DistrictWhereUniqueInput, {nullable:false})
    @Type(() => DistrictWhereUniqueInput)
    where!: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueDistrictArgs {
    @Field(() => DistrictWhereUniqueInput, {nullable:false})
    @Type(() => DistrictWhereUniqueInput)
    where!: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpdateManyDistrictArgs {
    @Field(() => DistrictUpdateManyMutationInput, {nullable:false})
    @Type(() => DistrictUpdateManyMutationInput)
    data!: InstanceType<typeof DistrictUpdateManyMutationInput>;
    @Field(() => DistrictWhereInput, {nullable:true})
    @Type(() => DistrictWhereInput)
    where?: InstanceType<typeof DistrictWhereInput>;
}

@ArgsType()
export class UpdateOneDistrictArgs {
    @Field(() => DistrictUpdateInput, {nullable:false})
    @Type(() => DistrictUpdateInput)
    data!: InstanceType<typeof DistrictUpdateInput>;
    @Field(() => DistrictWhereUniqueInput, {nullable:false})
    @Type(() => DistrictWhereUniqueInput)
    where!: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneDistrictArgs {
    @Field(() => DistrictWhereUniqueInput, {nullable:false})
    @Type(() => DistrictWhereUniqueInput)
    where!: Prisma.AtLeast<DistrictWhereUniqueInput, 'id'>;
    @Field(() => DistrictCreateInput, {nullable:false})
    @Type(() => DistrictCreateInput)
    create!: InstanceType<typeof DistrictCreateInput>;
    @Field(() => DistrictUpdateInput, {nullable:false})
    @Type(() => DistrictUpdateInput)
    update!: InstanceType<typeof DistrictUpdateInput>;
}

@ObjectType()
export class AggregateFaq {
    @Field(() => FaqCountAggregate, {nullable:true})
    _count?: InstanceType<typeof FaqCountAggregate>;
    @Field(() => FaqAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof FaqAvgAggregate>;
    @Field(() => FaqSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof FaqSumAggregate>;
    @Field(() => FaqMinAggregate, {nullable:true})
    _min?: InstanceType<typeof FaqMinAggregate>;
    @Field(() => FaqMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof FaqMaxAggregate>;
}

@ArgsType()
export class CreateManyFaqArgs {
    @Field(() => [FaqCreateManyInput], {nullable:false})
    @Type(() => FaqCreateManyInput)
    data!: Array<FaqCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneFaqArgs {
    @Field(() => FaqCreateInput, {nullable:false})
    @Type(() => FaqCreateInput)
    data!: InstanceType<typeof FaqCreateInput>;
}

@ArgsType()
export class DeleteManyFaqArgs {
    @Field(() => FaqWhereInput, {nullable:true})
    @Type(() => FaqWhereInput)
    where?: InstanceType<typeof FaqWhereInput>;
}

@ArgsType()
export class DeleteOneFaqArgs {
    @Field(() => FaqWhereUniqueInput, {nullable:false})
    @Type(() => FaqWhereUniqueInput)
    where!: Prisma.AtLeast<FaqWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FaqAggregateArgs {
    @Field(() => FaqWhereInput, {nullable:true})
    @Type(() => FaqWhereInput)
    where?: InstanceType<typeof FaqWhereInput>;
    @Field(() => [FaqOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<FaqOrderByWithRelationInput>;
    @Field(() => FaqWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<FaqWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => FaqCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof FaqCountAggregateInput>;
    @Field(() => FaqAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof FaqAvgAggregateInput>;
    @Field(() => FaqSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof FaqSumAggregateInput>;
    @Field(() => FaqMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof FaqMinAggregateInput>;
    @Field(() => FaqMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof FaqMaxAggregateInput>;
}

@InputType()
export class FaqAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
}

@ObjectType()
export class FaqAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
}

@InputType()
export class FaqAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
}

@InputType()
export class FaqCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    type?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class FaqCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    description!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    type!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class FaqCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    type?: keyof typeof SortOrder;
}

@InputType()
export class FaqCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => FaqType, {nullable:false})
    type!: keyof typeof FaqType;
}

@InputType()
export class FaqCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => FaqType, {nullable:false})
    type!: keyof typeof FaqType;
}

@ArgsType()
export class FaqGroupByArgs {
    @Field(() => FaqWhereInput, {nullable:true})
    @Type(() => FaqWhereInput)
    where?: InstanceType<typeof FaqWhereInput>;
    @Field(() => [FaqOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<FaqOrderByWithAggregationInput>;
    @Field(() => [FaqScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof FaqScalarFieldEnum>;
    @Field(() => FaqScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof FaqScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => FaqCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof FaqCountAggregateInput>;
    @Field(() => FaqAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof FaqAvgAggregateInput>;
    @Field(() => FaqSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof FaqSumAggregateInput>;
    @Field(() => FaqMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof FaqMinAggregateInput>;
    @Field(() => FaqMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof FaqMaxAggregateInput>;
}

@ObjectType()
export class FaqGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => FaqType, {nullable:false})
    type!: keyof typeof FaqType;
    @Field(() => FaqCountAggregate, {nullable:true})
    _count?: InstanceType<typeof FaqCountAggregate>;
    @Field(() => FaqAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof FaqAvgAggregate>;
    @Field(() => FaqSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof FaqSumAggregate>;
    @Field(() => FaqMinAggregate, {nullable:true})
    _min?: InstanceType<typeof FaqMinAggregate>;
    @Field(() => FaqMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof FaqMaxAggregate>;
}

@InputType()
export class FaqMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    type?: true;
}

@ObjectType()
export class FaqMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => FaqType, {nullable:true})
    type?: keyof typeof FaqType;
}

@InputType()
export class FaqMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    type?: keyof typeof SortOrder;
}

@InputType()
export class FaqMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    type?: true;
}

@ObjectType()
export class FaqMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => FaqType, {nullable:true})
    type?: keyof typeof FaqType;
}

@InputType()
export class FaqMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    type?: keyof typeof SortOrder;
}

@InputType()
export class FaqOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    type?: keyof typeof SortOrder;
    @Field(() => FaqCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof FaqCountOrderByAggregateInput>;
    @Field(() => FaqAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof FaqAvgOrderByAggregateInput>;
    @Field(() => FaqMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof FaqMaxOrderByAggregateInput>;
    @Field(() => FaqMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof FaqMinOrderByAggregateInput>;
    @Field(() => FaqSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof FaqSumOrderByAggregateInput>;
}

@InputType()
export class FaqOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    type?: keyof typeof SortOrder;
}

@InputType()
export class FaqScalarWhereWithAggregatesInput {
    @Field(() => [FaqScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<FaqScalarWhereWithAggregatesInput>;
    @Field(() => [FaqScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<FaqScalarWhereWithAggregatesInput>;
    @Field(() => [FaqScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<FaqScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    description?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => EnumFaqTypeWithAggregatesFilter, {nullable:true})
    type?: InstanceType<typeof EnumFaqTypeWithAggregatesFilter>;
}

@InputType()
export class FaqSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
}

@ObjectType()
export class FaqSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
}

@InputType()
export class FaqSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
}

@InputType()
export class FaqUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => FaqType, {nullable:false})
    type!: keyof typeof FaqType;
}

@InputType()
export class FaqUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumFaqTypeFieldUpdateOperationsInput, {nullable:true})
    type?: InstanceType<typeof EnumFaqTypeFieldUpdateOperationsInput>;
}

@InputType()
export class FaqUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumFaqTypeFieldUpdateOperationsInput, {nullable:true})
    type?: InstanceType<typeof EnumFaqTypeFieldUpdateOperationsInput>;
}

@InputType()
export class FaqUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumFaqTypeFieldUpdateOperationsInput, {nullable:true})
    type?: InstanceType<typeof EnumFaqTypeFieldUpdateOperationsInput>;
}

@InputType()
export class FaqUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumFaqTypeFieldUpdateOperationsInput, {nullable:true})
    type?: InstanceType<typeof EnumFaqTypeFieldUpdateOperationsInput>;
}

@InputType()
export class FaqWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [FaqWhereInput], {nullable:true})
    AND?: Array<FaqWhereInput>;
    @Field(() => [FaqWhereInput], {nullable:true})
    OR?: Array<FaqWhereInput>;
    @Field(() => [FaqWhereInput], {nullable:true})
    NOT?: Array<FaqWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => EnumFaqTypeFilter, {nullable:true})
    type?: InstanceType<typeof EnumFaqTypeFilter>;
}

@InputType()
export class FaqWhereInput {
    @Field(() => [FaqWhereInput], {nullable:true})
    AND?: Array<FaqWhereInput>;
    @Field(() => [FaqWhereInput], {nullable:true})
    OR?: Array<FaqWhereInput>;
    @Field(() => [FaqWhereInput], {nullable:true})
    NOT?: Array<FaqWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => EnumFaqTypeFilter, {nullable:true})
    type?: InstanceType<typeof EnumFaqTypeFilter>;
}

@ObjectType()
export class Faq {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => FaqType, {nullable:false})
    type!: keyof typeof FaqType;
}

@ArgsType()
export class FindFirstFaqOrThrowArgs {
    @Field(() => FaqWhereInput, {nullable:true})
    @Type(() => FaqWhereInput)
    where?: InstanceType<typeof FaqWhereInput>;
    @Field(() => [FaqOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<FaqOrderByWithRelationInput>;
    @Field(() => FaqWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<FaqWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [FaqScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof FaqScalarFieldEnum>;
}

@ArgsType()
export class FindFirstFaqArgs {
    @Field(() => FaqWhereInput, {nullable:true})
    @Type(() => FaqWhereInput)
    where?: InstanceType<typeof FaqWhereInput>;
    @Field(() => [FaqOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<FaqOrderByWithRelationInput>;
    @Field(() => FaqWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<FaqWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [FaqScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof FaqScalarFieldEnum>;
}

@ArgsType()
export class FindManyFaqArgs {
    @Field(() => FaqWhereInput, {nullable:true})
    @Type(() => FaqWhereInput)
    where?: InstanceType<typeof FaqWhereInput>;
    @Field(() => [FaqOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<FaqOrderByWithRelationInput>;
    @Field(() => FaqWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<FaqWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [FaqScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof FaqScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueFaqOrThrowArgs {
    @Field(() => FaqWhereUniqueInput, {nullable:false})
    @Type(() => FaqWhereUniqueInput)
    where!: Prisma.AtLeast<FaqWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueFaqArgs {
    @Field(() => FaqWhereUniqueInput, {nullable:false})
    @Type(() => FaqWhereUniqueInput)
    where!: Prisma.AtLeast<FaqWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpdateManyFaqArgs {
    @Field(() => FaqUpdateManyMutationInput, {nullable:false})
    @Type(() => FaqUpdateManyMutationInput)
    data!: InstanceType<typeof FaqUpdateManyMutationInput>;
    @Field(() => FaqWhereInput, {nullable:true})
    @Type(() => FaqWhereInput)
    where?: InstanceType<typeof FaqWhereInput>;
}

@ArgsType()
export class UpdateOneFaqArgs {
    @Field(() => FaqUpdateInput, {nullable:false})
    @Type(() => FaqUpdateInput)
    data!: InstanceType<typeof FaqUpdateInput>;
    @Field(() => FaqWhereUniqueInput, {nullable:false})
    @Type(() => FaqWhereUniqueInput)
    where!: Prisma.AtLeast<FaqWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneFaqArgs {
    @Field(() => FaqWhereUniqueInput, {nullable:false})
    @Type(() => FaqWhereUniqueInput)
    where!: Prisma.AtLeast<FaqWhereUniqueInput, 'id'>;
    @Field(() => FaqCreateInput, {nullable:false})
    @Type(() => FaqCreateInput)
    create!: InstanceType<typeof FaqCreateInput>;
    @Field(() => FaqUpdateInput, {nullable:false})
    @Type(() => FaqUpdateInput)
    update!: InstanceType<typeof FaqUpdateInput>;
}

@ObjectType()
export class AggregateFile {
    @Field(() => FileCountAggregate, {nullable:true})
    _count?: InstanceType<typeof FileCountAggregate>;
    @Field(() => FileAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof FileAvgAggregate>;
    @Field(() => FileSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof FileSumAggregate>;
    @Field(() => FileMinAggregate, {nullable:true})
    _min?: InstanceType<typeof FileMinAggregate>;
    @Field(() => FileMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof FileMaxAggregate>;
}

@ArgsType()
export class CreateManyFileArgs {
    @Field(() => [FileCreateManyInput], {nullable:false})
    @Type(() => FileCreateManyInput)
    data!: Array<FileCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneFileArgs {
    @Field(() => FileCreateInput, {nullable:false})
    @Type(() => FileCreateInput)
    data!: InstanceType<typeof FileCreateInput>;
}

@ArgsType()
export class DeleteManyFileArgs {
    @Field(() => FileWhereInput, {nullable:true})
    @Type(() => FileWhereInput)
    where?: InstanceType<typeof FileWhereInput>;
}

@ArgsType()
export class DeleteOneFileArgs {
    @Field(() => FileWhereUniqueInput, {nullable:false})
    @Type(() => FileWhereUniqueInput)
    where!: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
}

@ArgsType()
export class FileAggregateArgs {
    @Field(() => FileWhereInput, {nullable:true})
    @Type(() => FileWhereInput)
    where?: InstanceType<typeof FileWhereInput>;
    @Field(() => [FileOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<FileOrderByWithRelationInput>;
    @Field(() => FileWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => FileCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof FileCountAggregateInput>;
    @Field(() => FileAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof FileAvgAggregateInput>;
    @Field(() => FileSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof FileSumAggregateInput>;
    @Field(() => FileMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof FileMinAggregateInput>;
    @Field(() => FileMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof FileMaxAggregateInput>;
}

@InputType()
export class FileAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
}

@ObjectType()
export class FileAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    filesize?: number;
}

@InputType()
export class FileAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
}

@InputType()
export class FileCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    fileType?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    url?: true;
    @Field(() => Boolean, {nullable:true})
    createdById?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class FileCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    fileType!: number;
    @Field(() => Int, {nullable:false})
    filesize!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    description!: number;
    @Field(() => Int, {nullable:false})
    url!: number;
    @Field(() => Int, {nullable:false})
    createdById!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class FileCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class FileCreateManyCreatedByInputEnvelope {
    @Field(() => [FileCreateManyCreatedByInput], {nullable:false})
    @Type(() => FileCreateManyCreatedByInput)
    data!: Array<FileCreateManyCreatedByInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class FileCreateManyCreatedByInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class FileCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class FileCreateNestedManyWithoutCreatedByInput {
    @Field(() => [FileCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => FileCreateWithoutCreatedByInput)
    create?: Array<FileCreateWithoutCreatedByInput>;
    @Field(() => [FileCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => FileCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<FileCreateOrConnectWithoutCreatedByInput>;
    @Field(() => FileCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => FileCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof FileCreateManyCreatedByInputEnvelope>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
}

@InputType()
export class FileCreateOrConnectWithoutCreatedByInput {
    @Field(() => FileWhereUniqueInput, {nullable:false})
    @Type(() => FileWhereUniqueInput)
    where!: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => FileCreateWithoutCreatedByInput, {nullable:false})
    @Type(() => FileCreateWithoutCreatedByInput)
    create!: InstanceType<typeof FileCreateWithoutCreatedByInput>;
}

@InputType()
export class FileCreateWithoutCreatedByInput {
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class FileCreateInput {
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutFilesCreatedInput, {nullable:false})
    createdBy!: InstanceType<typeof UserCreateNestedOneWithoutFilesCreatedInput>;
}

@ArgsType()
export class FileGroupByArgs {
    @Field(() => FileWhereInput, {nullable:true})
    @Type(() => FileWhereInput)
    where?: InstanceType<typeof FileWhereInput>;
    @Field(() => [FileOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<FileOrderByWithAggregationInput>;
    @Field(() => [FileScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof FileScalarFieldEnum>;
    @Field(() => FileScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof FileScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => FileCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof FileCountAggregateInput>;
    @Field(() => FileAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof FileAvgAggregateInput>;
    @Field(() => FileSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof FileSumAggregateInput>;
    @Field(() => FileMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof FileMinAggregateInput>;
    @Field(() => FileMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof FileMaxAggregateInput>;
}

@ObjectType()
export class FileGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => String, {nullable:false})
    url!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => FileCountAggregate, {nullable:true})
    _count?: InstanceType<typeof FileCountAggregate>;
    @Field(() => FileAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof FileAvgAggregate>;
    @Field(() => FileSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof FileSumAggregate>;
    @Field(() => FileMinAggregate, {nullable:true})
    _min?: InstanceType<typeof FileMinAggregate>;
    @Field(() => FileMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof FileMaxAggregate>;
}

@InputType()
export class FileListRelationFilter {
    @Field(() => FileWhereInput, {nullable:true})
    every?: InstanceType<typeof FileWhereInput>;
    @Field(() => FileWhereInput, {nullable:true})
    some?: InstanceType<typeof FileWhereInput>;
    @Field(() => FileWhereInput, {nullable:true})
    none?: InstanceType<typeof FileWhereInput>;
}

@InputType()
export class FileMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    fileType?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    url?: true;
    @Field(() => Boolean, {nullable:true})
    createdById?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class FileMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:true})
    fileType?: keyof typeof FileType;
    @Field(() => Float, {nullable:true})
    filesize?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => String, {nullable:true})
    url?: string;
    @Field(() => String, {nullable:true})
    createdById?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class FileMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class FileMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    fileType?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    url?: true;
    @Field(() => Boolean, {nullable:true})
    createdById?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class FileMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:true})
    fileType?: keyof typeof FileType;
    @Field(() => Float, {nullable:true})
    filesize?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => String, {nullable:true})
    url?: string;
    @Field(() => String, {nullable:true})
    createdById?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class FileMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class FileOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class FileOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => FileCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof FileCountOrderByAggregateInput>;
    @Field(() => FileAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof FileAvgOrderByAggregateInput>;
    @Field(() => FileMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof FileMaxOrderByAggregateInput>;
    @Field(() => FileMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof FileMinOrderByAggregateInput>;
    @Field(() => FileSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof FileSumOrderByAggregateInput>;
}

@InputType()
export class FileOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    createdBy?: InstanceType<typeof UserOrderByWithRelationInput>;
}

@InputType()
export class FileScalarWhereWithAggregatesInput {
    @Field(() => [FileScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<FileScalarWhereWithAggregatesInput>;
    @Field(() => [FileScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<FileScalarWhereWithAggregatesInput>;
    @Field(() => [FileScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<FileScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => EnumFileTypeWithAggregatesFilter, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    filesize?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    description?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    url?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    createdById?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class FileScalarWhereInput {
    @Field(() => [FileScalarWhereInput], {nullable:true})
    AND?: Array<FileScalarWhereInput>;
    @Field(() => [FileScalarWhereInput], {nullable:true})
    OR?: Array<FileScalarWhereInput>;
    @Field(() => [FileScalarWhereInput], {nullable:true})
    NOT?: Array<FileScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => EnumFileTypeFilter, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    filesize?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    url?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    createdById?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class FileSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
}

@ObjectType()
export class FileSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    filesize?: number;
}

@InputType()
export class FileSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
}

@InputType()
export class FileUncheckedCreateNestedManyWithoutCreatedByInput {
    @Field(() => [FileCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => FileCreateWithoutCreatedByInput)
    create?: Array<FileCreateWithoutCreatedByInput>;
    @Field(() => [FileCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => FileCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<FileCreateOrConnectWithoutCreatedByInput>;
    @Field(() => FileCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => FileCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof FileCreateManyCreatedByInputEnvelope>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
}

@InputType()
export class FileUncheckedCreateWithoutCreatedByInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class FileUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class FileUncheckedUpdateManyWithoutCreatedByNestedInput {
    @Field(() => [FileCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => FileCreateWithoutCreatedByInput)
    create?: Array<FileCreateWithoutCreatedByInput>;
    @Field(() => [FileCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => FileCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<FileCreateOrConnectWithoutCreatedByInput>;
    @Field(() => [FileUpsertWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => FileUpsertWithWhereUniqueWithoutCreatedByInput)
    upsert?: Array<FileUpsertWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => FileCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => FileCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof FileCreateManyCreatedByInputEnvelope>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    set?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [FileUpdateWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => FileUpdateWithWhereUniqueWithoutCreatedByInput)
    update?: Array<FileUpdateWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => [FileUpdateManyWithWhereWithoutCreatedByInput], {nullable:true})
    @Type(() => FileUpdateManyWithWhereWithoutCreatedByInput)
    updateMany?: Array<FileUpdateManyWithWhereWithoutCreatedByInput>;
    @Field(() => [FileScalarWhereInput], {nullable:true})
    @Type(() => FileScalarWhereInput)
    deleteMany?: Array<FileScalarWhereInput>;
}

@InputType()
export class FileUncheckedUpdateManyWithoutCreatedByInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class FileUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class FileUncheckedUpdateWithoutCreatedByInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class FileUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class FileUpdateManyMutationInput {
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class FileUpdateManyWithWhereWithoutCreatedByInput {
    @Field(() => FileScalarWhereInput, {nullable:false})
    @Type(() => FileScalarWhereInput)
    where!: InstanceType<typeof FileScalarWhereInput>;
    @Field(() => FileUpdateManyMutationInput, {nullable:false})
    @Type(() => FileUpdateManyMutationInput)
    data!: InstanceType<typeof FileUpdateManyMutationInput>;
}

@InputType()
export class FileUpdateManyWithoutCreatedByNestedInput {
    @Field(() => [FileCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => FileCreateWithoutCreatedByInput)
    create?: Array<FileCreateWithoutCreatedByInput>;
    @Field(() => [FileCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => FileCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<FileCreateOrConnectWithoutCreatedByInput>;
    @Field(() => [FileUpsertWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => FileUpsertWithWhereUniqueWithoutCreatedByInput)
    upsert?: Array<FileUpsertWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => FileCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => FileCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof FileCreateManyCreatedByInputEnvelope>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    set?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [FileWhereUniqueInput], {nullable:true})
    @Type(() => FileWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>>;
    @Field(() => [FileUpdateWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => FileUpdateWithWhereUniqueWithoutCreatedByInput)
    update?: Array<FileUpdateWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => [FileUpdateManyWithWhereWithoutCreatedByInput], {nullable:true})
    @Type(() => FileUpdateManyWithWhereWithoutCreatedByInput)
    updateMany?: Array<FileUpdateManyWithWhereWithoutCreatedByInput>;
    @Field(() => [FileScalarWhereInput], {nullable:true})
    @Type(() => FileScalarWhereInput)
    deleteMany?: Array<FileScalarWhereInput>;
}

@InputType()
export class FileUpdateWithWhereUniqueWithoutCreatedByInput {
    @Field(() => FileWhereUniqueInput, {nullable:false})
    @Type(() => FileWhereUniqueInput)
    where!: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => FileUpdateWithoutCreatedByInput, {nullable:false})
    @Type(() => FileUpdateWithoutCreatedByInput)
    data!: InstanceType<typeof FileUpdateWithoutCreatedByInput>;
}

@InputType()
export class FileUpdateWithoutCreatedByInput {
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class FileUpdateInput {
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutFilesCreatedNestedInput, {nullable:true})
    createdBy?: InstanceType<typeof UserUpdateOneRequiredWithoutFilesCreatedNestedInput>;
}

@InputType()
export class FileUpsertWithWhereUniqueWithoutCreatedByInput {
    @Field(() => FileWhereUniqueInput, {nullable:false})
    @Type(() => FileWhereUniqueInput)
    where!: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => FileUpdateWithoutCreatedByInput, {nullable:false})
    @Type(() => FileUpdateWithoutCreatedByInput)
    update!: InstanceType<typeof FileUpdateWithoutCreatedByInput>;
    @Field(() => FileCreateWithoutCreatedByInput, {nullable:false})
    @Type(() => FileCreateWithoutCreatedByInput)
    create!: InstanceType<typeof FileCreateWithoutCreatedByInput>;
}

@InputType()
export class FileWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    createdById?: string;
    @Field(() => [FileWhereInput], {nullable:true})
    AND?: Array<FileWhereInput>;
    @Field(() => [FileWhereInput], {nullable:true})
    OR?: Array<FileWhereInput>;
    @Field(() => [FileWhereInput], {nullable:true})
    NOT?: Array<FileWhereInput>;
    @Field(() => EnumFileTypeFilter, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    filesize?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    url?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    createdBy?: InstanceType<typeof UserRelationFilter>;
}

@InputType()
export class FileWhereInput {
    @Field(() => [FileWhereInput], {nullable:true})
    AND?: Array<FileWhereInput>;
    @Field(() => [FileWhereInput], {nullable:true})
    OR?: Array<FileWhereInput>;
    @Field(() => [FileWhereInput], {nullable:true})
    NOT?: Array<FileWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => EnumFileTypeFilter, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    filesize?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    url?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    createdById?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    createdBy?: InstanceType<typeof UserRelationFilter>;
}

@ObjectType()
export class File {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => String, {nullable:false})
    url!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => User, {nullable:false})
    createdBy?: InstanceType<typeof User>;
}

@ArgsType()
export class FindFirstFileOrThrowArgs {
    @Field(() => FileWhereInput, {nullable:true})
    @Type(() => FileWhereInput)
    where?: InstanceType<typeof FileWhereInput>;
    @Field(() => [FileOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<FileOrderByWithRelationInput>;
    @Field(() => FileWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [FileScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof FileScalarFieldEnum>;
}

@ArgsType()
export class FindFirstFileArgs {
    @Field(() => FileWhereInput, {nullable:true})
    @Type(() => FileWhereInput)
    where?: InstanceType<typeof FileWhereInput>;
    @Field(() => [FileOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<FileOrderByWithRelationInput>;
    @Field(() => FileWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [FileScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof FileScalarFieldEnum>;
}

@ArgsType()
export class FindManyFileArgs {
    @Field(() => FileWhereInput, {nullable:true})
    @Type(() => FileWhereInput)
    where?: InstanceType<typeof FileWhereInput>;
    @Field(() => [FileOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<FileOrderByWithRelationInput>;
    @Field(() => FileWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [FileScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof FileScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueFileOrThrowArgs {
    @Field(() => FileWhereUniqueInput, {nullable:false})
    @Type(() => FileWhereUniqueInput)
    where!: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
}

@ArgsType()
export class FindUniqueFileArgs {
    @Field(() => FileWhereUniqueInput, {nullable:false})
    @Type(() => FileWhereUniqueInput)
    where!: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
}

@ArgsType()
export class UpdateManyFileArgs {
    @Field(() => FileUpdateManyMutationInput, {nullable:false})
    @Type(() => FileUpdateManyMutationInput)
    data!: InstanceType<typeof FileUpdateManyMutationInput>;
    @Field(() => FileWhereInput, {nullable:true})
    @Type(() => FileWhereInput)
    where?: InstanceType<typeof FileWhereInput>;
}

@ArgsType()
export class UpdateOneFileArgs {
    @Field(() => FileUpdateInput, {nullable:false})
    @Type(() => FileUpdateInput)
    data!: InstanceType<typeof FileUpdateInput>;
    @Field(() => FileWhereUniqueInput, {nullable:false})
    @Type(() => FileWhereUniqueInput)
    where!: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
}

@ArgsType()
export class UpsertOneFileArgs {
    @Field(() => FileWhereUniqueInput, {nullable:false})
    @Type(() => FileWhereUniqueInput)
    where!: Prisma.AtLeast<FileWhereUniqueInput, 'id' | 'createdById'>;
    @Field(() => FileCreateInput, {nullable:false})
    @Type(() => FileCreateInput)
    create!: InstanceType<typeof FileCreateInput>;
    @Field(() => FileUpdateInput, {nullable:false})
    @Type(() => FileUpdateInput)
    update!: InstanceType<typeof FileUpdateInput>;
}

@ObjectType()
export class AggregateHotel {
    @Field(() => HotelCountAggregate, {nullable:true})
    _count?: InstanceType<typeof HotelCountAggregate>;
    @Field(() => HotelAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof HotelAvgAggregate>;
    @Field(() => HotelSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof HotelSumAggregate>;
    @Field(() => HotelMinAggregate, {nullable:true})
    _min?: InstanceType<typeof HotelMinAggregate>;
    @Field(() => HotelMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof HotelMaxAggregate>;
}

@ArgsType()
export class CreateManyHotelArgs {
    @Field(() => [HotelCreateManyInput], {nullable:false})
    @Type(() => HotelCreateManyInput)
    data!: Array<HotelCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneHotelArgs {
    @Field(() => HotelCreateInput, {nullable:false})
    @Type(() => HotelCreateInput)
    data!: InstanceType<typeof HotelCreateInput>;
}

@ArgsType()
export class DeleteManyHotelArgs {
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
}

@ArgsType()
export class DeleteOneHotelArgs {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
}

@ArgsType()
export class FindFirstHotelOrThrowArgs {
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
    @Field(() => [HotelOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<HotelOrderByWithRelationInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [HotelScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof HotelScalarFieldEnum>;
}

@ArgsType()
export class FindFirstHotelArgs {
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
    @Field(() => [HotelOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<HotelOrderByWithRelationInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [HotelScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof HotelScalarFieldEnum>;
}

@ArgsType()
export class FindManyHotelArgs {
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
    @Field(() => [HotelOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<HotelOrderByWithRelationInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [HotelScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof HotelScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueHotelOrThrowArgs {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
}

@ArgsType()
export class FindUniqueHotelArgs {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
}

@ArgsType()
export class HotelAggregateArgs {
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
    @Field(() => [HotelOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<HotelOrderByWithRelationInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => HotelCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof HotelCountAggregateInput>;
    @Field(() => HotelAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof HotelAvgAggregateInput>;
    @Field(() => HotelSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof HotelSumAggregateInput>;
    @Field(() => HotelMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof HotelMinAggregateInput>;
    @Field(() => HotelMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof HotelMaxAggregateInput>;
}

@InputType()
export class HotelAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    rating?: true;
    @Field(() => Boolean, {nullable:true})
    quota?: true;
}

@ObjectType()
export class HotelAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    addressId?: number;
    @Field(() => Float, {nullable:true})
    rating?: number;
    @Field(() => Float, {nullable:true})
    quota?: number;
}

@InputType()
export class HotelAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rating?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    quota?: keyof typeof SortOrder;
}

@InputType()
export class HotelCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    rating?: true;
    @Field(() => Boolean, {nullable:true})
    startDate?: true;
    @Field(() => Boolean, {nullable:true})
    quota?: true;
    @Field(() => Boolean, {nullable:true})
    createdById?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class HotelCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => Int, {nullable:false})
    description!: number;
    @Field(() => Int, {nullable:false})
    rating!: number;
    @Field(() => Int, {nullable:false})
    startDate!: number;
    @Field(() => Int, {nullable:false})
    quota!: number;
    @Field(() => Int, {nullable:false})
    createdById!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class HotelCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rating?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    quota?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@ObjectType()
export class HotelCount {
    @Field(() => Int, {nullable:false})
    images?: number;
    @Field(() => Int, {nullable:false})
    checkIns?: number;
}

@InputType()
export class HotelCreateManyCreatedByInputEnvelope {
    @Field(() => [HotelCreateManyCreatedByInput], {nullable:false})
    @Type(() => HotelCreateManyCreatedByInput)
    data!: Array<HotelCreateManyCreatedByInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class HotelCreateManyCreatedByInput {
    @HideField()
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @HideField()
    addressId!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class HotelCreateManyInput {
    @HideField()
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @HideField()
    addressId!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @HideField()
    createdById!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class HotelCreateNestedManyWithoutCreatedByInput {
    @Field(() => [HotelCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelCreateWithoutCreatedByInput)
    create?: Array<HotelCreateWithoutCreatedByInput>;
    @Field(() => [HotelCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<HotelCreateOrConnectWithoutCreatedByInput>;
    @Field(() => HotelCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => HotelCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof HotelCreateManyCreatedByInputEnvelope>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
}

@InputType()
export class HotelCreateNestedOneWithoutAddressInput {
    @Field(() => HotelCreateWithoutAddressInput, {nullable:true})
    @Type(() => HotelCreateWithoutAddressInput)
    create?: InstanceType<typeof HotelCreateWithoutAddressInput>;
    @Field(() => HotelCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof HotelCreateOrConnectWithoutAddressInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
}

@InputType()
export class HotelCreateNestedOneWithoutCheckInsInput {
    @Field(() => HotelCreateWithoutCheckInsInput, {nullable:true})
    @Type(() => HotelCreateWithoutCheckInsInput)
    create?: InstanceType<typeof HotelCreateWithoutCheckInsInput>;
    @Field(() => HotelCreateOrConnectWithoutCheckInsInput, {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutCheckInsInput)
    connectOrCreate?: InstanceType<typeof HotelCreateOrConnectWithoutCheckInsInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
}

@InputType()
export class HotelCreateNestedOneWithoutImagesInput {
    @Field(() => HotelCreateWithoutImagesInput, {nullable:true})
    @Type(() => HotelCreateWithoutImagesInput)
    create?: InstanceType<typeof HotelCreateWithoutImagesInput>;
    @Field(() => HotelCreateOrConnectWithoutImagesInput, {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutImagesInput)
    connectOrCreate?: InstanceType<typeof HotelCreateOrConnectWithoutImagesInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
}

@InputType()
export class HotelCreateOrConnectWithoutAddressInput {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelCreateWithoutAddressInput, {nullable:false})
    @Type(() => HotelCreateWithoutAddressInput)
    create!: InstanceType<typeof HotelCreateWithoutAddressInput>;
}

@InputType()
export class HotelCreateOrConnectWithoutCheckInsInput {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelCreateWithoutCheckInsInput, {nullable:false})
    @Type(() => HotelCreateWithoutCheckInsInput)
    create!: InstanceType<typeof HotelCreateWithoutCheckInsInput>;
}

@InputType()
export class HotelCreateOrConnectWithoutCreatedByInput {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelCreateWithoutCreatedByInput, {nullable:false})
    @Type(() => HotelCreateWithoutCreatedByInput)
    create!: InstanceType<typeof HotelCreateWithoutCreatedByInput>;
}

@InputType()
export class HotelCreateOrConnectWithoutImagesInput {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelCreateWithoutImagesInput, {nullable:false})
    @Type(() => HotelCreateWithoutImagesInput)
    create!: InstanceType<typeof HotelCreateWithoutImagesInput>;
}

@InputType()
export class HotelCreateWithoutAddressInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutHotelImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesCreateNestedManyWithoutHotelImageInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutHotelInput>;
    @Field(() => UserCreateNestedOneWithoutHotelsCreatedInput, {nullable:false})
    createdBy!: InstanceType<typeof UserCreateNestedOneWithoutHotelsCreatedInput>;
}

@InputType()
export class HotelCreateWithoutCheckInsInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => AddressCreateNestedOneWithoutHotelInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutHotelInput>;
    @Field(() => ImagesCreateNestedManyWithoutHotelImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesCreateNestedManyWithoutHotelImageInput>;
    @Field(() => UserCreateNestedOneWithoutHotelsCreatedInput, {nullable:false})
    createdBy!: InstanceType<typeof UserCreateNestedOneWithoutHotelsCreatedInput>;
}

@InputType()
export class HotelCreateWithoutCreatedByInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => AddressCreateNestedOneWithoutHotelInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutHotelInput>;
    @Field(() => ImagesCreateNestedManyWithoutHotelImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesCreateNestedManyWithoutHotelImageInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutHotelInput>;
}

@InputType()
export class HotelCreateWithoutImagesInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => AddressCreateNestedOneWithoutHotelInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutHotelInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutHotelInput>;
    @Field(() => UserCreateNestedOneWithoutHotelsCreatedInput, {nullable:false})
    createdBy!: InstanceType<typeof UserCreateNestedOneWithoutHotelsCreatedInput>;
}

@InputType()
export class HotelCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => AddressCreateNestedOneWithoutHotelInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutHotelInput>;
    @Field(() => ImagesCreateNestedManyWithoutHotelImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesCreateNestedManyWithoutHotelImageInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutHotelInput>;
    @Field(() => UserCreateNestedOneWithoutHotelsCreatedInput, {nullable:false})
    createdBy!: InstanceType<typeof UserCreateNestedOneWithoutHotelsCreatedInput>;
}

@ArgsType()
export class HotelGroupByArgs {
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
    @Field(() => [HotelOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<HotelOrderByWithAggregationInput>;
    @Field(() => [HotelScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof HotelScalarFieldEnum>;
    @Field(() => HotelScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof HotelScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => HotelCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof HotelCountAggregateInput>;
    @Field(() => HotelAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof HotelAvgAggregateInput>;
    @Field(() => HotelSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof HotelSumAggregateInput>;
    @Field(() => HotelMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof HotelMinAggregateInput>;
    @Field(() => HotelMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof HotelMaxAggregateInput>;
}

@ObjectType()
export class HotelGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => Float, {nullable:false})
    rating!: number;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    quota!: number;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => HotelCountAggregate, {nullable:true})
    _count?: InstanceType<typeof HotelCountAggregate>;
    @Field(() => HotelAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof HotelAvgAggregate>;
    @Field(() => HotelSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof HotelSumAggregate>;
    @Field(() => HotelMinAggregate, {nullable:true})
    _min?: InstanceType<typeof HotelMinAggregate>;
    @Field(() => HotelMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof HotelMaxAggregate>;
}

@InputType()
export class HotelListRelationFilter {
    @Field(() => HotelWhereInput, {nullable:true})
    every?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    some?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    none?: InstanceType<typeof HotelWhereInput>;
}

@InputType()
export class HotelMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    rating?: true;
    @Field(() => Boolean, {nullable:true})
    startDate?: true;
    @Field(() => Boolean, {nullable:true})
    quota?: true;
    @Field(() => Boolean, {nullable:true})
    createdById?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class HotelMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => Float, {nullable:true})
    rating?: number;
    @Field(() => Date, {nullable:true})
    startDate?: Date | string;
    @Field(() => Int, {nullable:true})
    quota?: number;
    @Field(() => String, {nullable:true})
    createdById?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class HotelMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rating?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    quota?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class HotelMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    rating?: true;
    @Field(() => Boolean, {nullable:true})
    startDate?: true;
    @Field(() => Boolean, {nullable:true})
    quota?: true;
    @Field(() => Boolean, {nullable:true})
    createdById?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class HotelMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => Float, {nullable:true})
    rating?: number;
    @Field(() => Date, {nullable:true})
    startDate?: Date | string;
    @Field(() => Int, {nullable:true})
    quota?: number;
    @Field(() => String, {nullable:true})
    createdById?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class HotelMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rating?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    quota?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class HotelNullableRelationFilter {
    @Field(() => HotelWhereInput, {nullable:true})
    is?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    isNot?: InstanceType<typeof HotelWhereInput>;
}

@InputType()
export class HotelOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class HotelOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rating?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    quota?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => HotelCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof HotelCountOrderByAggregateInput>;
    @Field(() => HotelAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof HotelAvgOrderByAggregateInput>;
    @Field(() => HotelMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof HotelMaxOrderByAggregateInput>;
    @Field(() => HotelMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof HotelMinOrderByAggregateInput>;
    @Field(() => HotelSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof HotelSumOrderByAggregateInput>;
}

@InputType()
export class HotelOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rating?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    quota?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => AddressOrderByWithRelationInput, {nullable:true})
    address?: InstanceType<typeof AddressOrderByWithRelationInput>;
    @Field(() => ImagesOrderByRelationAggregateInput, {nullable:true})
    images?: InstanceType<typeof ImagesOrderByRelationAggregateInput>;
    @Field(() => CheckInOrderByRelationAggregateInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInOrderByRelationAggregateInput>;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    createdBy?: InstanceType<typeof UserOrderByWithRelationInput>;
}

@InputType()
export class HotelRelationFilter {
    @Field(() => HotelWhereInput, {nullable:true})
    is?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    isNot?: InstanceType<typeof HotelWhereInput>;
}

@InputType()
export class HotelScalarWhereWithAggregatesInput {
    @Field(() => [HotelScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<HotelScalarWhereWithAggregatesInput>;
    @Field(() => [HotelScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<HotelScalarWhereWithAggregatesInput>;
    @Field(() => [HotelScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<HotelScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    addressId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    description?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    rating?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    quota?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    createdById?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class HotelScalarWhereInput {
    @Field(() => [HotelScalarWhereInput], {nullable:true})
    AND?: Array<HotelScalarWhereInput>;
    @Field(() => [HotelScalarWhereInput], {nullable:true})
    OR?: Array<HotelScalarWhereInput>;
    @Field(() => [HotelScalarWhereInput], {nullable:true})
    NOT?: Array<HotelScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    addressId?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    rating?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => IntFilter, {nullable:true})
    quota?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    createdById?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class HotelSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    rating?: true;
    @Field(() => Boolean, {nullable:true})
    quota?: true;
}

@ObjectType()
export class HotelSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => Float, {nullable:true})
    rating?: number;
    @Field(() => Int, {nullable:true})
    quota?: number;
}

@InputType()
export class HotelSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rating?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    quota?: keyof typeof SortOrder;
}

@InputType()
export class HotelUncheckedCreateNestedManyWithoutCreatedByInput {
    @Field(() => [HotelCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelCreateWithoutCreatedByInput)
    create?: Array<HotelCreateWithoutCreatedByInput>;
    @Field(() => [HotelCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<HotelCreateOrConnectWithoutCreatedByInput>;
    @Field(() => HotelCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => HotelCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof HotelCreateManyCreatedByInputEnvelope>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
}

@InputType()
export class HotelUncheckedCreateNestedOneWithoutAddressInput {
    @Field(() => HotelCreateWithoutAddressInput, {nullable:true})
    @Type(() => HotelCreateWithoutAddressInput)
    create?: InstanceType<typeof HotelCreateWithoutAddressInput>;
    @Field(() => HotelCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof HotelCreateOrConnectWithoutAddressInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
}

@InputType()
export class HotelUncheckedCreateWithoutAddressInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutHotelImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutHotelImageInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutHotelInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutHotelInput>;
}

@InputType()
export class HotelUncheckedCreateWithoutCheckInsInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutHotelImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutHotelImageInput>;
}

@InputType()
export class HotelUncheckedCreateWithoutCreatedByInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutHotelImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutHotelImageInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutHotelInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutHotelInput>;
}

@InputType()
export class HotelUncheckedCreateWithoutImagesInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutHotelInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutHotelInput>;
}

@InputType()
export class HotelUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    rating!: number;
    @Field(() => Date, {nullable:false})
    @Validator.IsDate()
    @Validator.IsNotEmpty()
    startDate!: Date | string;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    quota!: number;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutHotelImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutHotelImageInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutHotelInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutHotelInput>;
}

@InputType()
export class HotelUncheckedUpdateManyWithoutCreatedByNestedInput {
    @Field(() => [HotelCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelCreateWithoutCreatedByInput)
    create?: Array<HotelCreateWithoutCreatedByInput>;
    @Field(() => [HotelCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<HotelCreateOrConnectWithoutCreatedByInput>;
    @Field(() => [HotelUpsertWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelUpsertWithWhereUniqueWithoutCreatedByInput)
    upsert?: Array<HotelUpsertWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => HotelCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => HotelCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof HotelCreateManyCreatedByInputEnvelope>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    set?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
    @Field(() => [HotelUpdateWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelUpdateWithWhereUniqueWithoutCreatedByInput)
    update?: Array<HotelUpdateWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => [HotelUpdateManyWithWhereWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelUpdateManyWithWhereWithoutCreatedByInput)
    updateMany?: Array<HotelUpdateManyWithWhereWithoutCreatedByInput>;
    @Field(() => [HotelScalarWhereInput], {nullable:true})
    @Type(() => HotelScalarWhereInput)
    deleteMany?: Array<HotelScalarWhereInput>;
}

@InputType()
export class HotelUncheckedUpdateManyWithoutCreatedByInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class HotelUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class HotelUncheckedUpdateOneWithoutAddressNestedInput {
    @Field(() => HotelCreateWithoutAddressInput, {nullable:true})
    @Type(() => HotelCreateWithoutAddressInput)
    create?: InstanceType<typeof HotelCreateWithoutAddressInput>;
    @Field(() => HotelCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof HotelCreateOrConnectWithoutAddressInput>;
    @Field(() => HotelUpsertWithoutAddressInput, {nullable:true})
    @Type(() => HotelUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof HotelUpsertWithoutAddressInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    disconnect?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    delete?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => HotelUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof HotelUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class HotelUncheckedUpdateWithoutAddressInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutHotelImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutHotelImageNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutHotelNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutHotelNestedInput>;
}

@InputType()
export class HotelUncheckedUpdateWithoutCheckInsInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutHotelImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutHotelImageNestedInput>;
}

@InputType()
export class HotelUncheckedUpdateWithoutCreatedByInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutHotelImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutHotelImageNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutHotelNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutHotelNestedInput>;
}

@InputType()
export class HotelUncheckedUpdateWithoutImagesInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutHotelNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutHotelNestedInput>;
}

@InputType()
export class HotelUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutHotelImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutHotelImageNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutHotelNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutHotelNestedInput>;
}

@InputType()
export class HotelUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class HotelUpdateManyWithWhereWithoutCreatedByInput {
    @Field(() => HotelScalarWhereInput, {nullable:false})
    @Type(() => HotelScalarWhereInput)
    where!: InstanceType<typeof HotelScalarWhereInput>;
    @Field(() => HotelUpdateManyMutationInput, {nullable:false})
    @Type(() => HotelUpdateManyMutationInput)
    data!: InstanceType<typeof HotelUpdateManyMutationInput>;
}

@InputType()
export class HotelUpdateManyWithoutCreatedByNestedInput {
    @Field(() => [HotelCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelCreateWithoutCreatedByInput)
    create?: Array<HotelCreateWithoutCreatedByInput>;
    @Field(() => [HotelCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<HotelCreateOrConnectWithoutCreatedByInput>;
    @Field(() => [HotelUpsertWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelUpsertWithWhereUniqueWithoutCreatedByInput)
    upsert?: Array<HotelUpsertWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => HotelCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => HotelCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof HotelCreateManyCreatedByInputEnvelope>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    set?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
    @Field(() => [HotelWhereUniqueInput], {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>>;
    @Field(() => [HotelUpdateWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelUpdateWithWhereUniqueWithoutCreatedByInput)
    update?: Array<HotelUpdateWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => [HotelUpdateManyWithWhereWithoutCreatedByInput], {nullable:true})
    @Type(() => HotelUpdateManyWithWhereWithoutCreatedByInput)
    updateMany?: Array<HotelUpdateManyWithWhereWithoutCreatedByInput>;
    @Field(() => [HotelScalarWhereInput], {nullable:true})
    @Type(() => HotelScalarWhereInput)
    deleteMany?: Array<HotelScalarWhereInput>;
}

@InputType()
export class HotelUpdateOneRequiredWithoutCheckInsNestedInput {
    @Field(() => HotelCreateWithoutCheckInsInput, {nullable:true})
    @Type(() => HotelCreateWithoutCheckInsInput)
    create?: InstanceType<typeof HotelCreateWithoutCheckInsInput>;
    @Field(() => HotelCreateOrConnectWithoutCheckInsInput, {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutCheckInsInput)
    connectOrCreate?: InstanceType<typeof HotelCreateOrConnectWithoutCheckInsInput>;
    @Field(() => HotelUpsertWithoutCheckInsInput, {nullable:true})
    @Type(() => HotelUpsertWithoutCheckInsInput)
    upsert?: InstanceType<typeof HotelUpsertWithoutCheckInsInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelUpdateToOneWithWhereWithoutCheckInsInput, {nullable:true})
    @Type(() => HotelUpdateToOneWithWhereWithoutCheckInsInput)
    update?: InstanceType<typeof HotelUpdateToOneWithWhereWithoutCheckInsInput>;
}

@InputType()
export class HotelUpdateOneWithoutAddressNestedInput {
    @Field(() => HotelCreateWithoutAddressInput, {nullable:true})
    @Type(() => HotelCreateWithoutAddressInput)
    create?: InstanceType<typeof HotelCreateWithoutAddressInput>;
    @Field(() => HotelCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof HotelCreateOrConnectWithoutAddressInput>;
    @Field(() => HotelUpsertWithoutAddressInput, {nullable:true})
    @Type(() => HotelUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof HotelUpsertWithoutAddressInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    disconnect?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    delete?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => HotelUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof HotelUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class HotelUpdateOneWithoutImagesNestedInput {
    @Field(() => HotelCreateWithoutImagesInput, {nullable:true})
    @Type(() => HotelCreateWithoutImagesInput)
    create?: InstanceType<typeof HotelCreateWithoutImagesInput>;
    @Field(() => HotelCreateOrConnectWithoutImagesInput, {nullable:true})
    @Type(() => HotelCreateOrConnectWithoutImagesInput)
    connectOrCreate?: InstanceType<typeof HotelCreateOrConnectWithoutImagesInput>;
    @Field(() => HotelUpsertWithoutImagesInput, {nullable:true})
    @Type(() => HotelUpsertWithoutImagesInput)
    upsert?: InstanceType<typeof HotelUpsertWithoutImagesInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    disconnect?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    delete?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:true})
    @Type(() => HotelWhereUniqueInput)
    connect?: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelUpdateToOneWithWhereWithoutImagesInput, {nullable:true})
    @Type(() => HotelUpdateToOneWithWhereWithoutImagesInput)
    update?: InstanceType<typeof HotelUpdateToOneWithWhereWithoutImagesInput>;
}

@InputType()
export class HotelUpdateToOneWithWhereWithoutAddressInput {
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelUpdateWithoutAddressInput, {nullable:false})
    @Type(() => HotelUpdateWithoutAddressInput)
    data!: InstanceType<typeof HotelUpdateWithoutAddressInput>;
}

@InputType()
export class HotelUpdateToOneWithWhereWithoutCheckInsInput {
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelUpdateWithoutCheckInsInput, {nullable:false})
    @Type(() => HotelUpdateWithoutCheckInsInput)
    data!: InstanceType<typeof HotelUpdateWithoutCheckInsInput>;
}

@InputType()
export class HotelUpdateToOneWithWhereWithoutImagesInput {
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
    @Field(() => HotelUpdateWithoutImagesInput, {nullable:false})
    @Type(() => HotelUpdateWithoutImagesInput)
    data!: InstanceType<typeof HotelUpdateWithoutImagesInput>;
}

@InputType()
export class HotelUpdateWithWhereUniqueWithoutCreatedByInput {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelUpdateWithoutCreatedByInput, {nullable:false})
    @Type(() => HotelUpdateWithoutCreatedByInput)
    data!: InstanceType<typeof HotelUpdateWithoutCreatedByInput>;
}

@InputType()
export class HotelUpdateWithoutAddressInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutHotelImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUpdateManyWithoutHotelImageNestedInput>;
    @Field(() => CheckInUpdateManyWithoutHotelNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutHotelNestedInput>;
    @Field(() => UserUpdateOneRequiredWithoutHotelsCreatedNestedInput, {nullable:true})
    createdBy?: InstanceType<typeof UserUpdateOneRequiredWithoutHotelsCreatedNestedInput>;
}

@InputType()
export class HotelUpdateWithoutCheckInsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutHotelNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutHotelNestedInput>;
    @Field(() => ImagesUpdateManyWithoutHotelImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUpdateManyWithoutHotelImageNestedInput>;
    @Field(() => UserUpdateOneRequiredWithoutHotelsCreatedNestedInput, {nullable:true})
    createdBy?: InstanceType<typeof UserUpdateOneRequiredWithoutHotelsCreatedNestedInput>;
}

@InputType()
export class HotelUpdateWithoutCreatedByInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutHotelNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutHotelNestedInput>;
    @Field(() => ImagesUpdateManyWithoutHotelImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUpdateManyWithoutHotelImageNestedInput>;
    @Field(() => CheckInUpdateManyWithoutHotelNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutHotelNestedInput>;
}

@InputType()
export class HotelUpdateWithoutImagesInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutHotelNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutHotelNestedInput>;
    @Field(() => CheckInUpdateManyWithoutHotelNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutHotelNestedInput>;
    @Field(() => UserUpdateOneRequiredWithoutHotelsCreatedNestedInput, {nullable:true})
    createdBy?: InstanceType<typeof UserUpdateOneRequiredWithoutHotelsCreatedNestedInput>;
}

@InputType()
export class HotelUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    rating?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    quota?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutHotelNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutHotelNestedInput>;
    @Field(() => ImagesUpdateManyWithoutHotelImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUpdateManyWithoutHotelImageNestedInput>;
    @Field(() => CheckInUpdateManyWithoutHotelNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutHotelNestedInput>;
    @Field(() => UserUpdateOneRequiredWithoutHotelsCreatedNestedInput, {nullable:true})
    createdBy?: InstanceType<typeof UserUpdateOneRequiredWithoutHotelsCreatedNestedInput>;
}

@InputType()
export class HotelUpsertWithWhereUniqueWithoutCreatedByInput {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelUpdateWithoutCreatedByInput, {nullable:false})
    @Type(() => HotelUpdateWithoutCreatedByInput)
    update!: InstanceType<typeof HotelUpdateWithoutCreatedByInput>;
    @Field(() => HotelCreateWithoutCreatedByInput, {nullable:false})
    @Type(() => HotelCreateWithoutCreatedByInput)
    create!: InstanceType<typeof HotelCreateWithoutCreatedByInput>;
}

@InputType()
export class HotelUpsertWithoutAddressInput {
    @Field(() => HotelUpdateWithoutAddressInput, {nullable:false})
    @Type(() => HotelUpdateWithoutAddressInput)
    update!: InstanceType<typeof HotelUpdateWithoutAddressInput>;
    @Field(() => HotelCreateWithoutAddressInput, {nullable:false})
    @Type(() => HotelCreateWithoutAddressInput)
    create!: InstanceType<typeof HotelCreateWithoutAddressInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
}

@InputType()
export class HotelUpsertWithoutCheckInsInput {
    @Field(() => HotelUpdateWithoutCheckInsInput, {nullable:false})
    @Type(() => HotelUpdateWithoutCheckInsInput)
    update!: InstanceType<typeof HotelUpdateWithoutCheckInsInput>;
    @Field(() => HotelCreateWithoutCheckInsInput, {nullable:false})
    @Type(() => HotelCreateWithoutCheckInsInput)
    create!: InstanceType<typeof HotelCreateWithoutCheckInsInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
}

@InputType()
export class HotelUpsertWithoutImagesInput {
    @Field(() => HotelUpdateWithoutImagesInput, {nullable:false})
    @Type(() => HotelUpdateWithoutImagesInput)
    update!: InstanceType<typeof HotelUpdateWithoutImagesInput>;
    @Field(() => HotelCreateWithoutImagesInput, {nullable:false})
    @Type(() => HotelCreateWithoutImagesInput)
    create!: InstanceType<typeof HotelCreateWithoutImagesInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
}

@InputType()
export class HotelWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => [HotelWhereInput], {nullable:true})
    AND?: Array<HotelWhereInput>;
    @Field(() => [HotelWhereInput], {nullable:true})
    OR?: Array<HotelWhereInput>;
    @Field(() => [HotelWhereInput], {nullable:true})
    NOT?: Array<HotelWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    rating?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => IntFilter, {nullable:true})
    quota?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    createdById?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => AddressRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressRelationFilter>;
    @Field(() => ImagesListRelationFilter, {nullable:true})
    images?: InstanceType<typeof ImagesListRelationFilter>;
    @Field(() => CheckInListRelationFilter, {nullable:true})
    checkIns?: InstanceType<typeof CheckInListRelationFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    createdBy?: InstanceType<typeof UserRelationFilter>;
}

@InputType()
export class HotelWhereInput {
    @Field(() => [HotelWhereInput], {nullable:true})
    AND?: Array<HotelWhereInput>;
    @Field(() => [HotelWhereInput], {nullable:true})
    OR?: Array<HotelWhereInput>;
    @Field(() => [HotelWhereInput], {nullable:true})
    NOT?: Array<HotelWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    addressId?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    rating?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => IntFilter, {nullable:true})
    quota?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    createdById?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => AddressRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressRelationFilter>;
    @Field(() => ImagesListRelationFilter, {nullable:true})
    images?: InstanceType<typeof ImagesListRelationFilter>;
    @Field(() => CheckInListRelationFilter, {nullable:true})
    checkIns?: InstanceType<typeof CheckInListRelationFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    createdBy?: InstanceType<typeof UserRelationFilter>;
}

@ObjectType()
export class Hotel {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => Float, {nullable:false})
    rating!: number;
    @Field(() => Date, {nullable:false})
    startDate!: Date;
    @Field(() => Int, {nullable:false})
    quota!: number;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => Address, {nullable:false})
    address?: InstanceType<typeof Address>;
    @Field(() => [Images], {nullable:true})
    images?: Array<Images>;
    @Field(() => [CheckIn], {nullable:true})
    checkIns?: Array<CheckIn>;
    @Field(() => User, {nullable:false})
    createdBy?: InstanceType<typeof User>;
    @Field(() => HotelCount, {nullable:false})
    _count?: InstanceType<typeof HotelCount>;
}

@ArgsType()
export class UpdateManyHotelArgs {
    @Field(() => HotelUpdateManyMutationInput, {nullable:false})
    @Type(() => HotelUpdateManyMutationInput)
    data!: InstanceType<typeof HotelUpdateManyMutationInput>;
    @Field(() => HotelWhereInput, {nullable:true})
    @Type(() => HotelWhereInput)
    where?: InstanceType<typeof HotelWhereInput>;
}

@ArgsType()
export class UpdateOneHotelArgs {
    @Field(() => HotelUpdateInput, {nullable:false})
    @Type(() => HotelUpdateInput)
    data!: InstanceType<typeof HotelUpdateInput>;
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
}

@ArgsType()
export class UpsertOneHotelArgs {
    @Field(() => HotelWhereUniqueInput, {nullable:false})
    @Type(() => HotelWhereUniqueInput)
    where!: Prisma.AtLeast<HotelWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => HotelCreateInput, {nullable:false})
    @Type(() => HotelCreateInput)
    create!: InstanceType<typeof HotelCreateInput>;
    @Field(() => HotelUpdateInput, {nullable:false})
    @Type(() => HotelUpdateInput)
    update!: InstanceType<typeof HotelUpdateInput>;
}

@ObjectType()
export class AggregateImages {
    @Field(() => ImagesCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ImagesCountAggregate>;
    @Field(() => ImagesAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ImagesAvgAggregate>;
    @Field(() => ImagesSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ImagesSumAggregate>;
    @Field(() => ImagesMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ImagesMinAggregate>;
    @Field(() => ImagesMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ImagesMaxAggregate>;
}

@ArgsType()
export class CreateManyImagesArgs {
    @Field(() => [ImagesCreateManyInput], {nullable:false})
    @Type(() => ImagesCreateManyInput)
    data!: Array<ImagesCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneImagesArgs {
    @Field(() => ImagesCreateInput, {nullable:false})
    @Type(() => ImagesCreateInput)
    data!: InstanceType<typeof ImagesCreateInput>;
}

@ArgsType()
export class DeleteManyImagesArgs {
    @Field(() => ImagesWhereInput, {nullable:true})
    @Type(() => ImagesWhereInput)
    where?: InstanceType<typeof ImagesWhereInput>;
}

@ArgsType()
export class DeleteOneImagesArgs {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstImagesOrThrowArgs {
    @Field(() => ImagesWhereInput, {nullable:true})
    @Type(() => ImagesWhereInput)
    where?: InstanceType<typeof ImagesWhereInput>;
    @Field(() => [ImagesOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ImagesOrderByWithRelationInput>;
    @Field(() => ImagesWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ImagesScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ImagesScalarFieldEnum>;
}

@ArgsType()
export class FindFirstImagesArgs {
    @Field(() => ImagesWhereInput, {nullable:true})
    @Type(() => ImagesWhereInput)
    where?: InstanceType<typeof ImagesWhereInput>;
    @Field(() => [ImagesOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ImagesOrderByWithRelationInput>;
    @Field(() => ImagesWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ImagesScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ImagesScalarFieldEnum>;
}

@ArgsType()
export class FindManyImagesArgs {
    @Field(() => ImagesWhereInput, {nullable:true})
    @Type(() => ImagesWhereInput)
    where?: InstanceType<typeof ImagesWhereInput>;
    @Field(() => [ImagesOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ImagesOrderByWithRelationInput>;
    @Field(() => ImagesWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ImagesScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ImagesScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueImagesOrThrowArgs {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueImagesArgs {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
}

@ArgsType()
export class ImagesAggregateArgs {
    @Field(() => ImagesWhereInput, {nullable:true})
    @Type(() => ImagesWhereInput)
    where?: InstanceType<typeof ImagesWhereInput>;
    @Field(() => [ImagesOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ImagesOrderByWithRelationInput>;
    @Field(() => ImagesWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ImagesCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ImagesCountAggregateInput>;
    @Field(() => ImagesAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ImagesAvgAggregateInput>;
    @Field(() => ImagesSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ImagesSumAggregateInput>;
    @Field(() => ImagesMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ImagesMinAggregateInput>;
    @Field(() => ImagesMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ImagesMaxAggregateInput>;
}

@InputType()
export class ImagesAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
    @Field(() => Boolean, {nullable:true})
    hotelImageId?: true;
    @Field(() => Boolean, {nullable:true})
    programImageId?: true;
    @Field(() => Boolean, {nullable:true})
    rewardImageId?: true;
    @Field(() => Boolean, {nullable:true})
    projectImageId?: true;
}

@ObjectType()
export class ImagesAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    filesize?: number;
    @Field(() => Float, {nullable:true})
    hotelImageId?: number;
    @Field(() => Float, {nullable:true})
    programImageId?: number;
    @Field(() => Float, {nullable:true})
    rewardImageId?: number;
    @Field(() => Float, {nullable:true})
    projectImageId?: number;
}

@InputType()
export class ImagesAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    programImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rewardImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectImageId?: keyof typeof SortOrder;
}

@InputType()
export class ImagesCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    fileType?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
    @Field(() => Boolean, {nullable:true})
    url?: true;
    @Field(() => Boolean, {nullable:true})
    hotelImageId?: true;
    @Field(() => Boolean, {nullable:true})
    programImageId?: true;
    @Field(() => Boolean, {nullable:true})
    rewardImageId?: true;
    @Field(() => Boolean, {nullable:true})
    projectImageId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class ImagesCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    fileType!: number;
    @Field(() => Int, {nullable:false})
    filesize!: number;
    @Field(() => Int, {nullable:false})
    url!: number;
    @Field(() => Int, {nullable:false})
    hotelImageId!: number;
    @Field(() => Int, {nullable:false})
    programImageId!: number;
    @Field(() => Int, {nullable:false})
    rewardImageId!: number;
    @Field(() => Int, {nullable:false})
    projectImageId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class ImagesCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    programImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rewardImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class ImagesCreateManyHotelImageInputEnvelope {
    @Field(() => [ImagesCreateManyHotelImageInput], {nullable:false})
    @Type(() => ImagesCreateManyHotelImageInput)
    data!: Array<ImagesCreateManyHotelImageInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class ImagesCreateManyHotelImageInput {
    @HideField()
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    programImageId?: number;
    @HideField()
    rewardImageId?: number;
    @HideField()
    projectImageId?: number;
    @HideField()
    createdAt?: Date | string;
}

@InputType()
export class ImagesCreateManyProgramImageInputEnvelope {
    @Field(() => [ImagesCreateManyProgramImageInput], {nullable:false})
    @Type(() => ImagesCreateManyProgramImageInput)
    data!: Array<ImagesCreateManyProgramImageInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class ImagesCreateManyProgramImageInput {
    @HideField()
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    hotelImageId?: number;
    @HideField()
    rewardImageId?: number;
    @HideField()
    projectImageId?: number;
    @HideField()
    createdAt?: Date | string;
}

@InputType()
export class ImagesCreateManyProjectImageInputEnvelope {
    @Field(() => [ImagesCreateManyProjectImageInput], {nullable:false})
    @Type(() => ImagesCreateManyProjectImageInput)
    data!: Array<ImagesCreateManyProjectImageInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class ImagesCreateManyProjectImageInput {
    @HideField()
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    hotelImageId?: number;
    @HideField()
    programImageId?: number;
    @HideField()
    rewardImageId?: number;
    @HideField()
    createdAt?: Date | string;
}

@InputType()
export class ImagesCreateManyRewardImageInputEnvelope {
    @Field(() => [ImagesCreateManyRewardImageInput], {nullable:false})
    @Type(() => ImagesCreateManyRewardImageInput)
    data!: Array<ImagesCreateManyRewardImageInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class ImagesCreateManyRewardImageInput {
    @HideField()
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    hotelImageId?: number;
    @HideField()
    programImageId?: number;
    @HideField()
    projectImageId?: number;
    @HideField()
    createdAt?: Date | string;
}

@InputType()
export class ImagesCreateManyInput {
    @HideField()
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    hotelImageId?: number;
    @HideField()
    programImageId?: number;
    @HideField()
    rewardImageId?: number;
    @HideField()
    projectImageId?: number;
    @HideField()
    createdAt?: Date | string;
}

@InputType()
export class ImagesCreateNestedManyWithoutHotelImageInput {
    @Field(() => [ImagesCreateWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutHotelImageInput)
    create?: Array<ImagesCreateWithoutHotelImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutHotelImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutHotelImageInput>;
    @Field(() => ImagesCreateManyHotelImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyHotelImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyHotelImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
}

@InputType()
export class ImagesCreateNestedManyWithoutProgramImageInput {
    @Field(() => [ImagesCreateWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutProgramImageInput)
    create?: Array<ImagesCreateWithoutProgramImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutProgramImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutProgramImageInput>;
    @Field(() => ImagesCreateManyProgramImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyProgramImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyProgramImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
}

@InputType()
export class ImagesCreateNestedManyWithoutProjectImageInput {
    @Field(() => [ImagesCreateWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutProjectImageInput)
    create?: Array<ImagesCreateWithoutProjectImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutProjectImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutProjectImageInput>;
    @Field(() => ImagesCreateManyProjectImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyProjectImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyProjectImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
}

@InputType()
export class ImagesCreateNestedManyWithoutRewardImageInput {
    @Field(() => [ImagesCreateWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutRewardImageInput)
    create?: Array<ImagesCreateWithoutRewardImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutRewardImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutRewardImageInput>;
    @Field(() => ImagesCreateManyRewardImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyRewardImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyRewardImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
}

@InputType()
export class ImagesCreateOrConnectWithoutHotelImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesCreateWithoutHotelImageInput, {nullable:false})
    @Type(() => ImagesCreateWithoutHotelImageInput)
    create!: InstanceType<typeof ImagesCreateWithoutHotelImageInput>;
}

@InputType()
export class ImagesCreateOrConnectWithoutProgramImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesCreateWithoutProgramImageInput, {nullable:false})
    @Type(() => ImagesCreateWithoutProgramImageInput)
    create!: InstanceType<typeof ImagesCreateWithoutProgramImageInput>;
}

@InputType()
export class ImagesCreateOrConnectWithoutProjectImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesCreateWithoutProjectImageInput, {nullable:false})
    @Type(() => ImagesCreateWithoutProjectImageInput)
    create!: InstanceType<typeof ImagesCreateWithoutProjectImageInput>;
}

@InputType()
export class ImagesCreateOrConnectWithoutRewardImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesCreateWithoutRewardImageInput, {nullable:false})
    @Type(() => ImagesCreateWithoutRewardImageInput)
    create!: InstanceType<typeof ImagesCreateWithoutRewardImageInput>;
}

@InputType()
export class ImagesCreateWithoutHotelImageInput {
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    programImage?: InstanceType<typeof ProgramCreateNestedOneWithoutImagesInput>;
    @HideField()
    rewardImage?: InstanceType<typeof RewardCreateNestedOneWithoutImagesInput>;
    @HideField()
    projectImage?: InstanceType<typeof ProjectCreateNestedOneWithoutImagesInput>;
}

@InputType()
export class ImagesCreateWithoutProgramImageInput {
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    hotelImage?: InstanceType<typeof HotelCreateNestedOneWithoutImagesInput>;
    @HideField()
    rewardImage?: InstanceType<typeof RewardCreateNestedOneWithoutImagesInput>;
    @HideField()
    projectImage?: InstanceType<typeof ProjectCreateNestedOneWithoutImagesInput>;
}

@InputType()
export class ImagesCreateWithoutProjectImageInput {
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    hotelImage?: InstanceType<typeof HotelCreateNestedOneWithoutImagesInput>;
    @HideField()
    programImage?: InstanceType<typeof ProgramCreateNestedOneWithoutImagesInput>;
    @HideField()
    rewardImage?: InstanceType<typeof RewardCreateNestedOneWithoutImagesInput>;
}

@InputType()
export class ImagesCreateWithoutRewardImageInput {
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    hotelImage?: InstanceType<typeof HotelCreateNestedOneWithoutImagesInput>;
    @HideField()
    programImage?: InstanceType<typeof ProgramCreateNestedOneWithoutImagesInput>;
    @HideField()
    projectImage?: InstanceType<typeof ProjectCreateNestedOneWithoutImagesInput>;
}

@InputType()
export class ImagesCreateInput {
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    hotelImage?: InstanceType<typeof HotelCreateNestedOneWithoutImagesInput>;
    @HideField()
    programImage?: InstanceType<typeof ProgramCreateNestedOneWithoutImagesInput>;
    @HideField()
    rewardImage?: InstanceType<typeof RewardCreateNestedOneWithoutImagesInput>;
    @HideField()
    projectImage?: InstanceType<typeof ProjectCreateNestedOneWithoutImagesInput>;
}

@ArgsType()
export class ImagesGroupByArgs {
    @Field(() => ImagesWhereInput, {nullable:true})
    @Type(() => ImagesWhereInput)
    where?: InstanceType<typeof ImagesWhereInput>;
    @Field(() => [ImagesOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<ImagesOrderByWithAggregationInput>;
    @Field(() => [ImagesScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof ImagesScalarFieldEnum>;
    @Field(() => ImagesScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof ImagesScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ImagesCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ImagesCountAggregateInput>;
    @Field(() => ImagesAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ImagesAvgAggregateInput>;
    @Field(() => ImagesSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ImagesSumAggregateInput>;
    @Field(() => ImagesMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ImagesMinAggregateInput>;
    @Field(() => ImagesMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ImagesMaxAggregateInput>;
}

@ObjectType()
export class ImagesGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    url!: string;
    @Field(() => Int, {nullable:true})
    hotelImageId?: number;
    @Field(() => Int, {nullable:true})
    programImageId?: number;
    @Field(() => Int, {nullable:true})
    rewardImageId?: number;
    @Field(() => Int, {nullable:true})
    projectImageId?: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => ImagesCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ImagesCountAggregate>;
    @Field(() => ImagesAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ImagesAvgAggregate>;
    @Field(() => ImagesSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ImagesSumAggregate>;
    @Field(() => ImagesMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ImagesMinAggregate>;
    @Field(() => ImagesMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ImagesMaxAggregate>;
}

@InputType()
export class ImagesListRelationFilter {
    @Field(() => ImagesWhereInput, {nullable:true})
    every?: InstanceType<typeof ImagesWhereInput>;
    @Field(() => ImagesWhereInput, {nullable:true})
    some?: InstanceType<typeof ImagesWhereInput>;
    @Field(() => ImagesWhereInput, {nullable:true})
    none?: InstanceType<typeof ImagesWhereInput>;
}

@InputType()
export class ImagesMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    fileType?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
    @Field(() => Boolean, {nullable:true})
    url?: true;
    @Field(() => Boolean, {nullable:true})
    hotelImageId?: true;
    @Field(() => Boolean, {nullable:true})
    programImageId?: true;
    @Field(() => Boolean, {nullable:true})
    rewardImageId?: true;
    @Field(() => Boolean, {nullable:true})
    projectImageId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
}

@ObjectType()
export class ImagesMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:true})
    fileType?: keyof typeof FileType;
    @Field(() => Float, {nullable:true})
    filesize?: number;
    @Field(() => String, {nullable:true})
    url?: string;
    @Field(() => Int, {nullable:true})
    hotelImageId?: number;
    @Field(() => Int, {nullable:true})
    programImageId?: number;
    @Field(() => Int, {nullable:true})
    rewardImageId?: number;
    @Field(() => Int, {nullable:true})
    projectImageId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class ImagesMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    programImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rewardImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class ImagesMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    fileType?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
    @Field(() => Boolean, {nullable:true})
    url?: true;
    @Field(() => Boolean, {nullable:true})
    hotelImageId?: true;
    @Field(() => Boolean, {nullable:true})
    programImageId?: true;
    @Field(() => Boolean, {nullable:true})
    rewardImageId?: true;
    @Field(() => Boolean, {nullable:true})
    projectImageId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
}

@ObjectType()
export class ImagesMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:true})
    fileType?: keyof typeof FileType;
    @Field(() => Float, {nullable:true})
    filesize?: number;
    @Field(() => String, {nullable:true})
    url?: string;
    @Field(() => Int, {nullable:true})
    hotelImageId?: number;
    @Field(() => Int, {nullable:true})
    programImageId?: number;
    @Field(() => Int, {nullable:true})
    rewardImageId?: number;
    @Field(() => Int, {nullable:true})
    projectImageId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class ImagesMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    programImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rewardImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class ImagesOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class ImagesOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    hotelImageId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    programImageId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    rewardImageId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    projectImageId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => ImagesCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ImagesCountOrderByAggregateInput>;
    @Field(() => ImagesAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ImagesAvgOrderByAggregateInput>;
    @Field(() => ImagesMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ImagesMaxOrderByAggregateInput>;
    @Field(() => ImagesMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ImagesMinOrderByAggregateInput>;
    @Field(() => ImagesSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ImagesSumOrderByAggregateInput>;
}

@InputType()
export class ImagesOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fileType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    url?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    hotelImageId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    programImageId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    rewardImageId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    projectImageId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => HotelOrderByWithRelationInput, {nullable:true})
    hotelImage?: InstanceType<typeof HotelOrderByWithRelationInput>;
    @Field(() => ProgramOrderByWithRelationInput, {nullable:true})
    programImage?: InstanceType<typeof ProgramOrderByWithRelationInput>;
    @Field(() => RewardOrderByWithRelationInput, {nullable:true})
    rewardImage?: InstanceType<typeof RewardOrderByWithRelationInput>;
    @Field(() => ProjectOrderByWithRelationInput, {nullable:true})
    projectImage?: InstanceType<typeof ProjectOrderByWithRelationInput>;
}

@InputType()
export class ImagesScalarWhereWithAggregatesInput {
    @Field(() => [ImagesScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<ImagesScalarWhereWithAggregatesInput>;
    @Field(() => [ImagesScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<ImagesScalarWhereWithAggregatesInput>;
    @Field(() => [ImagesScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<ImagesScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => EnumFileTypeWithAggregatesFilter, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    filesize?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    url?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntNullableWithAggregatesFilter, {nullable:true})
    hotelImageId?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => IntNullableWithAggregatesFilter, {nullable:true})
    programImageId?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => IntNullableWithAggregatesFilter, {nullable:true})
    rewardImageId?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => IntNullableWithAggregatesFilter, {nullable:true})
    projectImageId?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class ImagesScalarWhereInput {
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    AND?: Array<ImagesScalarWhereInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    OR?: Array<ImagesScalarWhereInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    NOT?: Array<ImagesScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => EnumFileTypeFilter, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    filesize?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    url?: InstanceType<typeof StringFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    hotelImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    programImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    rewardImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    projectImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class ImagesSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    filesize?: true;
    @Field(() => Boolean, {nullable:true})
    hotelImageId?: true;
    @Field(() => Boolean, {nullable:true})
    programImageId?: true;
    @Field(() => Boolean, {nullable:true})
    rewardImageId?: true;
    @Field(() => Boolean, {nullable:true})
    projectImageId?: true;
}

@ObjectType()
export class ImagesSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    filesize?: number;
    @Field(() => Int, {nullable:true})
    hotelImageId?: number;
    @Field(() => Int, {nullable:true})
    programImageId?: number;
    @Field(() => Int, {nullable:true})
    rewardImageId?: number;
    @Field(() => Int, {nullable:true})
    projectImageId?: number;
}

@InputType()
export class ImagesSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    filesize?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    hotelImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    programImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rewardImageId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectImageId?: keyof typeof SortOrder;
}

@InputType()
export class ImagesUncheckedCreateNestedManyWithoutHotelImageInput {
    @Field(() => [ImagesCreateWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutHotelImageInput)
    create?: Array<ImagesCreateWithoutHotelImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutHotelImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutHotelImageInput>;
    @Field(() => ImagesCreateManyHotelImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyHotelImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyHotelImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
}

@InputType()
export class ImagesUncheckedCreateNestedManyWithoutProgramImageInput {
    @Field(() => [ImagesCreateWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutProgramImageInput)
    create?: Array<ImagesCreateWithoutProgramImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutProgramImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutProgramImageInput>;
    @Field(() => ImagesCreateManyProgramImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyProgramImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyProgramImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
}

@InputType()
export class ImagesUncheckedCreateNestedManyWithoutProjectImageInput {
    @Field(() => [ImagesCreateWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutProjectImageInput)
    create?: Array<ImagesCreateWithoutProjectImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutProjectImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutProjectImageInput>;
    @Field(() => ImagesCreateManyProjectImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyProjectImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyProjectImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
}

@InputType()
export class ImagesUncheckedCreateNestedManyWithoutRewardImageInput {
    @Field(() => [ImagesCreateWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutRewardImageInput)
    create?: Array<ImagesCreateWithoutRewardImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutRewardImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutRewardImageInput>;
    @Field(() => ImagesCreateManyRewardImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyRewardImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyRewardImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
}

@InputType()
export class ImagesUncheckedCreateWithoutHotelImageInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => Int, {nullable:true})
    programImageId?: number;
    @Field(() => Int, {nullable:true})
    rewardImageId?: number;
    @Field(() => Int, {nullable:true})
    projectImageId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class ImagesUncheckedCreateWithoutProgramImageInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => Int, {nullable:true})
    hotelImageId?: number;
    @Field(() => Int, {nullable:true})
    rewardImageId?: number;
    @Field(() => Int, {nullable:true})
    projectImageId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class ImagesUncheckedCreateWithoutProjectImageInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => Int, {nullable:true})
    hotelImageId?: number;
    @Field(() => Int, {nullable:true})
    programImageId?: number;
    @Field(() => Int, {nullable:true})
    rewardImageId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class ImagesUncheckedCreateWithoutRewardImageInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => Int, {nullable:true})
    hotelImageId?: number;
    @Field(() => Int, {nullable:true})
    programImageId?: number;
    @Field(() => Int, {nullable:true})
    projectImageId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class ImagesUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    filesize!: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsUrl({ require_protocol: true })
    url!: string;
    @Field(() => Int, {nullable:true})
    hotelImageId?: number;
    @Field(() => Int, {nullable:true})
    programImageId?: number;
    @Field(() => Int, {nullable:true})
    rewardImageId?: number;
    @Field(() => Int, {nullable:true})
    projectImageId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class ImagesUncheckedUpdateManyWithoutHotelImageNestedInput {
    @Field(() => [ImagesCreateWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutHotelImageInput)
    create?: Array<ImagesCreateWithoutHotelImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutHotelImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutHotelImageInput>;
    @Field(() => [ImagesUpsertWithWhereUniqueWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesUpsertWithWhereUniqueWithoutHotelImageInput)
    upsert?: Array<ImagesUpsertWithWhereUniqueWithoutHotelImageInput>;
    @Field(() => ImagesCreateManyHotelImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyHotelImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyHotelImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesUpdateWithWhereUniqueWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesUpdateWithWhereUniqueWithoutHotelImageInput)
    update?: Array<ImagesUpdateWithWhereUniqueWithoutHotelImageInput>;
    @Field(() => [ImagesUpdateManyWithWhereWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesUpdateManyWithWhereWithoutHotelImageInput)
    updateMany?: Array<ImagesUpdateManyWithWhereWithoutHotelImageInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    @Type(() => ImagesScalarWhereInput)
    deleteMany?: Array<ImagesScalarWhereInput>;
}

@InputType()
export class ImagesUncheckedUpdateManyWithoutHotelImageInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    programImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    rewardImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUncheckedUpdateManyWithoutProgramImageNestedInput {
    @Field(() => [ImagesCreateWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutProgramImageInput)
    create?: Array<ImagesCreateWithoutProgramImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutProgramImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutProgramImageInput>;
    @Field(() => [ImagesUpsertWithWhereUniqueWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesUpsertWithWhereUniqueWithoutProgramImageInput)
    upsert?: Array<ImagesUpsertWithWhereUniqueWithoutProgramImageInput>;
    @Field(() => ImagesCreateManyProgramImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyProgramImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyProgramImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesUpdateWithWhereUniqueWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesUpdateWithWhereUniqueWithoutProgramImageInput)
    update?: Array<ImagesUpdateWithWhereUniqueWithoutProgramImageInput>;
    @Field(() => [ImagesUpdateManyWithWhereWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesUpdateManyWithWhereWithoutProgramImageInput)
    updateMany?: Array<ImagesUpdateManyWithWhereWithoutProgramImageInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    @Type(() => ImagesScalarWhereInput)
    deleteMany?: Array<ImagesScalarWhereInput>;
}

@InputType()
export class ImagesUncheckedUpdateManyWithoutProgramImageInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    hotelImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    rewardImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUncheckedUpdateManyWithoutProjectImageNestedInput {
    @Field(() => [ImagesCreateWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutProjectImageInput)
    create?: Array<ImagesCreateWithoutProjectImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutProjectImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutProjectImageInput>;
    @Field(() => [ImagesUpsertWithWhereUniqueWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesUpsertWithWhereUniqueWithoutProjectImageInput)
    upsert?: Array<ImagesUpsertWithWhereUniqueWithoutProjectImageInput>;
    @Field(() => ImagesCreateManyProjectImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyProjectImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyProjectImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesUpdateWithWhereUniqueWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesUpdateWithWhereUniqueWithoutProjectImageInput)
    update?: Array<ImagesUpdateWithWhereUniqueWithoutProjectImageInput>;
    @Field(() => [ImagesUpdateManyWithWhereWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesUpdateManyWithWhereWithoutProjectImageInput)
    updateMany?: Array<ImagesUpdateManyWithWhereWithoutProjectImageInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    @Type(() => ImagesScalarWhereInput)
    deleteMany?: Array<ImagesScalarWhereInput>;
}

@InputType()
export class ImagesUncheckedUpdateManyWithoutProjectImageInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    hotelImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    programImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    rewardImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUncheckedUpdateManyWithoutRewardImageNestedInput {
    @Field(() => [ImagesCreateWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutRewardImageInput)
    create?: Array<ImagesCreateWithoutRewardImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutRewardImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutRewardImageInput>;
    @Field(() => [ImagesUpsertWithWhereUniqueWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesUpsertWithWhereUniqueWithoutRewardImageInput)
    upsert?: Array<ImagesUpsertWithWhereUniqueWithoutRewardImageInput>;
    @Field(() => ImagesCreateManyRewardImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyRewardImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyRewardImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesUpdateWithWhereUniqueWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesUpdateWithWhereUniqueWithoutRewardImageInput)
    update?: Array<ImagesUpdateWithWhereUniqueWithoutRewardImageInput>;
    @Field(() => [ImagesUpdateManyWithWhereWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesUpdateManyWithWhereWithoutRewardImageInput)
    updateMany?: Array<ImagesUpdateManyWithWhereWithoutRewardImageInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    @Type(() => ImagesScalarWhereInput)
    deleteMany?: Array<ImagesScalarWhereInput>;
}

@InputType()
export class ImagesUncheckedUpdateManyWithoutRewardImageInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    hotelImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    programImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    hotelImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    programImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    rewardImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUncheckedUpdateWithoutHotelImageInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    programImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    rewardImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUncheckedUpdateWithoutProgramImageInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    hotelImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    rewardImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUncheckedUpdateWithoutProjectImageInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    hotelImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    programImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    rewardImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUncheckedUpdateWithoutRewardImageInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    hotelImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    programImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    hotelImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    programImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    rewardImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    projectImageId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUpdateManyMutationInput {
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ImagesUpdateManyWithWhereWithoutHotelImageInput {
    @Field(() => ImagesScalarWhereInput, {nullable:false})
    @Type(() => ImagesScalarWhereInput)
    where!: InstanceType<typeof ImagesScalarWhereInput>;
    @Field(() => ImagesUpdateManyMutationInput, {nullable:false})
    @Type(() => ImagesUpdateManyMutationInput)
    data!: InstanceType<typeof ImagesUpdateManyMutationInput>;
}

@InputType()
export class ImagesUpdateManyWithWhereWithoutProgramImageInput {
    @Field(() => ImagesScalarWhereInput, {nullable:false})
    @Type(() => ImagesScalarWhereInput)
    where!: InstanceType<typeof ImagesScalarWhereInput>;
    @Field(() => ImagesUpdateManyMutationInput, {nullable:false})
    @Type(() => ImagesUpdateManyMutationInput)
    data!: InstanceType<typeof ImagesUpdateManyMutationInput>;
}

@InputType()
export class ImagesUpdateManyWithWhereWithoutProjectImageInput {
    @Field(() => ImagesScalarWhereInput, {nullable:false})
    @Type(() => ImagesScalarWhereInput)
    where!: InstanceType<typeof ImagesScalarWhereInput>;
    @Field(() => ImagesUpdateManyMutationInput, {nullable:false})
    @Type(() => ImagesUpdateManyMutationInput)
    data!: InstanceType<typeof ImagesUpdateManyMutationInput>;
}

@InputType()
export class ImagesUpdateManyWithWhereWithoutRewardImageInput {
    @Field(() => ImagesScalarWhereInput, {nullable:false})
    @Type(() => ImagesScalarWhereInput)
    where!: InstanceType<typeof ImagesScalarWhereInput>;
    @Field(() => ImagesUpdateManyMutationInput, {nullable:false})
    @Type(() => ImagesUpdateManyMutationInput)
    data!: InstanceType<typeof ImagesUpdateManyMutationInput>;
}

@InputType()
export class ImagesUpdateManyWithoutHotelImageNestedInput {
    @Field(() => [ImagesCreateWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutHotelImageInput)
    create?: Array<ImagesCreateWithoutHotelImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutHotelImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutHotelImageInput>;
    @Field(() => [ImagesUpsertWithWhereUniqueWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesUpsertWithWhereUniqueWithoutHotelImageInput)
    upsert?: Array<ImagesUpsertWithWhereUniqueWithoutHotelImageInput>;
    @Field(() => ImagesCreateManyHotelImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyHotelImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyHotelImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesUpdateWithWhereUniqueWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesUpdateWithWhereUniqueWithoutHotelImageInput)
    update?: Array<ImagesUpdateWithWhereUniqueWithoutHotelImageInput>;
    @Field(() => [ImagesUpdateManyWithWhereWithoutHotelImageInput], {nullable:true})
    @Type(() => ImagesUpdateManyWithWhereWithoutHotelImageInput)
    updateMany?: Array<ImagesUpdateManyWithWhereWithoutHotelImageInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    @Type(() => ImagesScalarWhereInput)
    deleteMany?: Array<ImagesScalarWhereInput>;
}

@InputType()
export class ImagesUpdateManyWithoutProgramImageNestedInput {
    @Field(() => [ImagesCreateWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutProgramImageInput)
    create?: Array<ImagesCreateWithoutProgramImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutProgramImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutProgramImageInput>;
    @Field(() => [ImagesUpsertWithWhereUniqueWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesUpsertWithWhereUniqueWithoutProgramImageInput)
    upsert?: Array<ImagesUpsertWithWhereUniqueWithoutProgramImageInput>;
    @Field(() => ImagesCreateManyProgramImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyProgramImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyProgramImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesUpdateWithWhereUniqueWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesUpdateWithWhereUniqueWithoutProgramImageInput)
    update?: Array<ImagesUpdateWithWhereUniqueWithoutProgramImageInput>;
    @Field(() => [ImagesUpdateManyWithWhereWithoutProgramImageInput], {nullable:true})
    @Type(() => ImagesUpdateManyWithWhereWithoutProgramImageInput)
    updateMany?: Array<ImagesUpdateManyWithWhereWithoutProgramImageInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    @Type(() => ImagesScalarWhereInput)
    deleteMany?: Array<ImagesScalarWhereInput>;
}

@InputType()
export class ImagesUpdateManyWithoutProjectImageNestedInput {
    @Field(() => [ImagesCreateWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutProjectImageInput)
    create?: Array<ImagesCreateWithoutProjectImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutProjectImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutProjectImageInput>;
    @Field(() => [ImagesUpsertWithWhereUniqueWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesUpsertWithWhereUniqueWithoutProjectImageInput)
    upsert?: Array<ImagesUpsertWithWhereUniqueWithoutProjectImageInput>;
    @Field(() => ImagesCreateManyProjectImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyProjectImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyProjectImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesUpdateWithWhereUniqueWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesUpdateWithWhereUniqueWithoutProjectImageInput)
    update?: Array<ImagesUpdateWithWhereUniqueWithoutProjectImageInput>;
    @Field(() => [ImagesUpdateManyWithWhereWithoutProjectImageInput], {nullable:true})
    @Type(() => ImagesUpdateManyWithWhereWithoutProjectImageInput)
    updateMany?: Array<ImagesUpdateManyWithWhereWithoutProjectImageInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    @Type(() => ImagesScalarWhereInput)
    deleteMany?: Array<ImagesScalarWhereInput>;
}

@InputType()
export class ImagesUpdateManyWithoutRewardImageNestedInput {
    @Field(() => [ImagesCreateWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesCreateWithoutRewardImageInput)
    create?: Array<ImagesCreateWithoutRewardImageInput>;
    @Field(() => [ImagesCreateOrConnectWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesCreateOrConnectWithoutRewardImageInput)
    connectOrCreate?: Array<ImagesCreateOrConnectWithoutRewardImageInput>;
    @Field(() => [ImagesUpsertWithWhereUniqueWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesUpsertWithWhereUniqueWithoutRewardImageInput)
    upsert?: Array<ImagesUpsertWithWhereUniqueWithoutRewardImageInput>;
    @Field(() => ImagesCreateManyRewardImageInputEnvelope, {nullable:true})
    @Type(() => ImagesCreateManyRewardImageInputEnvelope)
    createMany?: InstanceType<typeof ImagesCreateManyRewardImageInputEnvelope>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesWhereUniqueInput], {nullable:true})
    @Type(() => ImagesWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>>;
    @Field(() => [ImagesUpdateWithWhereUniqueWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesUpdateWithWhereUniqueWithoutRewardImageInput)
    update?: Array<ImagesUpdateWithWhereUniqueWithoutRewardImageInput>;
    @Field(() => [ImagesUpdateManyWithWhereWithoutRewardImageInput], {nullable:true})
    @Type(() => ImagesUpdateManyWithWhereWithoutRewardImageInput)
    updateMany?: Array<ImagesUpdateManyWithWhereWithoutRewardImageInput>;
    @Field(() => [ImagesScalarWhereInput], {nullable:true})
    @Type(() => ImagesScalarWhereInput)
    deleteMany?: Array<ImagesScalarWhereInput>;
}

@InputType()
export class ImagesUpdateWithWhereUniqueWithoutHotelImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesUpdateWithoutHotelImageInput, {nullable:false})
    @Type(() => ImagesUpdateWithoutHotelImageInput)
    data!: InstanceType<typeof ImagesUpdateWithoutHotelImageInput>;
}

@InputType()
export class ImagesUpdateWithWhereUniqueWithoutProgramImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesUpdateWithoutProgramImageInput, {nullable:false})
    @Type(() => ImagesUpdateWithoutProgramImageInput)
    data!: InstanceType<typeof ImagesUpdateWithoutProgramImageInput>;
}

@InputType()
export class ImagesUpdateWithWhereUniqueWithoutProjectImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesUpdateWithoutProjectImageInput, {nullable:false})
    @Type(() => ImagesUpdateWithoutProjectImageInput)
    data!: InstanceType<typeof ImagesUpdateWithoutProjectImageInput>;
}

@InputType()
export class ImagesUpdateWithWhereUniqueWithoutRewardImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesUpdateWithoutRewardImageInput, {nullable:false})
    @Type(() => ImagesUpdateWithoutRewardImageInput)
    data!: InstanceType<typeof ImagesUpdateWithoutRewardImageInput>;
}

@InputType()
export class ImagesUpdateWithoutHotelImageInput {
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ProgramUpdateOneWithoutImagesNestedInput, {nullable:true})
    programImage?: InstanceType<typeof ProgramUpdateOneWithoutImagesNestedInput>;
    @Field(() => RewardUpdateOneWithoutImagesNestedInput, {nullable:true})
    rewardImage?: InstanceType<typeof RewardUpdateOneWithoutImagesNestedInput>;
    @Field(() => ProjectUpdateOneWithoutImagesNestedInput, {nullable:true})
    projectImage?: InstanceType<typeof ProjectUpdateOneWithoutImagesNestedInput>;
}

@InputType()
export class ImagesUpdateWithoutProgramImageInput {
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => HotelUpdateOneWithoutImagesNestedInput, {nullable:true})
    hotelImage?: InstanceType<typeof HotelUpdateOneWithoutImagesNestedInput>;
    @Field(() => RewardUpdateOneWithoutImagesNestedInput, {nullable:true})
    rewardImage?: InstanceType<typeof RewardUpdateOneWithoutImagesNestedInput>;
    @Field(() => ProjectUpdateOneWithoutImagesNestedInput, {nullable:true})
    projectImage?: InstanceType<typeof ProjectUpdateOneWithoutImagesNestedInput>;
}

@InputType()
export class ImagesUpdateWithoutProjectImageInput {
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => HotelUpdateOneWithoutImagesNestedInput, {nullable:true})
    hotelImage?: InstanceType<typeof HotelUpdateOneWithoutImagesNestedInput>;
    @Field(() => ProgramUpdateOneWithoutImagesNestedInput, {nullable:true})
    programImage?: InstanceType<typeof ProgramUpdateOneWithoutImagesNestedInput>;
    @Field(() => RewardUpdateOneWithoutImagesNestedInput, {nullable:true})
    rewardImage?: InstanceType<typeof RewardUpdateOneWithoutImagesNestedInput>;
}

@InputType()
export class ImagesUpdateWithoutRewardImageInput {
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => HotelUpdateOneWithoutImagesNestedInput, {nullable:true})
    hotelImage?: InstanceType<typeof HotelUpdateOneWithoutImagesNestedInput>;
    @Field(() => ProgramUpdateOneWithoutImagesNestedInput, {nullable:true})
    programImage?: InstanceType<typeof ProgramUpdateOneWithoutImagesNestedInput>;
    @Field(() => ProjectUpdateOneWithoutImagesNestedInput, {nullable:true})
    projectImage?: InstanceType<typeof ProjectUpdateOneWithoutImagesNestedInput>;
}

@InputType()
export class ImagesUpdateInput {
    @Field(() => EnumFileTypeFieldUpdateOperationsInput, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    filesize?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    url?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => HotelUpdateOneWithoutImagesNestedInput, {nullable:true})
    hotelImage?: InstanceType<typeof HotelUpdateOneWithoutImagesNestedInput>;
    @Field(() => ProgramUpdateOneWithoutImagesNestedInput, {nullable:true})
    programImage?: InstanceType<typeof ProgramUpdateOneWithoutImagesNestedInput>;
    @Field(() => RewardUpdateOneWithoutImagesNestedInput, {nullable:true})
    rewardImage?: InstanceType<typeof RewardUpdateOneWithoutImagesNestedInput>;
    @Field(() => ProjectUpdateOneWithoutImagesNestedInput, {nullable:true})
    projectImage?: InstanceType<typeof ProjectUpdateOneWithoutImagesNestedInput>;
}

@InputType()
export class ImagesUpsertWithWhereUniqueWithoutHotelImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesUpdateWithoutHotelImageInput, {nullable:false})
    @Type(() => ImagesUpdateWithoutHotelImageInput)
    update!: InstanceType<typeof ImagesUpdateWithoutHotelImageInput>;
    @Field(() => ImagesCreateWithoutHotelImageInput, {nullable:false})
    @Type(() => ImagesCreateWithoutHotelImageInput)
    create!: InstanceType<typeof ImagesCreateWithoutHotelImageInput>;
}

@InputType()
export class ImagesUpsertWithWhereUniqueWithoutProgramImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesUpdateWithoutProgramImageInput, {nullable:false})
    @Type(() => ImagesUpdateWithoutProgramImageInput)
    update!: InstanceType<typeof ImagesUpdateWithoutProgramImageInput>;
    @Field(() => ImagesCreateWithoutProgramImageInput, {nullable:false})
    @Type(() => ImagesCreateWithoutProgramImageInput)
    create!: InstanceType<typeof ImagesCreateWithoutProgramImageInput>;
}

@InputType()
export class ImagesUpsertWithWhereUniqueWithoutProjectImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesUpdateWithoutProjectImageInput, {nullable:false})
    @Type(() => ImagesUpdateWithoutProjectImageInput)
    update!: InstanceType<typeof ImagesUpdateWithoutProjectImageInput>;
    @Field(() => ImagesCreateWithoutProjectImageInput, {nullable:false})
    @Type(() => ImagesCreateWithoutProjectImageInput)
    create!: InstanceType<typeof ImagesCreateWithoutProjectImageInput>;
}

@InputType()
export class ImagesUpsertWithWhereUniqueWithoutRewardImageInput {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesUpdateWithoutRewardImageInput, {nullable:false})
    @Type(() => ImagesUpdateWithoutRewardImageInput)
    update!: InstanceType<typeof ImagesUpdateWithoutRewardImageInput>;
    @Field(() => ImagesCreateWithoutRewardImageInput, {nullable:false})
    @Type(() => ImagesCreateWithoutRewardImageInput)
    create!: InstanceType<typeof ImagesCreateWithoutRewardImageInput>;
}

@InputType()
export class ImagesWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [ImagesWhereInput], {nullable:true})
    AND?: Array<ImagesWhereInput>;
    @Field(() => [ImagesWhereInput], {nullable:true})
    OR?: Array<ImagesWhereInput>;
    @Field(() => [ImagesWhereInput], {nullable:true})
    NOT?: Array<ImagesWhereInput>;
    @Field(() => EnumFileTypeFilter, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    filesize?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    url?: InstanceType<typeof StringFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    hotelImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    programImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    rewardImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    projectImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => HotelNullableRelationFilter, {nullable:true})
    hotelImage?: InstanceType<typeof HotelNullableRelationFilter>;
    @Field(() => ProgramNullableRelationFilter, {nullable:true})
    programImage?: InstanceType<typeof ProgramNullableRelationFilter>;
    @Field(() => RewardNullableRelationFilter, {nullable:true})
    rewardImage?: InstanceType<typeof RewardNullableRelationFilter>;
    @Field(() => ProjectNullableRelationFilter, {nullable:true})
    projectImage?: InstanceType<typeof ProjectNullableRelationFilter>;
}

@InputType()
export class ImagesWhereInput {
    @Field(() => [ImagesWhereInput], {nullable:true})
    AND?: Array<ImagesWhereInput>;
    @Field(() => [ImagesWhereInput], {nullable:true})
    OR?: Array<ImagesWhereInput>;
    @Field(() => [ImagesWhereInput], {nullable:true})
    NOT?: Array<ImagesWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => EnumFileTypeFilter, {nullable:true})
    fileType?: InstanceType<typeof EnumFileTypeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    filesize?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    url?: InstanceType<typeof StringFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    hotelImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    programImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    rewardImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    projectImageId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => HotelNullableRelationFilter, {nullable:true})
    hotelImage?: InstanceType<typeof HotelNullableRelationFilter>;
    @Field(() => ProgramNullableRelationFilter, {nullable:true})
    programImage?: InstanceType<typeof ProgramNullableRelationFilter>;
    @Field(() => RewardNullableRelationFilter, {nullable:true})
    rewardImage?: InstanceType<typeof RewardNullableRelationFilter>;
    @Field(() => ProjectNullableRelationFilter, {nullable:true})
    projectImage?: InstanceType<typeof ProjectNullableRelationFilter>;
}

@ObjectType()
export class Images {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => FileType, {nullable:false})
    fileType!: keyof typeof FileType;
    @Field(() => Float, {nullable:false})
    filesize!: number;
    @Field(() => String, {nullable:false})
    url!: string;
    @Field(() => Int, {nullable:true})
    hotelImageId!: number | null;
    @Field(() => Int, {nullable:true})
    programImageId!: number | null;
    @Field(() => Int, {nullable:true})
    rewardImageId!: number | null;
    @Field(() => Int, {nullable:true})
    projectImageId!: number | null;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Hotel, {nullable:true})
    hotelImage?: InstanceType<typeof Hotel> | null;
    @Field(() => Program, {nullable:true})
    programImage?: InstanceType<typeof Program> | null;
    @Field(() => Reward, {nullable:true})
    rewardImage?: InstanceType<typeof Reward> | null;
    @Field(() => Project, {nullable:true})
    projectImage?: InstanceType<typeof Project> | null;
}

@ArgsType()
export class UpdateManyImagesArgs {
    @Field(() => ImagesUpdateManyMutationInput, {nullable:false})
    @Type(() => ImagesUpdateManyMutationInput)
    data!: InstanceType<typeof ImagesUpdateManyMutationInput>;
    @Field(() => ImagesWhereInput, {nullable:true})
    @Type(() => ImagesWhereInput)
    where?: InstanceType<typeof ImagesWhereInput>;
}

@ArgsType()
export class UpdateOneImagesArgs {
    @Field(() => ImagesUpdateInput, {nullable:false})
    @Type(() => ImagesUpdateInput)
    data!: InstanceType<typeof ImagesUpdateInput>;
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneImagesArgs {
    @Field(() => ImagesWhereUniqueInput, {nullable:false})
    @Type(() => ImagesWhereUniqueInput)
    where!: Prisma.AtLeast<ImagesWhereUniqueInput, 'id'>;
    @Field(() => ImagesCreateInput, {nullable:false})
    @Type(() => ImagesCreateInput)
    create!: InstanceType<typeof ImagesCreateInput>;
    @Field(() => ImagesUpdateInput, {nullable:false})
    @Type(() => ImagesUpdateInput)
    update!: InstanceType<typeof ImagesUpdateInput>;
}

@ObjectType()
export class AggregateInstallment {
    @Field(() => InstallmentCountAggregate, {nullable:true})
    _count?: InstanceType<typeof InstallmentCountAggregate>;
    @Field(() => InstallmentAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof InstallmentAvgAggregate>;
    @Field(() => InstallmentSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof InstallmentSumAggregate>;
    @Field(() => InstallmentMinAggregate, {nullable:true})
    _min?: InstanceType<typeof InstallmentMinAggregate>;
    @Field(() => InstallmentMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof InstallmentMaxAggregate>;
}

@ArgsType()
export class CreateManyInstallmentArgs {
    @Field(() => [InstallmentCreateManyInput], {nullable:false})
    @Type(() => InstallmentCreateManyInput)
    data!: Array<InstallmentCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneInstallmentArgs {
    @Field(() => InstallmentCreateInput, {nullable:false})
    @Type(() => InstallmentCreateInput)
    data!: InstanceType<typeof InstallmentCreateInput>;
}

@ArgsType()
export class DeleteManyInstallmentArgs {
    @Field(() => InstallmentWhereInput, {nullable:true})
    @Type(() => InstallmentWhereInput)
    where?: InstanceType<typeof InstallmentWhereInput>;
}

@ArgsType()
export class DeleteOneInstallmentArgs {
    @Field(() => InstallmentWhereUniqueInput, {nullable:false})
    @Type(() => InstallmentWhereUniqueInput)
    where!: Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstInstallmentOrThrowArgs {
    @Field(() => InstallmentWhereInput, {nullable:true})
    @Type(() => InstallmentWhereInput)
    where?: InstanceType<typeof InstallmentWhereInput>;
    @Field(() => [InstallmentOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<InstallmentOrderByWithRelationInput>;
    @Field(() => InstallmentWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [InstallmentScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof InstallmentScalarFieldEnum>;
}

@ArgsType()
export class FindFirstInstallmentArgs {
    @Field(() => InstallmentWhereInput, {nullable:true})
    @Type(() => InstallmentWhereInput)
    where?: InstanceType<typeof InstallmentWhereInput>;
    @Field(() => [InstallmentOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<InstallmentOrderByWithRelationInput>;
    @Field(() => InstallmentWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [InstallmentScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof InstallmentScalarFieldEnum>;
}

@ArgsType()
export class FindManyInstallmentArgs {
    @Field(() => InstallmentWhereInput, {nullable:true})
    @Type(() => InstallmentWhereInput)
    where?: InstanceType<typeof InstallmentWhereInput>;
    @Field(() => [InstallmentOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<InstallmentOrderByWithRelationInput>;
    @Field(() => InstallmentWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [InstallmentScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof InstallmentScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueInstallmentOrThrowArgs {
    @Field(() => InstallmentWhereUniqueInput, {nullable:false})
    @Type(() => InstallmentWhereUniqueInput)
    where!: Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueInstallmentArgs {
    @Field(() => InstallmentWhereUniqueInput, {nullable:false})
    @Type(() => InstallmentWhereUniqueInput)
    where!: Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>;
}

@ArgsType()
export class InstallmentAggregateArgs {
    @Field(() => InstallmentWhereInput, {nullable:true})
    @Type(() => InstallmentWhereInput)
    where?: InstanceType<typeof InstallmentWhereInput>;
    @Field(() => [InstallmentOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<InstallmentOrderByWithRelationInput>;
    @Field(() => InstallmentWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => InstallmentCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof InstallmentCountAggregateInput>;
    @Field(() => InstallmentAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof InstallmentAvgAggregateInput>;
    @Field(() => InstallmentSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof InstallmentSumAggregateInput>;
    @Field(() => InstallmentMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof InstallmentMinAggregateInput>;
    @Field(() => InstallmentMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof InstallmentMaxAggregateInput>;
}

@InputType()
export class InstallmentAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    number?: true;
    @Field(() => Boolean, {nullable:true})
    lateFee?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    transactionId?: true;
    @Field(() => Boolean, {nullable:true})
    invoiceId?: true;
}

@ObjectType()
export class InstallmentAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    number?: number;
    @Field(() => Float, {nullable:true})
    lateFee?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => Float, {nullable:true})
    transactionId?: number;
    @Field(() => Float, {nullable:true})
    invoiceId?: number;
}

@InputType()
export class InstallmentAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    number?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    lateFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    invoiceId?: keyof typeof SortOrder;
}

@InputType()
export class InstallmentCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    number?: true;
    @Field(() => Boolean, {nullable:true})
    lateFee?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    dueDate?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    transactionId?: true;
    @Field(() => Boolean, {nullable:true})
    invoiceId?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class InstallmentCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    number!: number;
    @Field(() => Int, {nullable:false})
    lateFee!: number;
    @Field(() => Int, {nullable:false})
    amount!: number;
    @Field(() => Int, {nullable:false})
    dueDate!: number;
    @Field(() => Int, {nullable:false})
    status!: number;
    @Field(() => Int, {nullable:false})
    transactionId!: number;
    @Field(() => Int, {nullable:false})
    invoiceId!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class InstallmentCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    number?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    lateFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    dueDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    invoiceId?: keyof typeof SortOrder;
}

@InputType()
export class InstallmentCreateManyInvoiceInputEnvelope {
    @Field(() => [InstallmentCreateManyInvoiceInput], {nullable:false})
    @Type(() => InstallmentCreateManyInvoiceInput)
    data!: Array<InstallmentCreateManyInvoiceInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class InstallmentCreateManyInvoiceInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    number!: number;
    @Field(() => Float, {nullable:false})
    lateFee!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => Date, {nullable:false})
    dueDate!: Date | string;
    @Field(() => InstallmentStatus, {nullable:false})
    status!: keyof typeof InstallmentStatus;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
}

@InputType()
export class InstallmentCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    number!: number;
    @Field(() => Float, {nullable:false})
    lateFee!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => Date, {nullable:false})
    dueDate!: Date | string;
    @Field(() => InstallmentStatus, {nullable:false})
    status!: keyof typeof InstallmentStatus;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => Int, {nullable:false})
    invoiceId!: number;
}

@InputType()
export class InstallmentCreateNestedManyWithoutInvoiceInput {
    @Field(() => [InstallmentCreateWithoutInvoiceInput], {nullable:true})
    @Type(() => InstallmentCreateWithoutInvoiceInput)
    create?: Array<InstallmentCreateWithoutInvoiceInput>;
    @Field(() => [InstallmentCreateOrConnectWithoutInvoiceInput], {nullable:true})
    @Type(() => InstallmentCreateOrConnectWithoutInvoiceInput)
    connectOrCreate?: Array<InstallmentCreateOrConnectWithoutInvoiceInput>;
    @Field(() => InstallmentCreateManyInvoiceInputEnvelope, {nullable:true})
    @Type(() => InstallmentCreateManyInvoiceInputEnvelope)
    createMany?: InstanceType<typeof InstallmentCreateManyInvoiceInputEnvelope>;
    @Field(() => [InstallmentWhereUniqueInput], {nullable:true})
    @Type(() => InstallmentWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>>;
}

@InputType()
export class InstallmentCreateNestedOneWithoutTransactionInput {
    @Field(() => InstallmentCreateWithoutTransactionInput, {nullable:true})
    @Type(() => InstallmentCreateWithoutTransactionInput)
    create?: InstanceType<typeof InstallmentCreateWithoutTransactionInput>;
    @Field(() => InstallmentCreateOrConnectWithoutTransactionInput, {nullable:true})
    @Type(() => InstallmentCreateOrConnectWithoutTransactionInput)
    connectOrCreate?: InstanceType<typeof InstallmentCreateOrConnectWithoutTransactionInput>;
    @Field(() => InstallmentWhereUniqueInput, {nullable:true})
    @Type(() => InstallmentWhereUniqueInput)
    connect?: Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>;
}

@InputType()
export class InstallmentCreateOrConnectWithoutInvoiceInput {
    @Field(() => InstallmentWhereUniqueInput, {nullable:false})
    @Type(() => InstallmentWhereUniqueInput)
    where!: Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>;
    @Field(() => InstallmentCreateWithoutInvoiceInput, {nullable:false})
    @Type(() => InstallmentCreateWithoutInvoiceInput)
    create!: InstanceType<typeof InstallmentCreateWithoutInvoiceInput>;
}

@InputType()
export class InstallmentCreateOrConnectWithoutTransactionInput {
    @Field(() => InstallmentWhereUniqueInput, {nullable:false})
    @Type(() => InstallmentWhereUniqueInput)
    where!: Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>;
    @Field(() => InstallmentCreateWithoutTransactionInput, {nullable:false})
    @Type(() => InstallmentCreateWithoutTransactionInput)
    create!: InstanceType<typeof InstallmentCreateWithoutTransactionInput>;
}

@InputType()
export class InstallmentCreateWithoutInvoiceInput {
    @Field(() => Int, {nullable:false})
    number!: number;
    @Field(() => Float, {nullable:false})
    lateFee!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => Date, {nullable:false})
    dueDate!: Date | string;
    @Field(() => InstallmentStatus, {nullable:false})
    status!: keyof typeof InstallmentStatus;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => TransactionCreateNestedOneWithoutInstallmentInput, {nullable:true})
    transaction?: InstanceType<typeof TransactionCreateNestedOneWithoutInstallmentInput>;
}

@InputType()
export class InstallmentCreateWithoutTransactionInput {
    @Field(() => Int, {nullable:false})
    number!: number;
    @Field(() => Float, {nullable:false})
    lateFee!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => Date, {nullable:false})
    dueDate!: Date | string;
    @Field(() => InstallmentStatus, {nullable:false})
    status!: keyof typeof InstallmentStatus;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => InvoiceCreateNestedOneWithoutInstallmentsInput, {nullable:false})
    invoice!: InstanceType<typeof InvoiceCreateNestedOneWithoutInstallmentsInput>;
}

@InputType()
export class InstallmentCreateInput {
    @Field(() => Int, {nullable:false})
    number!: number;
    @Field(() => Float, {nullable:false})
    lateFee!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => Date, {nullable:false})
    dueDate!: Date | string;
    @Field(() => InstallmentStatus, {nullable:false})
    status!: keyof typeof InstallmentStatus;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => TransactionCreateNestedOneWithoutInstallmentInput, {nullable:true})
    transaction?: InstanceType<typeof TransactionCreateNestedOneWithoutInstallmentInput>;
    @Field(() => InvoiceCreateNestedOneWithoutInstallmentsInput, {nullable:false})
    invoice!: InstanceType<typeof InvoiceCreateNestedOneWithoutInstallmentsInput>;
}

@ArgsType()
export class InstallmentGroupByArgs {
    @Field(() => InstallmentWhereInput, {nullable:true})
    @Type(() => InstallmentWhereInput)
    where?: InstanceType<typeof InstallmentWhereInput>;
    @Field(() => [InstallmentOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<InstallmentOrderByWithAggregationInput>;
    @Field(() => [InstallmentScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof InstallmentScalarFieldEnum>;
    @Field(() => InstallmentScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof InstallmentScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => InstallmentCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof InstallmentCountAggregateInput>;
    @Field(() => InstallmentAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof InstallmentAvgAggregateInput>;
    @Field(() => InstallmentSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof InstallmentSumAggregateInput>;
    @Field(() => InstallmentMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof InstallmentMinAggregateInput>;
    @Field(() => InstallmentMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof InstallmentMaxAggregateInput>;
}

@ObjectType()
export class InstallmentGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    number!: number;
    @Field(() => Float, {nullable:false})
    lateFee!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => Date, {nullable:false})
    dueDate!: Date | string;
    @Field(() => InstallmentStatus, {nullable:false})
    status!: keyof typeof InstallmentStatus;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => Int, {nullable:false})
    invoiceId!: number;
    @Field(() => InstallmentCountAggregate, {nullable:true})
    _count?: InstanceType<typeof InstallmentCountAggregate>;
    @Field(() => InstallmentAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof InstallmentAvgAggregate>;
    @Field(() => InstallmentSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof InstallmentSumAggregate>;
    @Field(() => InstallmentMinAggregate, {nullable:true})
    _min?: InstanceType<typeof InstallmentMinAggregate>;
    @Field(() => InstallmentMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof InstallmentMaxAggregate>;
}

@InputType()
export class InstallmentListRelationFilter {
    @Field(() => InstallmentWhereInput, {nullable:true})
    every?: InstanceType<typeof InstallmentWhereInput>;
    @Field(() => InstallmentWhereInput, {nullable:true})
    some?: InstanceType<typeof InstallmentWhereInput>;
    @Field(() => InstallmentWhereInput, {nullable:true})
    none?: InstanceType<typeof InstallmentWhereInput>;
}

@InputType()
export class InstallmentMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    number?: true;
    @Field(() => Boolean, {nullable:true})
    lateFee?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    dueDate?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    transactionId?: true;
    @Field(() => Boolean, {nullable:true})
    invoiceId?: true;
}

@ObjectType()
export class InstallmentMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    number?: number;
    @Field(() => Float, {nullable:true})
    lateFee?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => InstallmentStatus, {nullable:true})
    status?: keyof typeof InstallmentStatus;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => Int, {nullable:true})
    invoiceId?: number;
}

@InputType()
export class InstallmentMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    number?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    lateFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    dueDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    invoiceId?: keyof typeof SortOrder;
}

@InputType()
export class InstallmentMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    number?: true;
    @Field(() => Boolean, {nullable:true})
    lateFee?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    dueDate?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    transactionId?: true;
    @Field(() => Boolean, {nullable:true})
    invoiceId?: true;
}

@ObjectType()
export class InstallmentMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    number?: number;
    @Field(() => Float, {nullable:true})
    lateFee?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => InstallmentStatus, {nullable:true})
    status?: keyof typeof InstallmentStatus;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => Int, {nullable:true})
    invoiceId?: number;
}

@InputType()
export class InstallmentMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    number?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    lateFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    dueDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    invoiceId?: keyof typeof SortOrder;
}

@InputType()
export class InstallmentNullableRelationFilter {
    @Field(() => InstallmentWhereInput, {nullable:true})
    is?: InstanceType<typeof InstallmentWhereInput>;
    @Field(() => InstallmentWhereInput, {nullable:true})
    isNot?: InstanceType<typeof InstallmentWhereInput>;
}

@InputType()
export class InstallmentOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class InstallmentOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    number?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    lateFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    dueDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    transactionId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    invoiceId?: keyof typeof SortOrder;
    @Field(() => InstallmentCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof InstallmentCountOrderByAggregateInput>;
    @Field(() => InstallmentAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof InstallmentAvgOrderByAggregateInput>;
    @Field(() => InstallmentMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof InstallmentMaxOrderByAggregateInput>;
    @Field(() => InstallmentMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof InstallmentMinOrderByAggregateInput>;
    @Field(() => InstallmentSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof InstallmentSumOrderByAggregateInput>;
}

@InputType()
export class InstallmentOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    number?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    lateFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    dueDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    transactionId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    invoiceId?: keyof typeof SortOrder;
    @Field(() => TransactionOrderByWithRelationInput, {nullable:true})
    transaction?: InstanceType<typeof TransactionOrderByWithRelationInput>;
    @Field(() => InvoiceOrderByWithRelationInput, {nullable:true})
    invoice?: InstanceType<typeof InvoiceOrderByWithRelationInput>;
}

@InputType()
export class InstallmentScalarWhereWithAggregatesInput {
    @Field(() => [InstallmentScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<InstallmentScalarWhereWithAggregatesInput>;
    @Field(() => [InstallmentScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<InstallmentScalarWhereWithAggregatesInput>;
    @Field(() => [InstallmentScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<InstallmentScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    number?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    lateFee?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    amount?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => EnumInstallmentStatusWithAggregatesFilter, {nullable:true})
    status?: InstanceType<typeof EnumInstallmentStatusWithAggregatesFilter>;
    @Field(() => IntNullableWithAggregatesFilter, {nullable:true})
    transactionId?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    invoiceId?: InstanceType<typeof IntWithAggregatesFilter>;
}

@InputType()
export class InstallmentScalarWhereInput {
    @Field(() => [InstallmentScalarWhereInput], {nullable:true})
    AND?: Array<InstallmentScalarWhereInput>;
    @Field(() => [InstallmentScalarWhereInput], {nullable:true})
    OR?: Array<InstallmentScalarWhereInput>;
    @Field(() => [InstallmentScalarWhereInput], {nullable:true})
    NOT?: Array<InstallmentScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    number?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    lateFee?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => EnumInstallmentStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumInstallmentStatusFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    transactionId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntFilter, {nullable:true})
    invoiceId?: InstanceType<typeof IntFilter>;
}

@InputType()
export class InstallmentSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    number?: true;
    @Field(() => Boolean, {nullable:true})
    lateFee?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    transactionId?: true;
    @Field(() => Boolean, {nullable:true})
    invoiceId?: true;
}

@ObjectType()
export class InstallmentSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    number?: number;
    @Field(() => Float, {nullable:true})
    lateFee?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => Int, {nullable:true})
    invoiceId?: number;
}

@InputType()
export class InstallmentSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    number?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    lateFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    invoiceId?: keyof typeof SortOrder;
}

@InputType()
export class InstallmentUncheckedCreateNestedManyWithoutInvoiceInput {
    @Field(() => [InstallmentCreateWithoutInvoiceInput], {nullable:true})
    @Type(() => InstallmentCreateWithoutInvoiceInput)
    create?: Array<InstallmentCreateWithoutInvoiceInput>;
    @Field(() => [InstallmentCreateOrConnectWithoutInvoiceInput], {nullable:true})
    @Type(() => InstallmentCreateOrConnectWithoutInvoiceInput)
    connectOrCreate?: Array<InstallmentCreateOrConnectWithoutInvoiceInput>;
    @Field(() => InstallmentCreateManyInvoiceInputEnvelope, {nullable:true})
    @Type(() => InstallmentCreateManyInvoiceInputEnvelope)
    createMany?: InstanceType<typeof InstallmentCreateManyInvoiceInputEnvelope>;
    @Field(() => [InstallmentWhereUniqueInput], {nullable:true})
    @Type(() => InstallmentWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>>;
}

@InputType()
export class InstallmentUncheckedCreateWithoutInvoiceInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    number!: number;
    @Field(() => Float, {nullable:false})
    lateFee!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => Date, {nullable:false})
    dueDate!: Date | string;
    @Field(() => InstallmentStatus, {nullable:false})
    status!: keyof typeof InstallmentStatus;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => TransactionUncheckedCreateNestedOneWithoutInstallmentInput, {nullable:true})
    transaction?: InstanceType<typeof TransactionUncheckedCreateNestedOneWithoutInstallmentInput>;
}

@InputType()
export class InstallmentUncheckedCreateWithoutTransactionInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    number!: number;
    @Field(() => Float, {nullable:false})
    lateFee!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => Date, {nullable:false})
    dueDate!: Date | string;
    @Field(() => InstallmentStatus, {nullable:false})
    status!: keyof typeof InstallmentStatus;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => Int, {nullable:false})
    invoiceId!: number;
}

@InputType()
export class InstallmentUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    number!: number;
    @Field(() => Float, {nullable:false})
    lateFee!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => Date, {nullable:false})
    dueDate!: Date | string;
    @Field(() => InstallmentStatus, {nullable:false})
    status!: keyof typeof InstallmentStatus;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => Int, {nullable:false})
    invoiceId!: number;
    @Field(() => TransactionUncheckedCreateNestedOneWithoutInstallmentInput, {nullable:true})
    transaction?: InstanceType<typeof TransactionUncheckedCreateNestedOneWithoutInstallmentInput>;
}

@InputType()
export class InstallmentUncheckedUpdateManyWithoutInvoiceNestedInput {
    @Field(() => [InstallmentCreateWithoutInvoiceInput], {nullable:true})
    @Type(() => InstallmentCreateWithoutInvoiceInput)
    create?: Array<InstallmentCreateWithoutInvoiceInput>;
    @Field(() => [InstallmentCreateOrConnectWithoutInvoiceInput], {nullable:true})
    @Type(() => InstallmentCreateOrConnectWithoutInvoiceInput)
    connectOrCreate?: Array<InstallmentCreateOrConnectWithoutInvoiceInput>;
    @Field(() => [InstallmentUpsertWithWhereUniqueWithoutInvoiceInput], {nullable:true})
    @Type(() => InstallmentUpsertWithWhereUniqueWithoutInvoiceInput)
    upsert?: Array<InstallmentUpsertWithWhereUniqueWithoutInvoiceInput>;
    @Field(() => InstallmentCreateManyInvoiceInputEnvelope, {nullable:true})
    @Type(() => InstallmentCreateManyInvoiceInputEnvelope)
    createMany?: InstanceType<typeof InstallmentCreateManyInvoiceInputEnvelope>;
    @Field(() => [InstallmentWhereUniqueInput], {nullable:true})
    @Type(() => InstallmentWhereUniqueInput)
    set?: Array<Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>>;
    @Field(() => [InstallmentWhereUniqueInput], {nullable:true})
    @Type(() => InstallmentWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>>;
    @Field(() => [InstallmentWhereUniqueInput], {nullable:true})
    @Type(() => InstallmentWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>>;
    @Field(() => [InstallmentWhereUniqueInput], {nullable:true})
    @Type(() => InstallmentWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>>;
    @Field(() => [InstallmentUpdateWithWhereUniqueWithoutInvoiceInput], {nullable:true})
    @Type(() => InstallmentUpdateWithWhereUniqueWithoutInvoiceInput)
    update?: Array<InstallmentUpdateWithWhereUniqueWithoutInvoiceInput>;
    @Field(() => [InstallmentUpdateManyWithWhereWithoutInvoiceInput], {nullable:true})
    @Type(() => InstallmentUpdateManyWithWhereWithoutInvoiceInput)
    updateMany?: Array<InstallmentUpdateManyWithWhereWithoutInvoiceInput>;
    @Field(() => [InstallmentScalarWhereInput], {nullable:true})
    @Type(() => InstallmentScalarWhereInput)
    deleteMany?: Array<InstallmentScalarWhereInput>;
}

@InputType()
export class InstallmentUncheckedUpdateManyWithoutInvoiceInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    number?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    lateFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumInstallmentStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumInstallmentStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    transactionId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
}

@InputType()
export class InstallmentUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    number?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    lateFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumInstallmentStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumInstallmentStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    transactionId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    invoiceId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class InstallmentUncheckedUpdateWithoutInvoiceInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    number?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    lateFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumInstallmentStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumInstallmentStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    transactionId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => TransactionUncheckedUpdateOneWithoutInstallmentNestedInput, {nullable:true})
    transaction?: InstanceType<typeof TransactionUncheckedUpdateOneWithoutInstallmentNestedInput>;
}

@InputType()
export class InstallmentUncheckedUpdateWithoutTransactionInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    number?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    lateFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumInstallmentStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumInstallmentStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    transactionId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    invoiceId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class InstallmentUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    number?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    lateFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumInstallmentStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumInstallmentStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    transactionId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    invoiceId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => TransactionUncheckedUpdateOneWithoutInstallmentNestedInput, {nullable:true})
    transaction?: InstanceType<typeof TransactionUncheckedUpdateOneWithoutInstallmentNestedInput>;
}

@InputType()
export class InstallmentUpdateManyMutationInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    number?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    lateFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumInstallmentStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumInstallmentStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    transactionId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
}

@InputType()
export class InstallmentUpdateManyWithWhereWithoutInvoiceInput {
    @Field(() => InstallmentScalarWhereInput, {nullable:false})
    @Type(() => InstallmentScalarWhereInput)
    where!: InstanceType<typeof InstallmentScalarWhereInput>;
    @Field(() => InstallmentUpdateManyMutationInput, {nullable:false})
    @Type(() => InstallmentUpdateManyMutationInput)
    data!: InstanceType<typeof InstallmentUpdateManyMutationInput>;
}

@InputType()
export class InstallmentUpdateManyWithoutInvoiceNestedInput {
    @Field(() => [InstallmentCreateWithoutInvoiceInput], {nullable:true})
    @Type(() => InstallmentCreateWithoutInvoiceInput)
    create?: Array<InstallmentCreateWithoutInvoiceInput>;
    @Field(() => [InstallmentCreateOrConnectWithoutInvoiceInput], {nullable:true})
    @Type(() => InstallmentCreateOrConnectWithoutInvoiceInput)
    connectOrCreate?: Array<InstallmentCreateOrConnectWithoutInvoiceInput>;
    @Field(() => [InstallmentUpsertWithWhereUniqueWithoutInvoiceInput], {nullable:true})
    @Type(() => InstallmentUpsertWithWhereUniqueWithoutInvoiceInput)
    upsert?: Array<InstallmentUpsertWithWhereUniqueWithoutInvoiceInput>;
    @Field(() => InstallmentCreateManyInvoiceInputEnvelope, {nullable:true})
    @Type(() => InstallmentCreateManyInvoiceInputEnvelope)
    createMany?: InstanceType<typeof InstallmentCreateManyInvoiceInputEnvelope>;
    @Field(() => [InstallmentWhereUniqueInput], {nullable:true})
    @Type(() => InstallmentWhereUniqueInput)
    set?: Array<Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>>;
    @Field(() => [InstallmentWhereUniqueInput], {nullable:true})
    @Type(() => InstallmentWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>>;
    @Field(() => [InstallmentWhereUniqueInput], {nullable:true})
    @Type(() => InstallmentWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>>;
    @Field(() => [InstallmentWhereUniqueInput], {nullable:true})
    @Type(() => InstallmentWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>>;
    @Field(() => [InstallmentUpdateWithWhereUniqueWithoutInvoiceInput], {nullable:true})
    @Type(() => InstallmentUpdateWithWhereUniqueWithoutInvoiceInput)
    update?: Array<InstallmentUpdateWithWhereUniqueWithoutInvoiceInput>;
    @Field(() => [InstallmentUpdateManyWithWhereWithoutInvoiceInput], {nullable:true})
    @Type(() => InstallmentUpdateManyWithWhereWithoutInvoiceInput)
    updateMany?: Array<InstallmentUpdateManyWithWhereWithoutInvoiceInput>;
    @Field(() => [InstallmentScalarWhereInput], {nullable:true})
    @Type(() => InstallmentScalarWhereInput)
    deleteMany?: Array<InstallmentScalarWhereInput>;
}

@InputType()
export class InstallmentUpdateOneWithoutTransactionNestedInput {
    @Field(() => InstallmentCreateWithoutTransactionInput, {nullable:true})
    @Type(() => InstallmentCreateWithoutTransactionInput)
    create?: InstanceType<typeof InstallmentCreateWithoutTransactionInput>;
    @Field(() => InstallmentCreateOrConnectWithoutTransactionInput, {nullable:true})
    @Type(() => InstallmentCreateOrConnectWithoutTransactionInput)
    connectOrCreate?: InstanceType<typeof InstallmentCreateOrConnectWithoutTransactionInput>;
    @Field(() => InstallmentUpsertWithoutTransactionInput, {nullable:true})
    @Type(() => InstallmentUpsertWithoutTransactionInput)
    upsert?: InstanceType<typeof InstallmentUpsertWithoutTransactionInput>;
    @Field(() => InstallmentWhereInput, {nullable:true})
    @Type(() => InstallmentWhereInput)
    disconnect?: InstanceType<typeof InstallmentWhereInput>;
    @Field(() => InstallmentWhereInput, {nullable:true})
    @Type(() => InstallmentWhereInput)
    delete?: InstanceType<typeof InstallmentWhereInput>;
    @Field(() => InstallmentWhereUniqueInput, {nullable:true})
    @Type(() => InstallmentWhereUniqueInput)
    connect?: Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>;
    @Field(() => InstallmentUpdateToOneWithWhereWithoutTransactionInput, {nullable:true})
    @Type(() => InstallmentUpdateToOneWithWhereWithoutTransactionInput)
    update?: InstanceType<typeof InstallmentUpdateToOneWithWhereWithoutTransactionInput>;
}

@InputType()
export class InstallmentUpdateToOneWithWhereWithoutTransactionInput {
    @Field(() => InstallmentWhereInput, {nullable:true})
    @Type(() => InstallmentWhereInput)
    where?: InstanceType<typeof InstallmentWhereInput>;
    @Field(() => InstallmentUpdateWithoutTransactionInput, {nullable:false})
    @Type(() => InstallmentUpdateWithoutTransactionInput)
    data!: InstanceType<typeof InstallmentUpdateWithoutTransactionInput>;
}

@InputType()
export class InstallmentUpdateWithWhereUniqueWithoutInvoiceInput {
    @Field(() => InstallmentWhereUniqueInput, {nullable:false})
    @Type(() => InstallmentWhereUniqueInput)
    where!: Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>;
    @Field(() => InstallmentUpdateWithoutInvoiceInput, {nullable:false})
    @Type(() => InstallmentUpdateWithoutInvoiceInput)
    data!: InstanceType<typeof InstallmentUpdateWithoutInvoiceInput>;
}

@InputType()
export class InstallmentUpdateWithoutInvoiceInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    number?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    lateFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumInstallmentStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumInstallmentStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    transactionId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => TransactionUpdateOneWithoutInstallmentNestedInput, {nullable:true})
    transaction?: InstanceType<typeof TransactionUpdateOneWithoutInstallmentNestedInput>;
}

@InputType()
export class InstallmentUpdateWithoutTransactionInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    number?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    lateFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumInstallmentStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumInstallmentStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    transactionId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => InvoiceUpdateOneRequiredWithoutInstallmentsNestedInput, {nullable:true})
    invoice?: InstanceType<typeof InvoiceUpdateOneRequiredWithoutInstallmentsNestedInput>;
}

@InputType()
export class InstallmentUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    number?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    lateFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumInstallmentStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumInstallmentStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    transactionId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => TransactionUpdateOneWithoutInstallmentNestedInput, {nullable:true})
    transaction?: InstanceType<typeof TransactionUpdateOneWithoutInstallmentNestedInput>;
    @Field(() => InvoiceUpdateOneRequiredWithoutInstallmentsNestedInput, {nullable:true})
    invoice?: InstanceType<typeof InvoiceUpdateOneRequiredWithoutInstallmentsNestedInput>;
}

@InputType()
export class InstallmentUpsertWithWhereUniqueWithoutInvoiceInput {
    @Field(() => InstallmentWhereUniqueInput, {nullable:false})
    @Type(() => InstallmentWhereUniqueInput)
    where!: Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>;
    @Field(() => InstallmentUpdateWithoutInvoiceInput, {nullable:false})
    @Type(() => InstallmentUpdateWithoutInvoiceInput)
    update!: InstanceType<typeof InstallmentUpdateWithoutInvoiceInput>;
    @Field(() => InstallmentCreateWithoutInvoiceInput, {nullable:false})
    @Type(() => InstallmentCreateWithoutInvoiceInput)
    create!: InstanceType<typeof InstallmentCreateWithoutInvoiceInput>;
}

@InputType()
export class InstallmentUpsertWithoutTransactionInput {
    @Field(() => InstallmentUpdateWithoutTransactionInput, {nullable:false})
    @Type(() => InstallmentUpdateWithoutTransactionInput)
    update!: InstanceType<typeof InstallmentUpdateWithoutTransactionInput>;
    @Field(() => InstallmentCreateWithoutTransactionInput, {nullable:false})
    @Type(() => InstallmentCreateWithoutTransactionInput)
    create!: InstanceType<typeof InstallmentCreateWithoutTransactionInput>;
    @Field(() => InstallmentWhereInput, {nullable:true})
    @Type(() => InstallmentWhereInput)
    where?: InstanceType<typeof InstallmentWhereInput>;
}

@InputType()
export class InstallmentWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [InstallmentWhereInput], {nullable:true})
    AND?: Array<InstallmentWhereInput>;
    @Field(() => [InstallmentWhereInput], {nullable:true})
    OR?: Array<InstallmentWhereInput>;
    @Field(() => [InstallmentWhereInput], {nullable:true})
    NOT?: Array<InstallmentWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    number?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    lateFee?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => EnumInstallmentStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumInstallmentStatusFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    transactionId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntFilter, {nullable:true})
    invoiceId?: InstanceType<typeof IntFilter>;
    @Field(() => TransactionNullableRelationFilter, {nullable:true})
    transaction?: InstanceType<typeof TransactionNullableRelationFilter>;
    @Field(() => InvoiceRelationFilter, {nullable:true})
    invoice?: InstanceType<typeof InvoiceRelationFilter>;
}

@InputType()
export class InstallmentWhereInput {
    @Field(() => [InstallmentWhereInput], {nullable:true})
    AND?: Array<InstallmentWhereInput>;
    @Field(() => [InstallmentWhereInput], {nullable:true})
    OR?: Array<InstallmentWhereInput>;
    @Field(() => [InstallmentWhereInput], {nullable:true})
    NOT?: Array<InstallmentWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    number?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    lateFee?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => EnumInstallmentStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumInstallmentStatusFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    transactionId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntFilter, {nullable:true})
    invoiceId?: InstanceType<typeof IntFilter>;
    @Field(() => TransactionNullableRelationFilter, {nullable:true})
    transaction?: InstanceType<typeof TransactionNullableRelationFilter>;
    @Field(() => InvoiceRelationFilter, {nullable:true})
    invoice?: InstanceType<typeof InvoiceRelationFilter>;
}

@ObjectType()
export class Installment {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    number!: number;
    @Field(() => Float, {nullable:false})
    lateFee!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => Date, {nullable:false})
    dueDate!: Date;
    @Field(() => InstallmentStatus, {nullable:false})
    status!: keyof typeof InstallmentStatus;
    @Field(() => Int, {nullable:true})
    transactionId!: number | null;
    @Field(() => Int, {nullable:false})
    invoiceId!: number;
    @Field(() => Transaction, {nullable:true})
    transaction?: InstanceType<typeof Transaction> | null;
    @Field(() => Invoice, {nullable:false})
    invoice?: InstanceType<typeof Invoice>;
}

@ArgsType()
export class UpdateManyInstallmentArgs {
    @Field(() => InstallmentUpdateManyMutationInput, {nullable:false})
    @Type(() => InstallmentUpdateManyMutationInput)
    data!: InstanceType<typeof InstallmentUpdateManyMutationInput>;
    @Field(() => InstallmentWhereInput, {nullable:true})
    @Type(() => InstallmentWhereInput)
    where?: InstanceType<typeof InstallmentWhereInput>;
}

@ArgsType()
export class UpdateOneInstallmentArgs {
    @Field(() => InstallmentUpdateInput, {nullable:false})
    @Type(() => InstallmentUpdateInput)
    data!: InstanceType<typeof InstallmentUpdateInput>;
    @Field(() => InstallmentWhereUniqueInput, {nullable:false})
    @Type(() => InstallmentWhereUniqueInput)
    where!: Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneInstallmentArgs {
    @Field(() => InstallmentWhereUniqueInput, {nullable:false})
    @Type(() => InstallmentWhereUniqueInput)
    where!: Prisma.AtLeast<InstallmentWhereUniqueInput, 'id'>;
    @Field(() => InstallmentCreateInput, {nullable:false})
    @Type(() => InstallmentCreateInput)
    create!: InstanceType<typeof InstallmentCreateInput>;
    @Field(() => InstallmentUpdateInput, {nullable:false})
    @Type(() => InstallmentUpdateInput)
    update!: InstanceType<typeof InstallmentUpdateInput>;
}

@ObjectType()
export class AggregateInvoice {
    @Field(() => InvoiceCountAggregate, {nullable:true})
    _count?: InstanceType<typeof InvoiceCountAggregate>;
    @Field(() => InvoiceAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof InvoiceAvgAggregate>;
    @Field(() => InvoiceSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof InvoiceSumAggregate>;
    @Field(() => InvoiceMinAggregate, {nullable:true})
    _min?: InstanceType<typeof InvoiceMinAggregate>;
    @Field(() => InvoiceMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof InvoiceMaxAggregate>;
}

@ArgsType()
export class CreateManyInvoiceArgs {
    @Field(() => [InvoiceCreateManyInput], {nullable:false})
    @Type(() => InvoiceCreateManyInput)
    data!: Array<InvoiceCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneInvoiceArgs {
    @Field(() => InvoiceCreateInput, {nullable:false})
    @Type(() => InvoiceCreateInput)
    data!: InstanceType<typeof InvoiceCreateInput>;
}

@ArgsType()
export class DeleteManyInvoiceArgs {
    @Field(() => InvoiceWhereInput, {nullable:true})
    @Type(() => InvoiceWhereInput)
    where?: InstanceType<typeof InvoiceWhereInput>;
}

@ArgsType()
export class DeleteOneInvoiceArgs {
    @Field(() => InvoiceWhereUniqueInput, {nullable:false})
    @Type(() => InvoiceWhereUniqueInput)
    where!: Prisma.AtLeast<InvoiceWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstInvoiceOrThrowArgs {
    @Field(() => InvoiceWhereInput, {nullable:true})
    @Type(() => InvoiceWhereInput)
    where?: InstanceType<typeof InvoiceWhereInput>;
    @Field(() => [InvoiceOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<InvoiceOrderByWithRelationInput>;
    @Field(() => InvoiceWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<InvoiceWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [InvoiceScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof InvoiceScalarFieldEnum>;
}

@ArgsType()
export class FindFirstInvoiceArgs {
    @Field(() => InvoiceWhereInput, {nullable:true})
    @Type(() => InvoiceWhereInput)
    where?: InstanceType<typeof InvoiceWhereInput>;
    @Field(() => [InvoiceOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<InvoiceOrderByWithRelationInput>;
    @Field(() => InvoiceWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<InvoiceWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [InvoiceScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof InvoiceScalarFieldEnum>;
}

@ArgsType()
export class FindManyInvoiceArgs {
    @Field(() => InvoiceWhereInput, {nullable:true})
    @Type(() => InvoiceWhereInput)
    where?: InstanceType<typeof InvoiceWhereInput>;
    @Field(() => [InvoiceOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<InvoiceOrderByWithRelationInput>;
    @Field(() => InvoiceWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<InvoiceWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [InvoiceScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof InvoiceScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueInvoiceOrThrowArgs {
    @Field(() => InvoiceWhereUniqueInput, {nullable:false})
    @Type(() => InvoiceWhereUniqueInput)
    where!: Prisma.AtLeast<InvoiceWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueInvoiceArgs {
    @Field(() => InvoiceWhereUniqueInput, {nullable:false})
    @Type(() => InvoiceWhereUniqueInput)
    where!: Prisma.AtLeast<InvoiceWhereUniqueInput, 'id'>;
}

@ArgsType()
export class InvoiceAggregateArgs {
    @Field(() => InvoiceWhereInput, {nullable:true})
    @Type(() => InvoiceWhereInput)
    where?: InstanceType<typeof InvoiceWhereInput>;
    @Field(() => [InvoiceOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<InvoiceOrderByWithRelationInput>;
    @Field(() => InvoiceWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<InvoiceWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => InvoiceCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof InvoiceCountAggregateInput>;
    @Field(() => InvoiceAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof InvoiceAvgAggregateInput>;
    @Field(() => InvoiceSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof InvoiceSumAggregateInput>;
    @Field(() => InvoiceMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof InvoiceMinAggregateInput>;
    @Field(() => InvoiceMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof InvoiceMaxAggregateInput>;
}

@InputType()
export class InvoiceAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    adminFee?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @HideField()
    uniqueCode?: true;
}

@ObjectType()
export class InvoiceAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    adminFee?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => Float, {nullable:true})
    uniqueCode?: number;
}

@InputType()
export class InvoiceAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    adminFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @HideField()
    uniqueCode?: keyof typeof SortOrder;
}

@InputType()
export class InvoiceCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    adminFee?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @HideField()
    uniqueCode?: true;
    @HideField()
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class InvoiceCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    adminFee!: number;
    @Field(() => Int, {nullable:false})
    amount!: number;
    @Field(() => Int, {nullable:false})
    uniqueCode!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class InvoiceCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    adminFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @HideField()
    uniqueCode?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
}

@ObjectType()
export class InvoiceCount {
    @Field(() => Int, {nullable:false})
    transactions?: number;
    @Field(() => Int, {nullable:false})
    Installments?: number;
}

@InputType()
export class InvoiceCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    amount!: number;
    @HideField()
    uniqueCode!: number;
    @HideField()
    createdAt?: Date | string;
}

@InputType()
export class InvoiceCreateNestedOneWithoutInstallmentsInput {
    @Field(() => InvoiceCreateWithoutInstallmentsInput, {nullable:true})
    @Type(() => InvoiceCreateWithoutInstallmentsInput)
    create?: InstanceType<typeof InvoiceCreateWithoutInstallmentsInput>;
    @Field(() => InvoiceCreateOrConnectWithoutInstallmentsInput, {nullable:true})
    @Type(() => InvoiceCreateOrConnectWithoutInstallmentsInput)
    connectOrCreate?: InstanceType<typeof InvoiceCreateOrConnectWithoutInstallmentsInput>;
    @Field(() => InvoiceWhereUniqueInput, {nullable:true})
    @Type(() => InvoiceWhereUniqueInput)
    connect?: Prisma.AtLeast<InvoiceWhereUniqueInput, 'id'>;
}

@InputType()
export class InvoiceCreateNestedOneWithoutOrderInput {
    @Field(() => InvoiceCreateWithoutOrderInput, {nullable:true})
    @Type(() => InvoiceCreateWithoutOrderInput)
    create?: InstanceType<typeof InvoiceCreateWithoutOrderInput>;
    @Field(() => InvoiceCreateOrConnectWithoutOrderInput, {nullable:true})
    @Type(() => InvoiceCreateOrConnectWithoutOrderInput)
    connectOrCreate?: InstanceType<typeof InvoiceCreateOrConnectWithoutOrderInput>;
    @Field(() => InvoiceWhereUniqueInput, {nullable:true})
    @Type(() => InvoiceWhereUniqueInput)
    connect?: Prisma.AtLeast<InvoiceWhereUniqueInput, 'id'>;
}

@InputType()
export class InvoiceCreateNestedOneWithoutTransactionsInput {
    @Field(() => InvoiceCreateWithoutTransactionsInput, {nullable:true})
    @Type(() => InvoiceCreateWithoutTransactionsInput)
    create?: InstanceType<typeof InvoiceCreateWithoutTransactionsInput>;
    @Field(() => InvoiceCreateOrConnectWithoutTransactionsInput, {nullable:true})
    @Type(() => InvoiceCreateOrConnectWithoutTransactionsInput)
    connectOrCreate?: InstanceType<typeof InvoiceCreateOrConnectWithoutTransactionsInput>;
    @Field(() => InvoiceWhereUniqueInput, {nullable:true})
    @Type(() => InvoiceWhereUniqueInput)
    connect?: Prisma.AtLeast<InvoiceWhereUniqueInput, 'id'>;
}

@InputType()
export class InvoiceCreateOrConnectWithoutInstallmentsInput {
    @Field(() => InvoiceWhereUniqueInput, {nullable:false})
    @Type(() => InvoiceWhereUniqueInput)
    where!: Prisma.AtLeast<InvoiceWhereUniqueInput, 'id'>;
    @Field(() => InvoiceCreateWithoutInstallmentsInput, {nullable:false})
    @Type(() => InvoiceCreateWithoutInstallmentsInput)
    create!: InstanceType<typeof InvoiceCreateWithoutInstallmentsInput>;
}

@InputType()
export class InvoiceCreateOrConnectWithoutOrderInput {
    @Field(() => InvoiceWhereUniqueInput, {nullable:false})
    @Type(() => InvoiceWhereUniqueInput)
    where!: Prisma.AtLeast<InvoiceWhereUniqueInput, 'id'>;
    @Field(() => InvoiceCreateWithoutOrderInput, {nullable:false})
    @Type(() => InvoiceCreateWithoutOrderInput)
    create!: InstanceType<typeof InvoiceCreateWithoutOrderInput>;
}

@InputType()
export class InvoiceCreateOrConnectWithoutTransactionsInput {
    @Field(() => InvoiceWhereUniqueInput, {nullable:false})
    @Type(() => InvoiceWhereUniqueInput)
    where!: Prisma.AtLeast<InvoiceWhereUniqueInput, 'id'>;
    @Field(() => InvoiceCreateWithoutTransactionsInput, {nullable:false})
    @Type(() => InvoiceCreateWithoutTransactionsInput)
    create!: InstanceType<typeof InvoiceCreateWithoutTransactionsInput>;
}

@InputType()
export class InvoiceCreateWithoutInstallmentsInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    amount!: number;
    @HideField()
    uniqueCode!: number;
    @HideField()
    createdAt?: Date | string;
    @Field(() => OrderCreateNestedOneWithoutInvoiceInput, {nullable:true})
    Order?: InstanceType<typeof OrderCreateNestedOneWithoutInvoiceInput>;
    @Field(() => TransactionCreateNestedManyWithoutInvoiceInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutInvoiceInput>;
}

@InputType()
export class InvoiceCreateWithoutOrderInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    amount!: number;
    @HideField()
    uniqueCode!: number;
    @HideField()
    createdAt?: Date | string;
    @Field(() => TransactionCreateNestedManyWithoutInvoiceInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutInvoiceInput>;
    @Field(() => InstallmentCreateNestedManyWithoutInvoiceInput, {nullable:true})
    Installments?: InstanceType<typeof InstallmentCreateNestedManyWithoutInvoiceInput>;
}

@InputType()
export class InvoiceCreateWithoutTransactionsInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    amount!: number;
    @HideField()
    uniqueCode!: number;
    @HideField()
    createdAt?: Date | string;
    @Field(() => OrderCreateNestedOneWithoutInvoiceInput, {nullable:true})
    Order?: InstanceType<typeof OrderCreateNestedOneWithoutInvoiceInput>;
    @Field(() => InstallmentCreateNestedManyWithoutInvoiceInput, {nullable:true})
    Installments?: InstanceType<typeof InstallmentCreateNestedManyWithoutInvoiceInput>;
}

@InputType()
export class InvoiceCreateInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    amount!: number;
    @HideField()
    uniqueCode!: number;
    @HideField()
    createdAt?: Date | string;
    @Field(() => OrderCreateNestedOneWithoutInvoiceInput, {nullable:true})
    Order?: InstanceType<typeof OrderCreateNestedOneWithoutInvoiceInput>;
    @Field(() => TransactionCreateNestedManyWithoutInvoiceInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionCreateNestedManyWithoutInvoiceInput>;
    @Field(() => InstallmentCreateNestedManyWithoutInvoiceInput, {nullable:true})
    Installments?: InstanceType<typeof InstallmentCreateNestedManyWithoutInvoiceInput>;
}

@ArgsType()
export class InvoiceGroupByArgs {
    @Field(() => InvoiceWhereInput, {nullable:true})
    @Type(() => InvoiceWhereInput)
    where?: InstanceType<typeof InvoiceWhereInput>;
    @Field(() => [InvoiceOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<InvoiceOrderByWithAggregationInput>;
    @Field(() => [InvoiceScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof InvoiceScalarFieldEnum>;
    @Field(() => InvoiceScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof InvoiceScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => InvoiceCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof InvoiceCountAggregateInput>;
    @Field(() => InvoiceAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof InvoiceAvgAggregateInput>;
    @Field(() => InvoiceSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof InvoiceSumAggregateInput>;
    @Field(() => InvoiceMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof InvoiceMinAggregateInput>;
    @Field(() => InvoiceMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof InvoiceMaxAggregateInput>;
}

@ObjectType()
export class InvoiceGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Float, {nullable:false})
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => Int, {nullable:false})
    uniqueCode!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => InvoiceCountAggregate, {nullable:true})
    _count?: InstanceType<typeof InvoiceCountAggregate>;
    @Field(() => InvoiceAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof InvoiceAvgAggregate>;
    @Field(() => InvoiceSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof InvoiceSumAggregate>;
    @Field(() => InvoiceMinAggregate, {nullable:true})
    _min?: InstanceType<typeof InvoiceMinAggregate>;
    @Field(() => InvoiceMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof InvoiceMaxAggregate>;
}

@InputType()
export class InvoiceMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    adminFee?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @HideField()
    uniqueCode?: true;
    @HideField()
    createdAt?: true;
}

@ObjectType()
export class InvoiceMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    adminFee?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => Int, {nullable:true})
    uniqueCode?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class InvoiceMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    adminFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @HideField()
    uniqueCode?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class InvoiceMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    adminFee?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @HideField()
    uniqueCode?: true;
    @HideField()
    createdAt?: true;
}

@ObjectType()
export class InvoiceMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    adminFee?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => Int, {nullable:true})
    uniqueCode?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class InvoiceMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    adminFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @HideField()
    uniqueCode?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class InvoiceNullableRelationFilter {
    @Field(() => InvoiceWhereInput, {nullable:true})
    is?: InstanceType<typeof InvoiceWhereInput>;
    @Field(() => InvoiceWhereInput, {nullable:true})
    isNot?: InstanceType<typeof InvoiceWhereInput>;
}

@InputType()
export class InvoiceOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    adminFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @HideField()
    uniqueCode?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @Field(() => InvoiceCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof InvoiceCountOrderByAggregateInput>;
    @Field(() => InvoiceAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof InvoiceAvgOrderByAggregateInput>;
    @Field(() => InvoiceMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof InvoiceMaxOrderByAggregateInput>;
    @Field(() => InvoiceMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof InvoiceMinOrderByAggregateInput>;
    @Field(() => InvoiceSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof InvoiceSumOrderByAggregateInput>;
}

@InputType()
export class InvoiceOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    adminFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @HideField()
    uniqueCode?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @Field(() => OrderOrderByWithRelationInput, {nullable:true})
    Order?: InstanceType<typeof OrderOrderByWithRelationInput>;
    @Field(() => TransactionOrderByRelationAggregateInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionOrderByRelationAggregateInput>;
    @Field(() => InstallmentOrderByRelationAggregateInput, {nullable:true})
    Installments?: InstanceType<typeof InstallmentOrderByRelationAggregateInput>;
}

@InputType()
export class InvoiceRelationFilter {
    @Field(() => InvoiceWhereInput, {nullable:true})
    is?: InstanceType<typeof InvoiceWhereInput>;
    @Field(() => InvoiceWhereInput, {nullable:true})
    isNot?: InstanceType<typeof InvoiceWhereInput>;
}

@InputType()
export class InvoiceScalarWhereWithAggregatesInput {
    @Field(() => [InvoiceScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<InvoiceScalarWhereWithAggregatesInput>;
    @Field(() => [InvoiceScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<InvoiceScalarWhereWithAggregatesInput>;
    @Field(() => [InvoiceScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<InvoiceScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    adminFee?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    amount?: InstanceType<typeof FloatWithAggregatesFilter>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntWithAggregatesFilter>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class InvoiceSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    adminFee?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @HideField()
    uniqueCode?: true;
}

@ObjectType()
export class InvoiceSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    adminFee?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => Int, {nullable:true})
    uniqueCode?: number;
}

@InputType()
export class InvoiceSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    adminFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @HideField()
    uniqueCode?: keyof typeof SortOrder;
}

@InputType()
export class InvoiceUncheckedCreateWithoutInstallmentsInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    amount!: number;
    @HideField()
    uniqueCode!: number;
    @HideField()
    createdAt?: Date | string;
    @Field(() => OrderUncheckedCreateNestedOneWithoutInvoiceInput, {nullable:true})
    Order?: InstanceType<typeof OrderUncheckedCreateNestedOneWithoutInvoiceInput>;
    @Field(() => TransactionUncheckedCreateNestedManyWithoutInvoiceInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutInvoiceInput>;
}

@InputType()
export class InvoiceUncheckedCreateWithoutOrderInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    amount!: number;
    @HideField()
    uniqueCode!: number;
    @HideField()
    createdAt?: Date | string;
    @Field(() => TransactionUncheckedCreateNestedManyWithoutInvoiceInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutInvoiceInput>;
    @Field(() => InstallmentUncheckedCreateNestedManyWithoutInvoiceInput, {nullable:true})
    Installments?: InstanceType<typeof InstallmentUncheckedCreateNestedManyWithoutInvoiceInput>;
}

@InputType()
export class InvoiceUncheckedCreateWithoutTransactionsInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    amount!: number;
    @HideField()
    uniqueCode!: number;
    @HideField()
    createdAt?: Date | string;
    @Field(() => OrderUncheckedCreateNestedOneWithoutInvoiceInput, {nullable:true})
    Order?: InstanceType<typeof OrderUncheckedCreateNestedOneWithoutInvoiceInput>;
    @Field(() => InstallmentUncheckedCreateNestedManyWithoutInvoiceInput, {nullable:true})
    Installments?: InstanceType<typeof InstallmentUncheckedCreateNestedManyWithoutInvoiceInput>;
}

@InputType()
export class InvoiceUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    amount!: number;
    @HideField()
    uniqueCode!: number;
    @HideField()
    createdAt?: Date | string;
    @Field(() => OrderUncheckedCreateNestedOneWithoutInvoiceInput, {nullable:true})
    Order?: InstanceType<typeof OrderUncheckedCreateNestedOneWithoutInvoiceInput>;
    @Field(() => TransactionUncheckedCreateNestedManyWithoutInvoiceInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionUncheckedCreateNestedManyWithoutInvoiceInput>;
    @Field(() => InstallmentUncheckedCreateNestedManyWithoutInvoiceInput, {nullable:true})
    Installments?: InstanceType<typeof InstallmentUncheckedCreateNestedManyWithoutInvoiceInput>;
}

@InputType()
export class InvoiceUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class InvoiceUncheckedUpdateWithoutInstallmentsInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => OrderUncheckedUpdateOneWithoutInvoiceNestedInput, {nullable:true})
    Order?: InstanceType<typeof OrderUncheckedUpdateOneWithoutInvoiceNestedInput>;
    @Field(() => TransactionUncheckedUpdateManyWithoutInvoiceNestedInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutInvoiceNestedInput>;
}

@InputType()
export class InvoiceUncheckedUpdateWithoutOrderInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => TransactionUncheckedUpdateManyWithoutInvoiceNestedInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutInvoiceNestedInput>;
    @Field(() => InstallmentUncheckedUpdateManyWithoutInvoiceNestedInput, {nullable:true})
    Installments?: InstanceType<typeof InstallmentUncheckedUpdateManyWithoutInvoiceNestedInput>;
}

@InputType()
export class InvoiceUncheckedUpdateWithoutTransactionsInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => OrderUncheckedUpdateOneWithoutInvoiceNestedInput, {nullable:true})
    Order?: InstanceType<typeof OrderUncheckedUpdateOneWithoutInvoiceNestedInput>;
    @Field(() => InstallmentUncheckedUpdateManyWithoutInvoiceNestedInput, {nullable:true})
    Installments?: InstanceType<typeof InstallmentUncheckedUpdateManyWithoutInvoiceNestedInput>;
}

@InputType()
export class InvoiceUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => OrderUncheckedUpdateOneWithoutInvoiceNestedInput, {nullable:true})
    Order?: InstanceType<typeof OrderUncheckedUpdateOneWithoutInvoiceNestedInput>;
    @Field(() => TransactionUncheckedUpdateManyWithoutInvoiceNestedInput, {nullable:true})
    transactions?: InstanceType<typeof TransactionUncheckedUpdateManyWithoutInvoiceNestedInput>;
    @Field(() => InstallmentUncheckedUpdateManyWithoutInvoiceNestedInput, {nullable:true})
    Installments?: InstanceType<typeof InstallmentUncheckedUpdateManyWithoutInvoiceNestedInput>;
}

@InputType()
export class InvoiceUpdateManyMutationInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class InvoiceUpdateOneRequiredWithoutInstallmentsNestedInput {
    @Field(() => InvoiceCreateWithoutInstallmentsInput, {nullable:true})
    @Type(() => InvoiceCreateWithoutInstallmentsInput)
    create?: InstanceType<typeof InvoiceCreateWithoutInstallmentsInput>;
    @Field(() => InvoiceCreateOrConnectWithoutInstallmentsInput, {nullable:true})
    @Type(() => InvoiceCreateOrConnectWithoutInstallmentsInput)
    connectOrCreate?: InstanceType<typeof InvoiceCreateOrConnectWithoutInstallmentsInput>;
    @Field(() => InvoiceUpsertWithoutInstallmentsInput, {nullable:true})
    @Type(() => InvoiceUpsertWithoutInstallmentsInput)
    upsert?: InstanceType<typeof InvoiceUpsertWithoutInstallmentsInput>;
    @Field(() => InvoiceWhereUniqueInput, {nullable:true})
    @Type(() => InvoiceWhereUniqueInput)
    connect?: Prisma.AtLeast<InvoiceWhereUniqueInput, 'id'>;
    @Field(() => InvoiceUpdateToOneWithWhereWithoutInstallmentsInput, {nullable:true})
    @Type(() => InvoiceUpdateToOneWithWhereWithoutInstallmentsInput)
    update?: InstanceType<typeof InvoiceUpdateToOneWithWhereWithoutInstallmentsInput>;
}

@InputType()
export class InvoiceUpdateOneRequiredWithoutOrderNestedInput {
    @Field(() => InvoiceCreateWithoutOrderInput, {nullable:true})
    @Type(() => InvoiceCreateWithoutOrderInput)
    create?: InstanceType<typeof InvoiceCreateWithoutOrderInput>;
    @Field(() => InvoiceCreateOrConnectWithoutOrderInput, {nullable:true})
    @Type(() => InvoiceCreateOrConnectWithoutOrderInput)
    connectOrCreate?: InstanceType<typeof InvoiceCreateOrConnectWithoutOrderInput>;
    @Field(() => InvoiceUpsertWithoutOrderInput, {nullable:true})
    @Type(() => InvoiceUpsertWithoutOrderInput)
    upsert?: InstanceType<typeof InvoiceUpsertWithoutOrderInput>;
    @Field(() => InvoiceWhereUniqueInput, {nullable:true})
    @Type(() => InvoiceWhereUniqueInput)
    connect?: Prisma.AtLeast<InvoiceWhereUniqueInput, 'id'>;
    @Field(() => InvoiceUpdateToOneWithWhereWithoutOrderInput, {nullable:true})
    @Type(() => InvoiceUpdateToOneWithWhereWithoutOrderInput)
    update?: InstanceType<typeof InvoiceUpdateToOneWithWhereWithoutOrderInput>;
}

@InputType()
export class InvoiceUpdateOneWithoutTransactionsNestedInput {
    @Field(() => InvoiceCreateWithoutTransactionsInput, {nullable:true})
    @Type(() => InvoiceCreateWithoutTransactionsInput)
    create?: InstanceType<typeof InvoiceCreateWithoutTransactionsInput>;
    @Field(() => InvoiceCreateOrConnectWithoutTransactionsInput, {nullable:true})
    @Type(() => InvoiceCreateOrConnectWithoutTransactionsInput)
    connectOrCreate?: InstanceType<typeof InvoiceCreateOrConnectWithoutTransactionsInput>;
    @Field(() => InvoiceUpsertWithoutTransactionsInput, {nullable:true})
    @Type(() => InvoiceUpsertWithoutTransactionsInput)
    upsert?: InstanceType<typeof InvoiceUpsertWithoutTransactionsInput>;
    @Field(() => InvoiceWhereInput, {nullable:true})
    @Type(() => InvoiceWhereInput)
    disconnect?: InstanceType<typeof InvoiceWhereInput>;
    @Field(() => InvoiceWhereInput, {nullable:true})
    @Type(() => InvoiceWhereInput)
    delete?: InstanceType<typeof InvoiceWhereInput>;
    @Field(() => InvoiceWhereUniqueInput, {nullable:true})
    @Type(() => InvoiceWhereUniqueInput)
    connect?: Prisma.AtLeast<InvoiceWhereUniqueInput, 'id'>;
    @Field(() => InvoiceUpdateToOneWithWhereWithoutTransactionsInput, {nullable:true})
    @Type(() => InvoiceUpdateToOneWithWhereWithoutTransactionsInput)
    update?: InstanceType<typeof InvoiceUpdateToOneWithWhereWithoutTransactionsInput>;
}

@InputType()
export class InvoiceUpdateToOneWithWhereWithoutInstallmentsInput {
    @Field(() => InvoiceWhereInput, {nullable:true})
    @Type(() => InvoiceWhereInput)
    where?: InstanceType<typeof InvoiceWhereInput>;
    @Field(() => InvoiceUpdateWithoutInstallmentsInput, {nullable:false})
    @Type(() => InvoiceUpdateWithoutInstallmentsInput)
    data!: InstanceType<typeof InvoiceUpdateWithoutInstallmentsInput>;
}

@InputType()
export class InvoiceUpdateToOneWithWhereWithoutOrderInput {
    @Field(() => InvoiceWhereInput, {nullable:true})
    @Type(() => InvoiceWhereInput)
    where?: InstanceType<typeof InvoiceWhereInput>;
    @Field(() => InvoiceUpdateWithoutOrderInput, {nullable:false})
    @Type(() => InvoiceUpdateWithoutOrderInput)
    data!: InstanceType<typeof InvoiceUpdateWithoutOrderInput>;
}

@InputType()
export class InvoiceUpdateToOneWithWhereWithoutTransactionsInput {
    @Field(() => InvoiceWhereInput, {nullable:true})
    @Type(() => InvoiceWhereInput)
    where?: InstanceType<typeof InvoiceWhereInput>;
    @Field(() => InvoiceUpdateWithoutTransactionsInput, {nullable:false})
    @Type(() => InvoiceUpdateWithoutTransactionsInput)
    data!: InstanceType<typeof InvoiceUpdateWithoutTransactionsInput>;
}

@InputType()
export class InvoiceUpdateWithoutInstallmentsInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    Order?: InstanceType<typeof OrderUpdateOneWithoutInvoiceNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutInvoiceNestedInput>;
}

@InputType()
export class InvoiceUpdateWithoutOrderInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutInvoiceNestedInput>;
    @HideField()
    Installments?: InstanceType<typeof InstallmentUpdateManyWithoutInvoiceNestedInput>;
}

@InputType()
export class InvoiceUpdateWithoutTransactionsInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    Order?: InstanceType<typeof OrderUpdateOneWithoutInvoiceNestedInput>;
    @HideField()
    Installments?: InstanceType<typeof InstallmentUpdateManyWithoutInvoiceNestedInput>;
}

@InputType()
export class InvoiceUpdateInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    adminFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    Order?: InstanceType<typeof OrderUpdateOneWithoutInvoiceNestedInput>;
    @HideField()
    transactions?: InstanceType<typeof TransactionUpdateManyWithoutInvoiceNestedInput>;
    @HideField()
    Installments?: InstanceType<typeof InstallmentUpdateManyWithoutInvoiceNestedInput>;
}

@InputType()
export class InvoiceUpsertWithoutInstallmentsInput {
    @Field(() => InvoiceUpdateWithoutInstallmentsInput, {nullable:false})
    @Type(() => InvoiceUpdateWithoutInstallmentsInput)
    update!: InstanceType<typeof InvoiceUpdateWithoutInstallmentsInput>;
    @Field(() => InvoiceCreateWithoutInstallmentsInput, {nullable:false})
    @Type(() => InvoiceCreateWithoutInstallmentsInput)
    create!: InstanceType<typeof InvoiceCreateWithoutInstallmentsInput>;
    @Field(() => InvoiceWhereInput, {nullable:true})
    @Type(() => InvoiceWhereInput)
    where?: InstanceType<typeof InvoiceWhereInput>;
}

@InputType()
export class InvoiceUpsertWithoutOrderInput {
    @Field(() => InvoiceUpdateWithoutOrderInput, {nullable:false})
    @Type(() => InvoiceUpdateWithoutOrderInput)
    update!: InstanceType<typeof InvoiceUpdateWithoutOrderInput>;
    @Field(() => InvoiceCreateWithoutOrderInput, {nullable:false})
    @Type(() => InvoiceCreateWithoutOrderInput)
    create!: InstanceType<typeof InvoiceCreateWithoutOrderInput>;
    @Field(() => InvoiceWhereInput, {nullable:true})
    @Type(() => InvoiceWhereInput)
    where?: InstanceType<typeof InvoiceWhereInput>;
}

@InputType()
export class InvoiceUpsertWithoutTransactionsInput {
    @Field(() => InvoiceUpdateWithoutTransactionsInput, {nullable:false})
    @Type(() => InvoiceUpdateWithoutTransactionsInput)
    update!: InstanceType<typeof InvoiceUpdateWithoutTransactionsInput>;
    @Field(() => InvoiceCreateWithoutTransactionsInput, {nullable:false})
    @Type(() => InvoiceCreateWithoutTransactionsInput)
    create!: InstanceType<typeof InvoiceCreateWithoutTransactionsInput>;
    @Field(() => InvoiceWhereInput, {nullable:true})
    @Type(() => InvoiceWhereInput)
    where?: InstanceType<typeof InvoiceWhereInput>;
}

@InputType()
export class InvoiceWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [InvoiceWhereInput], {nullable:true})
    AND?: Array<InvoiceWhereInput>;
    @Field(() => [InvoiceWhereInput], {nullable:true})
    OR?: Array<InvoiceWhereInput>;
    @Field(() => [InvoiceWhereInput], {nullable:true})
    NOT?: Array<InvoiceWhereInput>;
    @Field(() => FloatFilter, {nullable:true})
    adminFee?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntFilter>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => OrderNullableRelationFilter, {nullable:true})
    Order?: InstanceType<typeof OrderNullableRelationFilter>;
    @Field(() => TransactionListRelationFilter, {nullable:true})
    transactions?: InstanceType<typeof TransactionListRelationFilter>;
    @Field(() => InstallmentListRelationFilter, {nullable:true})
    Installments?: InstanceType<typeof InstallmentListRelationFilter>;
}

@InputType()
export class InvoiceWhereInput {
    @Field(() => [InvoiceWhereInput], {nullable:true})
    AND?: Array<InvoiceWhereInput>;
    @Field(() => [InvoiceWhereInput], {nullable:true})
    OR?: Array<InvoiceWhereInput>;
    @Field(() => [InvoiceWhereInput], {nullable:true})
    NOT?: Array<InvoiceWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    adminFee?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntFilter>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => OrderNullableRelationFilter, {nullable:true})
    Order?: InstanceType<typeof OrderNullableRelationFilter>;
    @Field(() => TransactionListRelationFilter, {nullable:true})
    transactions?: InstanceType<typeof TransactionListRelationFilter>;
    @Field(() => InstallmentListRelationFilter, {nullable:true})
    Installments?: InstanceType<typeof InstallmentListRelationFilter>;
}

@ObjectType()
export class Invoice {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Float, {nullable:false})
    adminFee!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => Int, {nullable:false})
    uniqueCode!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Order, {nullable:true})
    Order?: InstanceType<typeof Order> | null;
    @Field(() => [Transaction], {nullable:true})
    transactions?: Array<Transaction>;
    @Field(() => [Installment], {nullable:true})
    Installments?: Array<Installment>;
    @Field(() => InvoiceCount, {nullable:false})
    _count?: InstanceType<typeof InvoiceCount>;
}

@ArgsType()
export class UpdateManyInvoiceArgs {
    @Field(() => InvoiceUpdateManyMutationInput, {nullable:false})
    @Type(() => InvoiceUpdateManyMutationInput)
    data!: InstanceType<typeof InvoiceUpdateManyMutationInput>;
    @Field(() => InvoiceWhereInput, {nullable:true})
    @Type(() => InvoiceWhereInput)
    where?: InstanceType<typeof InvoiceWhereInput>;
}

@ArgsType()
export class UpdateOneInvoiceArgs {
    @Field(() => InvoiceUpdateInput, {nullable:false})
    @Type(() => InvoiceUpdateInput)
    data!: InstanceType<typeof InvoiceUpdateInput>;
    @Field(() => InvoiceWhereUniqueInput, {nullable:false})
    @Type(() => InvoiceWhereUniqueInput)
    where!: Prisma.AtLeast<InvoiceWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneInvoiceArgs {
    @Field(() => InvoiceWhereUniqueInput, {nullable:false})
    @Type(() => InvoiceWhereUniqueInput)
    where!: Prisma.AtLeast<InvoiceWhereUniqueInput, 'id'>;
    @Field(() => InvoiceCreateInput, {nullable:false})
    @Type(() => InvoiceCreateInput)
    create!: InstanceType<typeof InvoiceCreateInput>;
    @Field(() => InvoiceUpdateInput, {nullable:false})
    @Type(() => InvoiceUpdateInput)
    update!: InstanceType<typeof InvoiceUpdateInput>;
}

@ObjectType()
export class AggregateItem {
    @Field(() => ItemCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ItemCountAggregate>;
    @Field(() => ItemAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ItemAvgAggregate>;
    @Field(() => ItemSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ItemSumAggregate>;
    @Field(() => ItemMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ItemMinAggregate>;
    @Field(() => ItemMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ItemMaxAggregate>;
}

@ArgsType()
export class CreateManyItemArgs {
    @Field(() => [ItemCreateManyInput], {nullable:false})
    @Type(() => ItemCreateManyInput)
    data!: Array<ItemCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneItemArgs {
    @Field(() => ItemCreateInput, {nullable:false})
    @Type(() => ItemCreateInput)
    data!: InstanceType<typeof ItemCreateInput>;
}

@ArgsType()
export class DeleteManyItemArgs {
    @Field(() => ItemWhereInput, {nullable:true})
    @Type(() => ItemWhereInput)
    where?: InstanceType<typeof ItemWhereInput>;
}

@ArgsType()
export class DeleteOneItemArgs {
    @Field(() => ItemWhereUniqueInput, {nullable:false})
    @Type(() => ItemWhereUniqueInput)
    where!: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstItemOrThrowArgs {
    @Field(() => ItemWhereInput, {nullable:true})
    @Type(() => ItemWhereInput)
    where?: InstanceType<typeof ItemWhereInput>;
    @Field(() => [ItemOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ItemOrderByWithRelationInput>;
    @Field(() => ItemWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ItemScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ItemScalarFieldEnum>;
}

@ArgsType()
export class FindFirstItemArgs {
    @Field(() => ItemWhereInput, {nullable:true})
    @Type(() => ItemWhereInput)
    where?: InstanceType<typeof ItemWhereInput>;
    @Field(() => [ItemOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ItemOrderByWithRelationInput>;
    @Field(() => ItemWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ItemScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ItemScalarFieldEnum>;
}

@ArgsType()
export class FindManyItemArgs {
    @Field(() => ItemWhereInput, {nullable:true})
    @Type(() => ItemWhereInput)
    where?: InstanceType<typeof ItemWhereInput>;
    @Field(() => [ItemOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ItemOrderByWithRelationInput>;
    @Field(() => ItemWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ItemScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ItemScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueItemOrThrowArgs {
    @Field(() => ItemWhereUniqueInput, {nullable:false})
    @Type(() => ItemWhereUniqueInput)
    where!: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueItemArgs {
    @Field(() => ItemWhereUniqueInput, {nullable:false})
    @Type(() => ItemWhereUniqueInput)
    where!: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
}

@ArgsType()
export class ItemAggregateArgs {
    @Field(() => ItemWhereInput, {nullable:true})
    @Type(() => ItemWhereInput)
    where?: InstanceType<typeof ItemWhereInput>;
    @Field(() => [ItemOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ItemOrderByWithRelationInput>;
    @Field(() => ItemWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ItemCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ItemCountAggregateInput>;
    @Field(() => ItemAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ItemAvgAggregateInput>;
    @Field(() => ItemSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ItemSumAggregateInput>;
    @Field(() => ItemMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ItemMinAggregateInput>;
    @Field(() => ItemMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ItemMaxAggregateInput>;
}

@InputType()
export class ItemAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    price?: true;
    @Field(() => Boolean, {nullable:true})
    cost?: true;
}

@ObjectType()
export class ItemAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    price?: number;
    @Field(() => Float, {nullable:true})
    cost?: number;
}

@InputType()
export class ItemAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
}

@InputType()
export class ItemCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    price?: true;
    @Field(() => Boolean, {nullable:true})
    cost?: true;
    @Field(() => Boolean, {nullable:true})
    userRole?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class ItemCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    description!: number;
    @Field(() => Int, {nullable:false})
    price!: number;
    @Field(() => Int, {nullable:false})
    cost!: number;
    @Field(() => Int, {nullable:false})
    userRole!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class ItemCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@ObjectType()
export class ItemCount {
    @Field(() => Int, {nullable:false})
    cart?: number;
}

@InputType()
export class ItemCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    price!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    cost!: number;
    @Field(() => UserRole, {nullable:false})
    userRole!: keyof typeof UserRole;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ItemCreateNestedOneWithoutCartInput {
    @Field(() => ItemCreateWithoutCartInput, {nullable:true})
    @Type(() => ItemCreateWithoutCartInput)
    create?: InstanceType<typeof ItemCreateWithoutCartInput>;
    @Field(() => ItemCreateOrConnectWithoutCartInput, {nullable:true})
    @Type(() => ItemCreateOrConnectWithoutCartInput)
    connectOrCreate?: InstanceType<typeof ItemCreateOrConnectWithoutCartInput>;
    @Field(() => ItemWhereUniqueInput, {nullable:true})
    @Type(() => ItemWhereUniqueInput)
    connect?: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
}

@InputType()
export class ItemCreateOrConnectWithoutCartInput {
    @Field(() => ItemWhereUniqueInput, {nullable:false})
    @Type(() => ItemWhereUniqueInput)
    where!: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
    @Field(() => ItemCreateWithoutCartInput, {nullable:false})
    @Type(() => ItemCreateWithoutCartInput)
    create!: InstanceType<typeof ItemCreateWithoutCartInput>;
}

@InputType()
export class ItemCreateWithoutCartInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    price!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    cost!: number;
    @Field(() => UserRole, {nullable:false})
    userRole!: keyof typeof UserRole;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ItemCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    price!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    cost!: number;
    @Field(() => UserRole, {nullable:false})
    userRole!: keyof typeof UserRole;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => CartCreateNestedManyWithoutMembershipItemInput, {nullable:true})
    cart?: InstanceType<typeof CartCreateNestedManyWithoutMembershipItemInput>;
}

@ArgsType()
export class ItemGroupByArgs {
    @Field(() => ItemWhereInput, {nullable:true})
    @Type(() => ItemWhereInput)
    where?: InstanceType<typeof ItemWhereInput>;
    @Field(() => [ItemOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<ItemOrderByWithAggregationInput>;
    @Field(() => [ItemScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof ItemScalarFieldEnum>;
    @Field(() => ItemScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof ItemScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ItemCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ItemCountAggregateInput>;
    @Field(() => ItemAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ItemAvgAggregateInput>;
    @Field(() => ItemSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ItemSumAggregateInput>;
    @Field(() => ItemMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ItemMinAggregateInput>;
    @Field(() => ItemMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ItemMaxAggregateInput>;
}

@ObjectType()
export class ItemGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => Float, {nullable:false})
    price!: number;
    @Field(() => Float, {nullable:false})
    cost!: number;
    @Field(() => UserRole, {nullable:false})
    userRole!: keyof typeof UserRole;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => ItemCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ItemCountAggregate>;
    @Field(() => ItemAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ItemAvgAggregate>;
    @Field(() => ItemSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ItemSumAggregate>;
    @Field(() => ItemMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ItemMinAggregate>;
    @Field(() => ItemMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ItemMaxAggregate>;
}

@InputType()
export class ItemMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    price?: true;
    @Field(() => Boolean, {nullable:true})
    cost?: true;
    @Field(() => Boolean, {nullable:true})
    userRole?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class ItemMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => Float, {nullable:true})
    price?: number;
    @Field(() => Float, {nullable:true})
    cost?: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ItemMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ItemMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    price?: true;
    @Field(() => Boolean, {nullable:true})
    cost?: true;
    @Field(() => Boolean, {nullable:true})
    userRole?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class ItemMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => Float, {nullable:true})
    price?: number;
    @Field(() => Float, {nullable:true})
    cost?: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ItemMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ItemNullableRelationFilter {
    @Field(() => ItemWhereInput, {nullable:true})
    is?: InstanceType<typeof ItemWhereInput>;
    @Field(() => ItemWhereInput, {nullable:true})
    isNot?: InstanceType<typeof ItemWhereInput>;
}

@InputType()
export class ItemOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => ItemCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ItemCountOrderByAggregateInput>;
    @Field(() => ItemAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ItemAvgOrderByAggregateInput>;
    @Field(() => ItemMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ItemMaxOrderByAggregateInput>;
    @Field(() => ItemMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ItemMinOrderByAggregateInput>;
    @Field(() => ItemSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ItemSumOrderByAggregateInput>;
}

@InputType()
export class ItemOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => CartOrderByRelationAggregateInput, {nullable:true})
    cart?: InstanceType<typeof CartOrderByRelationAggregateInput>;
}

@InputType()
export class ItemScalarWhereWithAggregatesInput {
    @Field(() => [ItemScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<ItemScalarWhereWithAggregatesInput>;
    @Field(() => [ItemScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<ItemScalarWhereWithAggregatesInput>;
    @Field(() => [ItemScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<ItemScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    description?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    price?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    cost?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => EnumUserRoleWithAggregatesFilter, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class ItemSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    price?: true;
    @Field(() => Boolean, {nullable:true})
    cost?: true;
}

@ObjectType()
export class ItemSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    price?: number;
    @Field(() => Float, {nullable:true})
    cost?: number;
}

@InputType()
export class ItemSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    price?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    cost?: keyof typeof SortOrder;
}

@InputType()
export class ItemUncheckedCreateWithoutCartInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    price!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    cost!: number;
    @Field(() => UserRole, {nullable:false})
    userRole!: keyof typeof UserRole;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ItemUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(30)
    description!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    price!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    cost!: number;
    @Field(() => UserRole, {nullable:false})
    userRole!: keyof typeof UserRole;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => CartUncheckedCreateNestedManyWithoutMembershipItemInput, {nullable:true})
    cart?: InstanceType<typeof CartUncheckedCreateNestedManyWithoutMembershipItemInput>;
}

@InputType()
export class ItemUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ItemUncheckedUpdateWithoutCartInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ItemUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => CartUncheckedUpdateManyWithoutMembershipItemNestedInput, {nullable:true})
    cart?: InstanceType<typeof CartUncheckedUpdateManyWithoutMembershipItemNestedInput>;
}

@InputType()
export class ItemUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ItemUpdateOneWithoutCartNestedInput {
    @Field(() => ItemCreateWithoutCartInput, {nullable:true})
    @Type(() => ItemCreateWithoutCartInput)
    create?: InstanceType<typeof ItemCreateWithoutCartInput>;
    @Field(() => ItemCreateOrConnectWithoutCartInput, {nullable:true})
    @Type(() => ItemCreateOrConnectWithoutCartInput)
    connectOrCreate?: InstanceType<typeof ItemCreateOrConnectWithoutCartInput>;
    @Field(() => ItemUpsertWithoutCartInput, {nullable:true})
    @Type(() => ItemUpsertWithoutCartInput)
    upsert?: InstanceType<typeof ItemUpsertWithoutCartInput>;
    @Field(() => ItemWhereInput, {nullable:true})
    @Type(() => ItemWhereInput)
    disconnect?: InstanceType<typeof ItemWhereInput>;
    @Field(() => ItemWhereInput, {nullable:true})
    @Type(() => ItemWhereInput)
    delete?: InstanceType<typeof ItemWhereInput>;
    @Field(() => ItemWhereUniqueInput, {nullable:true})
    @Type(() => ItemWhereUniqueInput)
    connect?: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
    @Field(() => ItemUpdateToOneWithWhereWithoutCartInput, {nullable:true})
    @Type(() => ItemUpdateToOneWithWhereWithoutCartInput)
    update?: InstanceType<typeof ItemUpdateToOneWithWhereWithoutCartInput>;
}

@InputType()
export class ItemUpdateToOneWithWhereWithoutCartInput {
    @Field(() => ItemWhereInput, {nullable:true})
    @Type(() => ItemWhereInput)
    where?: InstanceType<typeof ItemWhereInput>;
    @Field(() => ItemUpdateWithoutCartInput, {nullable:false})
    @Type(() => ItemUpdateWithoutCartInput)
    data!: InstanceType<typeof ItemUpdateWithoutCartInput>;
}

@InputType()
export class ItemUpdateWithoutCartInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ItemUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    price?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    cost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => CartUpdateManyWithoutMembershipItemNestedInput, {nullable:true})
    cart?: InstanceType<typeof CartUpdateManyWithoutMembershipItemNestedInput>;
}

@InputType()
export class ItemUpsertWithoutCartInput {
    @Field(() => ItemUpdateWithoutCartInput, {nullable:false})
    @Type(() => ItemUpdateWithoutCartInput)
    update!: InstanceType<typeof ItemUpdateWithoutCartInput>;
    @Field(() => ItemCreateWithoutCartInput, {nullable:false})
    @Type(() => ItemCreateWithoutCartInput)
    create!: InstanceType<typeof ItemCreateWithoutCartInput>;
    @Field(() => ItemWhereInput, {nullable:true})
    @Type(() => ItemWhereInput)
    where?: InstanceType<typeof ItemWhereInput>;
}

@InputType()
export class ItemWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [ItemWhereInput], {nullable:true})
    AND?: Array<ItemWhereInput>;
    @Field(() => [ItemWhereInput], {nullable:true})
    OR?: Array<ItemWhereInput>;
    @Field(() => [ItemWhereInput], {nullable:true})
    NOT?: Array<ItemWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    price?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    cost?: InstanceType<typeof FloatFilter>;
    @Field(() => EnumUserRoleFilter, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => CartListRelationFilter, {nullable:true})
    cart?: InstanceType<typeof CartListRelationFilter>;
}

@InputType()
export class ItemWhereInput {
    @Field(() => [ItemWhereInput], {nullable:true})
    AND?: Array<ItemWhereInput>;
    @Field(() => [ItemWhereInput], {nullable:true})
    OR?: Array<ItemWhereInput>;
    @Field(() => [ItemWhereInput], {nullable:true})
    NOT?: Array<ItemWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    price?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    cost?: InstanceType<typeof FloatFilter>;
    @Field(() => EnumUserRoleFilter, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => CartListRelationFilter, {nullable:true})
    cart?: InstanceType<typeof CartListRelationFilter>;
}

@ObjectType()
export class Item {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => Float, {nullable:false})
    price!: number;
    @Field(() => Float, {nullable:false})
    cost!: number;
    @Field(() => UserRole, {nullable:false})
    userRole!: keyof typeof UserRole;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => [Cart], {nullable:true})
    cart?: Array<Cart>;
    @Field(() => ItemCount, {nullable:false})
    _count?: InstanceType<typeof ItemCount>;
}

@ArgsType()
export class UpdateManyItemArgs {
    @Field(() => ItemUpdateManyMutationInput, {nullable:false})
    @Type(() => ItemUpdateManyMutationInput)
    data!: InstanceType<typeof ItemUpdateManyMutationInput>;
    @Field(() => ItemWhereInput, {nullable:true})
    @Type(() => ItemWhereInput)
    where?: InstanceType<typeof ItemWhereInput>;
}

@ArgsType()
export class UpdateOneItemArgs {
    @Field(() => ItemUpdateInput, {nullable:false})
    @Type(() => ItemUpdateInput)
    data!: InstanceType<typeof ItemUpdateInput>;
    @Field(() => ItemWhereUniqueInput, {nullable:false})
    @Type(() => ItemWhereUniqueInput)
    where!: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneItemArgs {
    @Field(() => ItemWhereUniqueInput, {nullable:false})
    @Type(() => ItemWhereUniqueInput)
    where!: Prisma.AtLeast<ItemWhereUniqueInput, 'id'>;
    @Field(() => ItemCreateInput, {nullable:false})
    @Type(() => ItemCreateInput)
    create!: InstanceType<typeof ItemCreateInput>;
    @Field(() => ItemUpdateInput, {nullable:false})
    @Type(() => ItemUpdateInput)
    update!: InstanceType<typeof ItemUpdateInput>;
}

@ObjectType()
export class AggregateOrder {
    @Field(() => OrderCountAggregate, {nullable:true})
    _count?: InstanceType<typeof OrderCountAggregate>;
    @Field(() => OrderAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof OrderAvgAggregate>;
    @Field(() => OrderSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof OrderSumAggregate>;
    @Field(() => OrderMinAggregate, {nullable:true})
    _min?: InstanceType<typeof OrderMinAggregate>;
    @Field(() => OrderMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof OrderMaxAggregate>;
}

@ArgsType()
export class CreateManyOrderArgs {
    @Field(() => [OrderCreateManyInput], {nullable:false})
    @Type(() => OrderCreateManyInput)
    data!: Array<OrderCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneOrderArgs {
    @Field(() => OrderCreateInput, {nullable:false})
    @Type(() => OrderCreateInput)
    data!: InstanceType<typeof OrderCreateInput>;
}

@ArgsType()
export class DeleteManyOrderArgs {
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
}

@ArgsType()
export class DeleteOneOrderArgs {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
}

@ArgsType()
export class FindFirstOrderOrThrowArgs {
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
    @Field(() => [OrderOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<OrderOrderByWithRelationInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [OrderScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof OrderScalarFieldEnum>;
}

@ArgsType()
export class FindFirstOrderArgs {
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
    @Field(() => [OrderOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<OrderOrderByWithRelationInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [OrderScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof OrderScalarFieldEnum>;
}

@ArgsType()
export class FindManyOrderArgs {
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
    @Field(() => [OrderOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<OrderOrderByWithRelationInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [OrderScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof OrderScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueOrderOrThrowArgs {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
}

@ArgsType()
export class FindUniqueOrderArgs {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
}

@ArgsType()
export class OrderAggregateArgs {
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
    @Field(() => [OrderOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<OrderOrderByWithRelationInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => OrderCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof OrderCountAggregateInput>;
    @Field(() => OrderAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof OrderAvgAggregateInput>;
    @Field(() => OrderSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof OrderSumAggregateInput>;
    @Field(() => OrderMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof OrderMinAggregateInput>;
    @Field(() => OrderMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof OrderMaxAggregateInput>;
}

@InputType()
export class OrderAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    shippingId?: true;
    @Field(() => Boolean, {nullable:true})
    invoiceId?: true;
    @Field(() => Boolean, {nullable:true})
    platformFee?: true;
    @Field(() => Boolean, {nullable:true})
    total?: true;
}

@ObjectType()
export class OrderAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    shippingId?: number;
    @Field(() => Float, {nullable:true})
    invoiceId?: number;
    @Field(() => Float, {nullable:true})
    platformFee?: number;
    @Field(() => Float, {nullable:true})
    total?: number;
}

@InputType()
export class OrderAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    shippingId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    invoiceId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    platformFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    total?: keyof typeof SortOrder;
}

@InputType()
export class OrderCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    orderById?: true;
    @Field(() => Boolean, {nullable:true})
    shippingId?: true;
    @Field(() => Boolean, {nullable:true})
    invoiceId?: true;
    @Field(() => Boolean, {nullable:true})
    platformFee?: true;
    @Field(() => Boolean, {nullable:true})
    total?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class OrderCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    status!: number;
    @Field(() => Int, {nullable:false})
    orderById!: number;
    @Field(() => Int, {nullable:false})
    shippingId!: number;
    @Field(() => Int, {nullable:false})
    invoiceId!: number;
    @Field(() => Int, {nullable:false})
    platformFee!: number;
    @Field(() => Int, {nullable:false})
    total!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class OrderCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    shippingId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    invoiceId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    platformFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    total?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@ObjectType()
export class OrderCount {
    @Field(() => Int, {nullable:false})
    cart?: number;
}

@InputType()
export class OrderCreateManyOrderByInputEnvelope {
    @Field(() => [OrderCreateManyOrderByInput], {nullable:false})
    @Type(() => OrderCreateManyOrderByInput)
    data!: Array<OrderCreateManyOrderByInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class OrderCreateManyOrderByInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Int, {nullable:false})
    invoiceId!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class OrderCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:false})
    orderById!: string;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Int, {nullable:false})
    invoiceId!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class OrderCreateNestedManyWithoutOrderByInput {
    @Field(() => [OrderCreateWithoutOrderByInput], {nullable:true})
    @Type(() => OrderCreateWithoutOrderByInput)
    create?: Array<OrderCreateWithoutOrderByInput>;
    @Field(() => [OrderCreateOrConnectWithoutOrderByInput], {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutOrderByInput)
    connectOrCreate?: Array<OrderCreateOrConnectWithoutOrderByInput>;
    @Field(() => OrderCreateManyOrderByInputEnvelope, {nullable:true})
    @Type(() => OrderCreateManyOrderByInputEnvelope)
    createMany?: InstanceType<typeof OrderCreateManyOrderByInputEnvelope>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>>;
}

@InputType()
export class OrderCreateNestedOneWithoutCartInput {
    @Field(() => OrderCreateWithoutCartInput, {nullable:true})
    @Type(() => OrderCreateWithoutCartInput)
    create?: InstanceType<typeof OrderCreateWithoutCartInput>;
    @Field(() => OrderCreateOrConnectWithoutCartInput, {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutCartInput)
    connectOrCreate?: InstanceType<typeof OrderCreateOrConnectWithoutCartInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
}

@InputType()
export class OrderCreateNestedOneWithoutInvoiceInput {
    @Field(() => OrderCreateWithoutInvoiceInput, {nullable:true})
    @Type(() => OrderCreateWithoutInvoiceInput)
    create?: InstanceType<typeof OrderCreateWithoutInvoiceInput>;
    @Field(() => OrderCreateOrConnectWithoutInvoiceInput, {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutInvoiceInput)
    connectOrCreate?: InstanceType<typeof OrderCreateOrConnectWithoutInvoiceInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
}

@InputType()
export class OrderCreateNestedOneWithoutShippingInput {
    @Field(() => OrderCreateWithoutShippingInput, {nullable:true})
    @Type(() => OrderCreateWithoutShippingInput)
    create?: InstanceType<typeof OrderCreateWithoutShippingInput>;
    @Field(() => OrderCreateOrConnectWithoutShippingInput, {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutShippingInput)
    connectOrCreate?: InstanceType<typeof OrderCreateOrConnectWithoutShippingInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
}

@InputType()
export class OrderCreateOrConnectWithoutCartInput {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
    @Field(() => OrderCreateWithoutCartInput, {nullable:false})
    @Type(() => OrderCreateWithoutCartInput)
    create!: InstanceType<typeof OrderCreateWithoutCartInput>;
}

@InputType()
export class OrderCreateOrConnectWithoutInvoiceInput {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
    @Field(() => OrderCreateWithoutInvoiceInput, {nullable:false})
    @Type(() => OrderCreateWithoutInvoiceInput)
    create!: InstanceType<typeof OrderCreateWithoutInvoiceInput>;
}

@InputType()
export class OrderCreateOrConnectWithoutOrderByInput {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
    @Field(() => OrderCreateWithoutOrderByInput, {nullable:false})
    @Type(() => OrderCreateWithoutOrderByInput)
    create!: InstanceType<typeof OrderCreateWithoutOrderByInput>;
}

@InputType()
export class OrderCreateOrConnectWithoutShippingInput {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
    @Field(() => OrderCreateWithoutShippingInput, {nullable:false})
    @Type(() => OrderCreateWithoutShippingInput)
    create!: InstanceType<typeof OrderCreateWithoutShippingInput>;
}

@InputType()
export class OrderCreateWithoutCartInput {
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutOrdersInput, {nullable:false})
    orderBy!: InstanceType<typeof UserCreateNestedOneWithoutOrdersInput>;
    @Field(() => ShippingCreateNestedOneWithoutOrderInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutOrderInput>;
    @Field(() => InvoiceCreateNestedOneWithoutOrderInput, {nullable:false})
    invoice!: InstanceType<typeof InvoiceCreateNestedOneWithoutOrderInput>;
}

@InputType()
export class OrderCreateWithoutInvoiceInput {
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutOrdersInput, {nullable:false})
    orderBy!: InstanceType<typeof UserCreateNestedOneWithoutOrdersInput>;
    @Field(() => CartCreateNestedManyWithoutOrderInput, {nullable:true})
    cart?: InstanceType<typeof CartCreateNestedManyWithoutOrderInput>;
    @Field(() => ShippingCreateNestedOneWithoutOrderInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutOrderInput>;
}

@InputType()
export class OrderCreateWithoutOrderByInput {
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => CartCreateNestedManyWithoutOrderInput, {nullable:true})
    cart?: InstanceType<typeof CartCreateNestedManyWithoutOrderInput>;
    @Field(() => ShippingCreateNestedOneWithoutOrderInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutOrderInput>;
    @Field(() => InvoiceCreateNestedOneWithoutOrderInput, {nullable:false})
    invoice!: InstanceType<typeof InvoiceCreateNestedOneWithoutOrderInput>;
}

@InputType()
export class OrderCreateWithoutShippingInput {
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutOrdersInput, {nullable:false})
    orderBy!: InstanceType<typeof UserCreateNestedOneWithoutOrdersInput>;
    @Field(() => CartCreateNestedManyWithoutOrderInput, {nullable:true})
    cart?: InstanceType<typeof CartCreateNestedManyWithoutOrderInput>;
    @Field(() => InvoiceCreateNestedOneWithoutOrderInput, {nullable:false})
    invoice!: InstanceType<typeof InvoiceCreateNestedOneWithoutOrderInput>;
}

@InputType()
export class OrderCreateInput {
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutOrdersInput, {nullable:false})
    orderBy!: InstanceType<typeof UserCreateNestedOneWithoutOrdersInput>;
    @Field(() => CartCreateNestedManyWithoutOrderInput, {nullable:true})
    cart?: InstanceType<typeof CartCreateNestedManyWithoutOrderInput>;
    @Field(() => ShippingCreateNestedOneWithoutOrderInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingCreateNestedOneWithoutOrderInput>;
    @Field(() => InvoiceCreateNestedOneWithoutOrderInput, {nullable:false})
    invoice!: InstanceType<typeof InvoiceCreateNestedOneWithoutOrderInput>;
}

@ArgsType()
export class OrderGroupByArgs {
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
    @Field(() => [OrderOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<OrderOrderByWithAggregationInput>;
    @Field(() => [OrderScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof OrderScalarFieldEnum>;
    @Field(() => OrderScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof OrderScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => OrderCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof OrderCountAggregateInput>;
    @Field(() => OrderAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof OrderAvgAggregateInput>;
    @Field(() => OrderSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof OrderSumAggregateInput>;
    @Field(() => OrderMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof OrderMinAggregateInput>;
    @Field(() => OrderMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof OrderMaxAggregateInput>;
}

@ObjectType()
export class OrderGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:false})
    orderById!: string;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Int, {nullable:false})
    invoiceId!: number;
    @Field(() => Float, {nullable:false})
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    total!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => OrderCountAggregate, {nullable:true})
    _count?: InstanceType<typeof OrderCountAggregate>;
    @Field(() => OrderAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof OrderAvgAggregate>;
    @Field(() => OrderSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof OrderSumAggregate>;
    @Field(() => OrderMinAggregate, {nullable:true})
    _min?: InstanceType<typeof OrderMinAggregate>;
    @Field(() => OrderMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof OrderMaxAggregate>;
}

@InputType()
export class OrderListRelationFilter {
    @Field(() => OrderWhereInput, {nullable:true})
    every?: InstanceType<typeof OrderWhereInput>;
    @Field(() => OrderWhereInput, {nullable:true})
    some?: InstanceType<typeof OrderWhereInput>;
    @Field(() => OrderWhereInput, {nullable:true})
    none?: InstanceType<typeof OrderWhereInput>;
}

@InputType()
export class OrderMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    orderById?: true;
    @Field(() => Boolean, {nullable:true})
    shippingId?: true;
    @Field(() => Boolean, {nullable:true})
    invoiceId?: true;
    @Field(() => Boolean, {nullable:true})
    platformFee?: true;
    @Field(() => Boolean, {nullable:true})
    total?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class OrderMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => TransactionStatus, {nullable:true})
    status?: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:true})
    orderById?: string;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Int, {nullable:true})
    invoiceId?: number;
    @Field(() => Float, {nullable:true})
    platformFee?: number;
    @Field(() => Float, {nullable:true})
    total?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class OrderMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    shippingId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    invoiceId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    platformFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    total?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class OrderMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    orderById?: true;
    @Field(() => Boolean, {nullable:true})
    shippingId?: true;
    @Field(() => Boolean, {nullable:true})
    invoiceId?: true;
    @Field(() => Boolean, {nullable:true})
    platformFee?: true;
    @Field(() => Boolean, {nullable:true})
    total?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class OrderMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => TransactionStatus, {nullable:true})
    status?: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:true})
    orderById?: string;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Int, {nullable:true})
    invoiceId?: number;
    @Field(() => Float, {nullable:true})
    platformFee?: number;
    @Field(() => Float, {nullable:true})
    total?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class OrderMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    shippingId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    invoiceId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    platformFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    total?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class OrderNullableRelationFilter {
    @Field(() => OrderWhereInput, {nullable:true})
    is?: InstanceType<typeof OrderWhereInput>;
    @Field(() => OrderWhereInput, {nullable:true})
    isNot?: InstanceType<typeof OrderWhereInput>;
}

@InputType()
export class OrderOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class OrderOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderById?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    shippingId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    invoiceId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    platformFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    total?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => OrderCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof OrderCountOrderByAggregateInput>;
    @Field(() => OrderAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof OrderAvgOrderByAggregateInput>;
    @Field(() => OrderMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof OrderMaxOrderByAggregateInput>;
    @Field(() => OrderMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof OrderMinOrderByAggregateInput>;
    @Field(() => OrderSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof OrderSumOrderByAggregateInput>;
}

@InputType()
export class OrderOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderById?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    shippingId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    invoiceId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    platformFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    total?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    orderBy?: InstanceType<typeof UserOrderByWithRelationInput>;
    @Field(() => CartOrderByRelationAggregateInput, {nullable:true})
    cart?: InstanceType<typeof CartOrderByRelationAggregateInput>;
    @Field(() => ShippingOrderByWithRelationInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingOrderByWithRelationInput>;
    @Field(() => InvoiceOrderByWithRelationInput, {nullable:true})
    invoice?: InstanceType<typeof InvoiceOrderByWithRelationInput>;
}

@InputType()
export class OrderRelationFilter {
    @Field(() => OrderWhereInput, {nullable:true})
    is?: InstanceType<typeof OrderWhereInput>;
    @Field(() => OrderWhereInput, {nullable:true})
    isNot?: InstanceType<typeof OrderWhereInput>;
}

@InputType()
export class OrderScalarWhereWithAggregatesInput {
    @Field(() => [OrderScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<OrderScalarWhereWithAggregatesInput>;
    @Field(() => [OrderScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<OrderScalarWhereWithAggregatesInput>;
    @Field(() => [OrderScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<OrderScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => EnumTransactionStatusWithAggregatesFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    orderById?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntNullableWithAggregatesFilter, {nullable:true})
    shippingId?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    invoiceId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    platformFee?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    total?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class OrderScalarWhereInput {
    @Field(() => [OrderScalarWhereInput], {nullable:true})
    AND?: Array<OrderScalarWhereInput>;
    @Field(() => [OrderScalarWhereInput], {nullable:true})
    OR?: Array<OrderScalarWhereInput>;
    @Field(() => [OrderScalarWhereInput], {nullable:true})
    NOT?: Array<OrderScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => EnumTransactionStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFilter>;
    @Field(() => StringFilter, {nullable:true})
    orderById?: InstanceType<typeof StringFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    shippingId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntFilter, {nullable:true})
    invoiceId?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    platformFee?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    total?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class OrderSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    shippingId?: true;
    @Field(() => Boolean, {nullable:true})
    invoiceId?: true;
    @Field(() => Boolean, {nullable:true})
    platformFee?: true;
    @Field(() => Boolean, {nullable:true})
    total?: true;
}

@ObjectType()
export class OrderSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Int, {nullable:true})
    invoiceId?: number;
    @Field(() => Float, {nullable:true})
    platformFee?: number;
    @Field(() => Float, {nullable:true})
    total?: number;
}

@InputType()
export class OrderSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    shippingId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    invoiceId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    platformFee?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    total?: keyof typeof SortOrder;
}

@InputType()
export class OrderUncheckedCreateNestedManyWithoutOrderByInput {
    @Field(() => [OrderCreateWithoutOrderByInput], {nullable:true})
    @Type(() => OrderCreateWithoutOrderByInput)
    create?: Array<OrderCreateWithoutOrderByInput>;
    @Field(() => [OrderCreateOrConnectWithoutOrderByInput], {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutOrderByInput)
    connectOrCreate?: Array<OrderCreateOrConnectWithoutOrderByInput>;
    @Field(() => OrderCreateManyOrderByInputEnvelope, {nullable:true})
    @Type(() => OrderCreateManyOrderByInputEnvelope)
    createMany?: InstanceType<typeof OrderCreateManyOrderByInputEnvelope>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>>;
}

@InputType()
export class OrderUncheckedCreateNestedOneWithoutInvoiceInput {
    @Field(() => OrderCreateWithoutInvoiceInput, {nullable:true})
    @Type(() => OrderCreateWithoutInvoiceInput)
    create?: InstanceType<typeof OrderCreateWithoutInvoiceInput>;
    @Field(() => OrderCreateOrConnectWithoutInvoiceInput, {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutInvoiceInput)
    connectOrCreate?: InstanceType<typeof OrderCreateOrConnectWithoutInvoiceInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
}

@InputType()
export class OrderUncheckedCreateWithoutCartInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:false})
    orderById!: string;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Int, {nullable:false})
    invoiceId!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutOrderInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutOrderInput>;
}

@InputType()
export class OrderUncheckedCreateWithoutInvoiceInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:false})
    orderById!: string;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => CartUncheckedCreateNestedManyWithoutOrderInput, {nullable:true})
    cart?: InstanceType<typeof CartUncheckedCreateNestedManyWithoutOrderInput>;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutOrderInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutOrderInput>;
}

@InputType()
export class OrderUncheckedCreateWithoutOrderByInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Int, {nullable:false})
    invoiceId!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => CartUncheckedCreateNestedManyWithoutOrderInput, {nullable:true})
    cart?: InstanceType<typeof CartUncheckedCreateNestedManyWithoutOrderInput>;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutOrderInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutOrderInput>;
}

@InputType()
export class OrderUncheckedCreateWithoutShippingInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:false})
    orderById!: string;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Int, {nullable:false})
    invoiceId!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => CartUncheckedCreateNestedManyWithoutOrderInput, {nullable:true})
    cart?: InstanceType<typeof CartUncheckedCreateNestedManyWithoutOrderInput>;
}

@InputType()
export class OrderUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:false})
    orderById!: string;
    @Field(() => Int, {nullable:true})
    shippingId?: number;
    @Field(() => Int, {nullable:false})
    invoiceId!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    total!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => CartUncheckedCreateNestedManyWithoutOrderInput, {nullable:true})
    cart?: InstanceType<typeof CartUncheckedCreateNestedManyWithoutOrderInput>;
    @Field(() => ShippingUncheckedCreateNestedOneWithoutOrderInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUncheckedCreateNestedOneWithoutOrderInput>;
}

@InputType()
export class OrderUncheckedUpdateManyWithoutOrderByNestedInput {
    @Field(() => [OrderCreateWithoutOrderByInput], {nullable:true})
    @Type(() => OrderCreateWithoutOrderByInput)
    create?: Array<OrderCreateWithoutOrderByInput>;
    @Field(() => [OrderCreateOrConnectWithoutOrderByInput], {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutOrderByInput)
    connectOrCreate?: Array<OrderCreateOrConnectWithoutOrderByInput>;
    @Field(() => [OrderUpsertWithWhereUniqueWithoutOrderByInput], {nullable:true})
    @Type(() => OrderUpsertWithWhereUniqueWithoutOrderByInput)
    upsert?: Array<OrderUpsertWithWhereUniqueWithoutOrderByInput>;
    @Field(() => OrderCreateManyOrderByInputEnvelope, {nullable:true})
    @Type(() => OrderCreateManyOrderByInputEnvelope)
    createMany?: InstanceType<typeof OrderCreateManyOrderByInputEnvelope>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    set?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>>;
    @Field(() => [OrderUpdateWithWhereUniqueWithoutOrderByInput], {nullable:true})
    @Type(() => OrderUpdateWithWhereUniqueWithoutOrderByInput)
    update?: Array<OrderUpdateWithWhereUniqueWithoutOrderByInput>;
    @Field(() => [OrderUpdateManyWithWhereWithoutOrderByInput], {nullable:true})
    @Type(() => OrderUpdateManyWithWhereWithoutOrderByInput)
    updateMany?: Array<OrderUpdateManyWithWhereWithoutOrderByInput>;
    @Field(() => [OrderScalarWhereInput], {nullable:true})
    @Type(() => OrderScalarWhereInput)
    deleteMany?: Array<OrderScalarWhereInput>;
}

@InputType()
export class OrderUncheckedUpdateManyWithoutOrderByInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    invoiceId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class OrderUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    orderById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    invoiceId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class OrderUncheckedUpdateOneWithoutInvoiceNestedInput {
    @Field(() => OrderCreateWithoutInvoiceInput, {nullable:true})
    @Type(() => OrderCreateWithoutInvoiceInput)
    create?: InstanceType<typeof OrderCreateWithoutInvoiceInput>;
    @Field(() => OrderCreateOrConnectWithoutInvoiceInput, {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutInvoiceInput)
    connectOrCreate?: InstanceType<typeof OrderCreateOrConnectWithoutInvoiceInput>;
    @Field(() => OrderUpsertWithoutInvoiceInput, {nullable:true})
    @Type(() => OrderUpsertWithoutInvoiceInput)
    upsert?: InstanceType<typeof OrderUpsertWithoutInvoiceInput>;
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    disconnect?: InstanceType<typeof OrderWhereInput>;
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    delete?: InstanceType<typeof OrderWhereInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
    @Field(() => OrderUpdateToOneWithWhereWithoutInvoiceInput, {nullable:true})
    @Type(() => OrderUpdateToOneWithWhereWithoutInvoiceInput)
    update?: InstanceType<typeof OrderUpdateToOneWithWhereWithoutInvoiceInput>;
}

@InputType()
export class OrderUncheckedUpdateWithoutCartInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    orderById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    invoiceId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutOrderNestedInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutOrderNestedInput>;
}

@InputType()
export class OrderUncheckedUpdateWithoutInvoiceInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    orderById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => CartUncheckedUpdateManyWithoutOrderNestedInput, {nullable:true})
    cart?: InstanceType<typeof CartUncheckedUpdateManyWithoutOrderNestedInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutOrderNestedInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutOrderNestedInput>;
}

@InputType()
export class OrderUncheckedUpdateWithoutOrderByInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    invoiceId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => CartUncheckedUpdateManyWithoutOrderNestedInput, {nullable:true})
    cart?: InstanceType<typeof CartUncheckedUpdateManyWithoutOrderNestedInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutOrderNestedInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutOrderNestedInput>;
}

@InputType()
export class OrderUncheckedUpdateWithoutShippingInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    orderById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    invoiceId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => CartUncheckedUpdateManyWithoutOrderNestedInput, {nullable:true})
    cart?: InstanceType<typeof CartUncheckedUpdateManyWithoutOrderNestedInput>;
}

@InputType()
export class OrderUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    orderById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    invoiceId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => CartUncheckedUpdateManyWithoutOrderNestedInput, {nullable:true})
    cart?: InstanceType<typeof CartUncheckedUpdateManyWithoutOrderNestedInput>;
    @Field(() => ShippingUncheckedUpdateOneWithoutOrderNestedInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUncheckedUpdateOneWithoutOrderNestedInput>;
}

@InputType()
export class OrderUpdateManyMutationInput {
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class OrderUpdateManyWithWhereWithoutOrderByInput {
    @Field(() => OrderScalarWhereInput, {nullable:false})
    @Type(() => OrderScalarWhereInput)
    where!: InstanceType<typeof OrderScalarWhereInput>;
    @Field(() => OrderUpdateManyMutationInput, {nullable:false})
    @Type(() => OrderUpdateManyMutationInput)
    data!: InstanceType<typeof OrderUpdateManyMutationInput>;
}

@InputType()
export class OrderUpdateManyWithoutOrderByNestedInput {
    @Field(() => [OrderCreateWithoutOrderByInput], {nullable:true})
    @Type(() => OrderCreateWithoutOrderByInput)
    create?: Array<OrderCreateWithoutOrderByInput>;
    @Field(() => [OrderCreateOrConnectWithoutOrderByInput], {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutOrderByInput)
    connectOrCreate?: Array<OrderCreateOrConnectWithoutOrderByInput>;
    @Field(() => [OrderUpsertWithWhereUniqueWithoutOrderByInput], {nullable:true})
    @Type(() => OrderUpsertWithWhereUniqueWithoutOrderByInput)
    upsert?: Array<OrderUpsertWithWhereUniqueWithoutOrderByInput>;
    @Field(() => OrderCreateManyOrderByInputEnvelope, {nullable:true})
    @Type(() => OrderCreateManyOrderByInputEnvelope)
    createMany?: InstanceType<typeof OrderCreateManyOrderByInputEnvelope>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    set?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>>;
    @Field(() => [OrderWhereUniqueInput], {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>>;
    @Field(() => [OrderUpdateWithWhereUniqueWithoutOrderByInput], {nullable:true})
    @Type(() => OrderUpdateWithWhereUniqueWithoutOrderByInput)
    update?: Array<OrderUpdateWithWhereUniqueWithoutOrderByInput>;
    @Field(() => [OrderUpdateManyWithWhereWithoutOrderByInput], {nullable:true})
    @Type(() => OrderUpdateManyWithWhereWithoutOrderByInput)
    updateMany?: Array<OrderUpdateManyWithWhereWithoutOrderByInput>;
    @Field(() => [OrderScalarWhereInput], {nullable:true})
    @Type(() => OrderScalarWhereInput)
    deleteMany?: Array<OrderScalarWhereInput>;
}

@InputType()
export class OrderUpdateOneRequiredWithoutCartNestedInput {
    @Field(() => OrderCreateWithoutCartInput, {nullable:true})
    @Type(() => OrderCreateWithoutCartInput)
    create?: InstanceType<typeof OrderCreateWithoutCartInput>;
    @Field(() => OrderCreateOrConnectWithoutCartInput, {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutCartInput)
    connectOrCreate?: InstanceType<typeof OrderCreateOrConnectWithoutCartInput>;
    @Field(() => OrderUpsertWithoutCartInput, {nullable:true})
    @Type(() => OrderUpsertWithoutCartInput)
    upsert?: InstanceType<typeof OrderUpsertWithoutCartInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
    @Field(() => OrderUpdateToOneWithWhereWithoutCartInput, {nullable:true})
    @Type(() => OrderUpdateToOneWithWhereWithoutCartInput)
    update?: InstanceType<typeof OrderUpdateToOneWithWhereWithoutCartInput>;
}

@InputType()
export class OrderUpdateOneRequiredWithoutShippingNestedInput {
    @Field(() => OrderCreateWithoutShippingInput, {nullable:true})
    @Type(() => OrderCreateWithoutShippingInput)
    create?: InstanceType<typeof OrderCreateWithoutShippingInput>;
    @Field(() => OrderCreateOrConnectWithoutShippingInput, {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutShippingInput)
    connectOrCreate?: InstanceType<typeof OrderCreateOrConnectWithoutShippingInput>;
    @Field(() => OrderUpsertWithoutShippingInput, {nullable:true})
    @Type(() => OrderUpsertWithoutShippingInput)
    upsert?: InstanceType<typeof OrderUpsertWithoutShippingInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
    @Field(() => OrderUpdateToOneWithWhereWithoutShippingInput, {nullable:true})
    @Type(() => OrderUpdateToOneWithWhereWithoutShippingInput)
    update?: InstanceType<typeof OrderUpdateToOneWithWhereWithoutShippingInput>;
}

@InputType()
export class OrderUpdateOneWithoutInvoiceNestedInput {
    @Field(() => OrderCreateWithoutInvoiceInput, {nullable:true})
    @Type(() => OrderCreateWithoutInvoiceInput)
    create?: InstanceType<typeof OrderCreateWithoutInvoiceInput>;
    @Field(() => OrderCreateOrConnectWithoutInvoiceInput, {nullable:true})
    @Type(() => OrderCreateOrConnectWithoutInvoiceInput)
    connectOrCreate?: InstanceType<typeof OrderCreateOrConnectWithoutInvoiceInput>;
    @Field(() => OrderUpsertWithoutInvoiceInput, {nullable:true})
    @Type(() => OrderUpsertWithoutInvoiceInput)
    upsert?: InstanceType<typeof OrderUpsertWithoutInvoiceInput>;
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    disconnect?: InstanceType<typeof OrderWhereInput>;
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    delete?: InstanceType<typeof OrderWhereInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:true})
    @Type(() => OrderWhereUniqueInput)
    connect?: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
    @Field(() => OrderUpdateToOneWithWhereWithoutInvoiceInput, {nullable:true})
    @Type(() => OrderUpdateToOneWithWhereWithoutInvoiceInput)
    update?: InstanceType<typeof OrderUpdateToOneWithWhereWithoutInvoiceInput>;
}

@InputType()
export class OrderUpdateToOneWithWhereWithoutCartInput {
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
    @Field(() => OrderUpdateWithoutCartInput, {nullable:false})
    @Type(() => OrderUpdateWithoutCartInput)
    data!: InstanceType<typeof OrderUpdateWithoutCartInput>;
}

@InputType()
export class OrderUpdateToOneWithWhereWithoutInvoiceInput {
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
    @Field(() => OrderUpdateWithoutInvoiceInput, {nullable:false})
    @Type(() => OrderUpdateWithoutInvoiceInput)
    data!: InstanceType<typeof OrderUpdateWithoutInvoiceInput>;
}

@InputType()
export class OrderUpdateToOneWithWhereWithoutShippingInput {
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
    @Field(() => OrderUpdateWithoutShippingInput, {nullable:false})
    @Type(() => OrderUpdateWithoutShippingInput)
    data!: InstanceType<typeof OrderUpdateWithoutShippingInput>;
}

@InputType()
export class OrderUpdateWithWhereUniqueWithoutOrderByInput {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
    @Field(() => OrderUpdateWithoutOrderByInput, {nullable:false})
    @Type(() => OrderUpdateWithoutOrderByInput)
    data!: InstanceType<typeof OrderUpdateWithoutOrderByInput>;
}

@InputType()
export class OrderUpdateWithoutCartInput {
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutOrdersNestedInput, {nullable:true})
    orderBy?: InstanceType<typeof UserUpdateOneRequiredWithoutOrdersNestedInput>;
    @Field(() => ShippingUpdateOneWithoutOrderNestedInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUpdateOneWithoutOrderNestedInput>;
    @Field(() => InvoiceUpdateOneRequiredWithoutOrderNestedInput, {nullable:true})
    invoice?: InstanceType<typeof InvoiceUpdateOneRequiredWithoutOrderNestedInput>;
}

@InputType()
export class OrderUpdateWithoutInvoiceInput {
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutOrdersNestedInput, {nullable:true})
    orderBy?: InstanceType<typeof UserUpdateOneRequiredWithoutOrdersNestedInput>;
    @Field(() => CartUpdateManyWithoutOrderNestedInput, {nullable:true})
    cart?: InstanceType<typeof CartUpdateManyWithoutOrderNestedInput>;
    @Field(() => ShippingUpdateOneWithoutOrderNestedInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUpdateOneWithoutOrderNestedInput>;
}

@InputType()
export class OrderUpdateWithoutOrderByInput {
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => CartUpdateManyWithoutOrderNestedInput, {nullable:true})
    cart?: InstanceType<typeof CartUpdateManyWithoutOrderNestedInput>;
    @Field(() => ShippingUpdateOneWithoutOrderNestedInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUpdateOneWithoutOrderNestedInput>;
    @Field(() => InvoiceUpdateOneRequiredWithoutOrderNestedInput, {nullable:true})
    invoice?: InstanceType<typeof InvoiceUpdateOneRequiredWithoutOrderNestedInput>;
}

@InputType()
export class OrderUpdateWithoutShippingInput {
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutOrdersNestedInput, {nullable:true})
    orderBy?: InstanceType<typeof UserUpdateOneRequiredWithoutOrdersNestedInput>;
    @Field(() => CartUpdateManyWithoutOrderNestedInput, {nullable:true})
    cart?: InstanceType<typeof CartUpdateManyWithoutOrderNestedInput>;
    @Field(() => InvoiceUpdateOneRequiredWithoutOrderNestedInput, {nullable:true})
    invoice?: InstanceType<typeof InvoiceUpdateOneRequiredWithoutOrderNestedInput>;
}

@InputType()
export class OrderUpdateInput {
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    shippingId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    platformFee?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    total?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutOrdersNestedInput, {nullable:true})
    orderBy?: InstanceType<typeof UserUpdateOneRequiredWithoutOrdersNestedInput>;
    @Field(() => CartUpdateManyWithoutOrderNestedInput, {nullable:true})
    cart?: InstanceType<typeof CartUpdateManyWithoutOrderNestedInput>;
    @Field(() => ShippingUpdateOneWithoutOrderNestedInput, {nullable:true})
    shipping?: InstanceType<typeof ShippingUpdateOneWithoutOrderNestedInput>;
    @Field(() => InvoiceUpdateOneRequiredWithoutOrderNestedInput, {nullable:true})
    invoice?: InstanceType<typeof InvoiceUpdateOneRequiredWithoutOrderNestedInput>;
}

@InputType()
export class OrderUpsertWithWhereUniqueWithoutOrderByInput {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
    @Field(() => OrderUpdateWithoutOrderByInput, {nullable:false})
    @Type(() => OrderUpdateWithoutOrderByInput)
    update!: InstanceType<typeof OrderUpdateWithoutOrderByInput>;
    @Field(() => OrderCreateWithoutOrderByInput, {nullable:false})
    @Type(() => OrderCreateWithoutOrderByInput)
    create!: InstanceType<typeof OrderCreateWithoutOrderByInput>;
}

@InputType()
export class OrderUpsertWithoutCartInput {
    @Field(() => OrderUpdateWithoutCartInput, {nullable:false})
    @Type(() => OrderUpdateWithoutCartInput)
    update!: InstanceType<typeof OrderUpdateWithoutCartInput>;
    @Field(() => OrderCreateWithoutCartInput, {nullable:false})
    @Type(() => OrderCreateWithoutCartInput)
    create!: InstanceType<typeof OrderCreateWithoutCartInput>;
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
}

@InputType()
export class OrderUpsertWithoutInvoiceInput {
    @Field(() => OrderUpdateWithoutInvoiceInput, {nullable:false})
    @Type(() => OrderUpdateWithoutInvoiceInput)
    update!: InstanceType<typeof OrderUpdateWithoutInvoiceInput>;
    @Field(() => OrderCreateWithoutInvoiceInput, {nullable:false})
    @Type(() => OrderCreateWithoutInvoiceInput)
    create!: InstanceType<typeof OrderCreateWithoutInvoiceInput>;
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
}

@InputType()
export class OrderUpsertWithoutShippingInput {
    @Field(() => OrderUpdateWithoutShippingInput, {nullable:false})
    @Type(() => OrderUpdateWithoutShippingInput)
    update!: InstanceType<typeof OrderUpdateWithoutShippingInput>;
    @Field(() => OrderCreateWithoutShippingInput, {nullable:false})
    @Type(() => OrderCreateWithoutShippingInput)
    create!: InstanceType<typeof OrderCreateWithoutShippingInput>;
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
}

@InputType()
export class OrderWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    orderById?: string;
    @Field(() => Int, {nullable:true})
    invoiceId?: number;
    @Field(() => [OrderWhereInput], {nullable:true})
    AND?: Array<OrderWhereInput>;
    @Field(() => [OrderWhereInput], {nullable:true})
    OR?: Array<OrderWhereInput>;
    @Field(() => [OrderWhereInput], {nullable:true})
    NOT?: Array<OrderWhereInput>;
    @Field(() => EnumTransactionStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    shippingId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => FloatFilter, {nullable:true})
    platformFee?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    total?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    orderBy?: InstanceType<typeof UserRelationFilter>;
    @Field(() => CartListRelationFilter, {nullable:true})
    cart?: InstanceType<typeof CartListRelationFilter>;
    @Field(() => ShippingNullableRelationFilter, {nullable:true})
    shipping?: InstanceType<typeof ShippingNullableRelationFilter>;
    @Field(() => InvoiceRelationFilter, {nullable:true})
    invoice?: InstanceType<typeof InvoiceRelationFilter>;
}

@InputType()
export class OrderWhereInput {
    @Field(() => [OrderWhereInput], {nullable:true})
    AND?: Array<OrderWhereInput>;
    @Field(() => [OrderWhereInput], {nullable:true})
    OR?: Array<OrderWhereInput>;
    @Field(() => [OrderWhereInput], {nullable:true})
    NOT?: Array<OrderWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => EnumTransactionStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFilter>;
    @Field(() => StringFilter, {nullable:true})
    orderById?: InstanceType<typeof StringFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    shippingId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntFilter, {nullable:true})
    invoiceId?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    platformFee?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    total?: InstanceType<typeof FloatFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    orderBy?: InstanceType<typeof UserRelationFilter>;
    @Field(() => CartListRelationFilter, {nullable:true})
    cart?: InstanceType<typeof CartListRelationFilter>;
    @Field(() => ShippingNullableRelationFilter, {nullable:true})
    shipping?: InstanceType<typeof ShippingNullableRelationFilter>;
    @Field(() => InvoiceRelationFilter, {nullable:true})
    invoice?: InstanceType<typeof InvoiceRelationFilter>;
}

@ObjectType()
export class Order {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:false})
    orderById!: string;
    @Field(() => Int, {nullable:true})
    shippingId!: number | null;
    @Field(() => Int, {nullable:false})
    invoiceId!: number;
    @Field(() => Float, {nullable:false})
    platformFee!: number;
    @Field(() => Float, {nullable:false})
    total!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => User, {nullable:false})
    orderBy?: InstanceType<typeof User>;
    @Field(() => [Cart], {nullable:true})
    cart?: Array<Cart>;
    @Field(() => Shipping, {nullable:true})
    shipping?: InstanceType<typeof Shipping> | null;
    @Field(() => Invoice, {nullable:false})
    invoice?: InstanceType<typeof Invoice>;
    @Field(() => OrderCount, {nullable:false})
    _count?: InstanceType<typeof OrderCount>;
}

@ArgsType()
export class UpdateManyOrderArgs {
    @Field(() => OrderUpdateManyMutationInput, {nullable:false})
    @Type(() => OrderUpdateManyMutationInput)
    data!: InstanceType<typeof OrderUpdateManyMutationInput>;
    @Field(() => OrderWhereInput, {nullable:true})
    @Type(() => OrderWhereInput)
    where?: InstanceType<typeof OrderWhereInput>;
}

@ArgsType()
export class UpdateOneOrderArgs {
    @Field(() => OrderUpdateInput, {nullable:false})
    @Type(() => OrderUpdateInput)
    data!: InstanceType<typeof OrderUpdateInput>;
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
}

@ArgsType()
export class UpsertOneOrderArgs {
    @Field(() => OrderWhereUniqueInput, {nullable:false})
    @Type(() => OrderWhereUniqueInput)
    where!: Prisma.AtLeast<OrderWhereUniqueInput, 'id' | 'orderById' | 'invoiceId'>;
    @Field(() => OrderCreateInput, {nullable:false})
    @Type(() => OrderCreateInput)
    create!: InstanceType<typeof OrderCreateInput>;
    @Field(() => OrderUpdateInput, {nullable:false})
    @Type(() => OrderUpdateInput)
    update!: InstanceType<typeof OrderUpdateInput>;
}

@ObjectType()
export class AggregatePointTransaction {
    @Field(() => PointTransactionCountAggregate, {nullable:true})
    _count?: InstanceType<typeof PointTransactionCountAggregate>;
    @Field(() => PointTransactionAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof PointTransactionAvgAggregate>;
    @Field(() => PointTransactionSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof PointTransactionSumAggregate>;
    @Field(() => PointTransactionMinAggregate, {nullable:true})
    _min?: InstanceType<typeof PointTransactionMinAggregate>;
    @Field(() => PointTransactionMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof PointTransactionMaxAggregate>;
}

@ArgsType()
export class CreateManyPointTransactionArgs {
    @Field(() => [PointTransactionCreateManyInput], {nullable:false})
    @Type(() => PointTransactionCreateManyInput)
    data!: Array<PointTransactionCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOnePointTransactionArgs {
    @Field(() => PointTransactionCreateInput, {nullable:false})
    @Type(() => PointTransactionCreateInput)
    data!: InstanceType<typeof PointTransactionCreateInput>;
}

@ArgsType()
export class DeleteManyPointTransactionArgs {
    @Field(() => PointTransactionWhereInput, {nullable:true})
    @Type(() => PointTransactionWhereInput)
    where?: InstanceType<typeof PointTransactionWhereInput>;
}

@ArgsType()
export class DeleteOnePointTransactionArgs {
    @Field(() => PointTransactionWhereUniqueInput, {nullable:false})
    @Type(() => PointTransactionWhereUniqueInput)
    where!: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstPointTransactionOrThrowArgs {
    @Field(() => PointTransactionWhereInput, {nullable:true})
    @Type(() => PointTransactionWhereInput)
    where?: InstanceType<typeof PointTransactionWhereInput>;
    @Field(() => [PointTransactionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PointTransactionOrderByWithRelationInput>;
    @Field(() => PointTransactionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [PointTransactionScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof PointTransactionScalarFieldEnum>;
}

@ArgsType()
export class FindFirstPointTransactionArgs {
    @Field(() => PointTransactionWhereInput, {nullable:true})
    @Type(() => PointTransactionWhereInput)
    where?: InstanceType<typeof PointTransactionWhereInput>;
    @Field(() => [PointTransactionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PointTransactionOrderByWithRelationInput>;
    @Field(() => PointTransactionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [PointTransactionScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof PointTransactionScalarFieldEnum>;
}

@ArgsType()
export class FindManyPointTransactionArgs {
    @Field(() => PointTransactionWhereInput, {nullable:true})
    @Type(() => PointTransactionWhereInput)
    where?: InstanceType<typeof PointTransactionWhereInput>;
    @Field(() => [PointTransactionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PointTransactionOrderByWithRelationInput>;
    @Field(() => PointTransactionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [PointTransactionScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof PointTransactionScalarFieldEnum>;
}

@ArgsType()
export class FindUniquePointTransactionOrThrowArgs {
    @Field(() => PointTransactionWhereUniqueInput, {nullable:false})
    @Type(() => PointTransactionWhereUniqueInput)
    where!: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniquePointTransactionArgs {
    @Field(() => PointTransactionWhereUniqueInput, {nullable:false})
    @Type(() => PointTransactionWhereUniqueInput)
    where!: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
}

@ArgsType()
export class PointTransactionAggregateArgs {
    @Field(() => PointTransactionWhereInput, {nullable:true})
    @Type(() => PointTransactionWhereInput)
    where?: InstanceType<typeof PointTransactionWhereInput>;
    @Field(() => [PointTransactionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<PointTransactionOrderByWithRelationInput>;
    @Field(() => PointTransactionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => PointTransactionCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof PointTransactionCountAggregateInput>;
    @Field(() => PointTransactionAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof PointTransactionAvgAggregateInput>;
    @Field(() => PointTransactionSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof PointTransactionSumAggregateInput>;
    @Field(() => PointTransactionMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof PointTransactionMinAggregateInput>;
    @Field(() => PointTransactionMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof PointTransactionMaxAggregateInput>;
}

@InputType()
export class PointTransactionAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    currentBalance?: true;
}

@ObjectType()
export class PointTransactionAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
}

@InputType()
export class PointTransactionAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
}

@InputType()
export class PointTransactionCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    pointType?: true;
    @Field(() => Boolean, {nullable:true})
    transactionType?: true;
    @Field(() => Boolean, {nullable:true})
    currentBalance?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class PointTransactionCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    amount!: number;
    @Field(() => Int, {nullable:false})
    pointType!: number;
    @Field(() => Int, {nullable:false})
    transactionType!: number;
    @Field(() => Int, {nullable:false})
    currentBalance!: number;
    @Field(() => Int, {nullable:false})
    userId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class PointTransactionCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class PointTransactionCreateManyUserInputEnvelope {
    @Field(() => [PointTransactionCreateManyUserInput], {nullable:false})
    @Type(() => PointTransactionCreateManyUserInput)
    data!: Array<PointTransactionCreateManyUserInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class PointTransactionCreateManyUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => PointType, {nullable:false})
    pointType!: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class PointTransactionCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => PointType, {nullable:false})
    pointType!: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class PointTransactionCreateNestedManyWithoutUserInput {
    @Field(() => [PointTransactionCreateWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionCreateWithoutUserInput)
    create?: Array<PointTransactionCreateWithoutUserInput>;
    @Field(() => [PointTransactionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<PointTransactionCreateOrConnectWithoutUserInput>;
    @Field(() => PointTransactionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => PointTransactionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof PointTransactionCreateManyUserInputEnvelope>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
}

@InputType()
export class PointTransactionCreateOrConnectWithoutUserInput {
    @Field(() => PointTransactionWhereUniqueInput, {nullable:false})
    @Type(() => PointTransactionWhereUniqueInput)
    where!: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
    @Field(() => PointTransactionCreateWithoutUserInput, {nullable:false})
    @Type(() => PointTransactionCreateWithoutUserInput)
    create!: InstanceType<typeof PointTransactionCreateWithoutUserInput>;
}

@InputType()
export class PointTransactionCreateWithoutUserInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => PointType, {nullable:false})
    pointType!: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class PointTransactionCreateInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => PointType, {nullable:false})
    pointType!: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutPointTransactionsInput, {nullable:false})
    User!: InstanceType<typeof UserCreateNestedOneWithoutPointTransactionsInput>;
}

@ArgsType()
export class PointTransactionGroupByArgs {
    @Field(() => PointTransactionWhereInput, {nullable:true})
    @Type(() => PointTransactionWhereInput)
    where?: InstanceType<typeof PointTransactionWhereInput>;
    @Field(() => [PointTransactionOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<PointTransactionOrderByWithAggregationInput>;
    @Field(() => [PointTransactionScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof PointTransactionScalarFieldEnum>;
    @Field(() => PointTransactionScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof PointTransactionScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => PointTransactionCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof PointTransactionCountAggregateInput>;
    @Field(() => PointTransactionAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof PointTransactionAvgAggregateInput>;
    @Field(() => PointTransactionSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof PointTransactionSumAggregateInput>;
    @Field(() => PointTransactionMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof PointTransactionMinAggregateInput>;
    @Field(() => PointTransactionMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof PointTransactionMaxAggregateInput>;
}

@ObjectType()
export class PointTransactionGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => PointType, {nullable:false})
    pointType!: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => Float, {nullable:false})
    currentBalance!: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => PointTransactionCountAggregate, {nullable:true})
    _count?: InstanceType<typeof PointTransactionCountAggregate>;
    @Field(() => PointTransactionAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof PointTransactionAvgAggregate>;
    @Field(() => PointTransactionSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof PointTransactionSumAggregate>;
    @Field(() => PointTransactionMinAggregate, {nullable:true})
    _min?: InstanceType<typeof PointTransactionMinAggregate>;
    @Field(() => PointTransactionMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof PointTransactionMaxAggregate>;
}

@InputType()
export class PointTransactionListRelationFilter {
    @Field(() => PointTransactionWhereInput, {nullable:true})
    every?: InstanceType<typeof PointTransactionWhereInput>;
    @Field(() => PointTransactionWhereInput, {nullable:true})
    some?: InstanceType<typeof PointTransactionWhereInput>;
    @Field(() => PointTransactionWhereInput, {nullable:true})
    none?: InstanceType<typeof PointTransactionWhereInput>;
}

@InputType()
export class PointTransactionMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    pointType?: true;
    @Field(() => Boolean, {nullable:true})
    transactionType?: true;
    @Field(() => Boolean, {nullable:true})
    currentBalance?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
}

@ObjectType()
export class PointTransactionMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => PointType, {nullable:true})
    pointType?: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:true})
    transactionType?: keyof typeof TransactionType;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class PointTransactionMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class PointTransactionMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    pointType?: true;
    @Field(() => Boolean, {nullable:true})
    transactionType?: true;
    @Field(() => Boolean, {nullable:true})
    currentBalance?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
}

@ObjectType()
export class PointTransactionMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => PointType, {nullable:true})
    pointType?: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:true})
    transactionType?: keyof typeof TransactionType;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class PointTransactionMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class PointTransactionOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class PointTransactionOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => PointTransactionCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof PointTransactionCountOrderByAggregateInput>;
    @Field(() => PointTransactionAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof PointTransactionAvgOrderByAggregateInput>;
    @Field(() => PointTransactionMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof PointTransactionMaxOrderByAggregateInput>;
    @Field(() => PointTransactionMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof PointTransactionMinOrderByAggregateInput>;
    @Field(() => PointTransactionSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof PointTransactionSumOrderByAggregateInput>;
}

@InputType()
export class PointTransactionOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    User?: InstanceType<typeof UserOrderByWithRelationInput>;
}

@InputType()
export class PointTransactionScalarWhereWithAggregatesInput {
    @Field(() => [PointTransactionScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<PointTransactionScalarWhereWithAggregatesInput>;
    @Field(() => [PointTransactionScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<PointTransactionScalarWhereWithAggregatesInput>;
    @Field(() => [PointTransactionScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<PointTransactionScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    amount?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => EnumPointTypeWithAggregatesFilter, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeWithAggregatesFilter>;
    @Field(() => EnumTransactionTypeWithAggregatesFilter, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    currentBalance?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    userId?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class PointTransactionScalarWhereInput {
    @Field(() => [PointTransactionScalarWhereInput], {nullable:true})
    AND?: Array<PointTransactionScalarWhereInput>;
    @Field(() => [PointTransactionScalarWhereInput], {nullable:true})
    OR?: Array<PointTransactionScalarWhereInput>;
    @Field(() => [PointTransactionScalarWhereInput], {nullable:true})
    NOT?: Array<PointTransactionScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @Field(() => EnumPointTypeFilter, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFilter>;
    @Field(() => EnumTransactionTypeFilter, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class PointTransactionSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    currentBalance?: true;
}

@ObjectType()
export class PointTransactionSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
}

@InputType()
export class PointTransactionSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    currentBalance?: keyof typeof SortOrder;
}

@InputType()
export class PointTransactionUncheckedCreateNestedManyWithoutUserInput {
    @Field(() => [PointTransactionCreateWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionCreateWithoutUserInput)
    create?: Array<PointTransactionCreateWithoutUserInput>;
    @Field(() => [PointTransactionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<PointTransactionCreateOrConnectWithoutUserInput>;
    @Field(() => PointTransactionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => PointTransactionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof PointTransactionCreateManyUserInputEnvelope>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
}

@InputType()
export class PointTransactionUncheckedCreateWithoutUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => PointType, {nullable:false})
    pointType!: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class PointTransactionUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => PointType, {nullable:false})
    pointType!: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => Float, {nullable:true})
    currentBalance?: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class PointTransactionUncheckedUpdateManyWithoutUserNestedInput {
    @Field(() => [PointTransactionCreateWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionCreateWithoutUserInput)
    create?: Array<PointTransactionCreateWithoutUserInput>;
    @Field(() => [PointTransactionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<PointTransactionCreateOrConnectWithoutUserInput>;
    @Field(() => [PointTransactionUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<PointTransactionUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => PointTransactionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => PointTransactionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof PointTransactionCreateManyUserInputEnvelope>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    set?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
    @Field(() => [PointTransactionUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<PointTransactionUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [PointTransactionUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<PointTransactionUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [PointTransactionScalarWhereInput], {nullable:true})
    @Type(() => PointTransactionScalarWhereInput)
    deleteMany?: Array<PointTransactionScalarWhereInput>;
}

@InputType()
export class PointTransactionUncheckedUpdateManyWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumPointTypeFieldUpdateOperationsInput, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PointTransactionUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumPointTypeFieldUpdateOperationsInput, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PointTransactionUncheckedUpdateWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumPointTypeFieldUpdateOperationsInput, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PointTransactionUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumPointTypeFieldUpdateOperationsInput, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PointTransactionUpdateManyMutationInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumPointTypeFieldUpdateOperationsInput, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PointTransactionUpdateManyWithWhereWithoutUserInput {
    @Field(() => PointTransactionScalarWhereInput, {nullable:false})
    @Type(() => PointTransactionScalarWhereInput)
    where!: InstanceType<typeof PointTransactionScalarWhereInput>;
    @Field(() => PointTransactionUpdateManyMutationInput, {nullable:false})
    @Type(() => PointTransactionUpdateManyMutationInput)
    data!: InstanceType<typeof PointTransactionUpdateManyMutationInput>;
}

@InputType()
export class PointTransactionUpdateManyWithoutUserNestedInput {
    @Field(() => [PointTransactionCreateWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionCreateWithoutUserInput)
    create?: Array<PointTransactionCreateWithoutUserInput>;
    @Field(() => [PointTransactionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<PointTransactionCreateOrConnectWithoutUserInput>;
    @Field(() => [PointTransactionUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<PointTransactionUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => PointTransactionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => PointTransactionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof PointTransactionCreateManyUserInputEnvelope>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    set?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
    @Field(() => [PointTransactionWhereUniqueInput], {nullable:true})
    @Type(() => PointTransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>>;
    @Field(() => [PointTransactionUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<PointTransactionUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [PointTransactionUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => PointTransactionUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<PointTransactionUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [PointTransactionScalarWhereInput], {nullable:true})
    @Type(() => PointTransactionScalarWhereInput)
    deleteMany?: Array<PointTransactionScalarWhereInput>;
}

@InputType()
export class PointTransactionUpdateWithWhereUniqueWithoutUserInput {
    @Field(() => PointTransactionWhereUniqueInput, {nullable:false})
    @Type(() => PointTransactionWhereUniqueInput)
    where!: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
    @Field(() => PointTransactionUpdateWithoutUserInput, {nullable:false})
    @Type(() => PointTransactionUpdateWithoutUserInput)
    data!: InstanceType<typeof PointTransactionUpdateWithoutUserInput>;
}

@InputType()
export class PointTransactionUpdateWithoutUserInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumPointTypeFieldUpdateOperationsInput, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class PointTransactionUpdateInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumPointTypeFieldUpdateOperationsInput, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionTypeFieldUpdateOperationsInput, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutPointTransactionsNestedInput, {nullable:true})
    User?: InstanceType<typeof UserUpdateOneRequiredWithoutPointTransactionsNestedInput>;
}

@InputType()
export class PointTransactionUpsertWithWhereUniqueWithoutUserInput {
    @Field(() => PointTransactionWhereUniqueInput, {nullable:false})
    @Type(() => PointTransactionWhereUniqueInput)
    where!: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
    @Field(() => PointTransactionUpdateWithoutUserInput, {nullable:false})
    @Type(() => PointTransactionUpdateWithoutUserInput)
    update!: InstanceType<typeof PointTransactionUpdateWithoutUserInput>;
    @Field(() => PointTransactionCreateWithoutUserInput, {nullable:false})
    @Type(() => PointTransactionCreateWithoutUserInput)
    create!: InstanceType<typeof PointTransactionCreateWithoutUserInput>;
}

@InputType()
export class PointTransactionWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [PointTransactionWhereInput], {nullable:true})
    AND?: Array<PointTransactionWhereInput>;
    @Field(() => [PointTransactionWhereInput], {nullable:true})
    OR?: Array<PointTransactionWhereInput>;
    @Field(() => [PointTransactionWhereInput], {nullable:true})
    NOT?: Array<PointTransactionWhereInput>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @Field(() => EnumPointTypeFilter, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFilter>;
    @Field(() => EnumTransactionTypeFilter, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    User?: InstanceType<typeof UserRelationFilter>;
}

@InputType()
export class PointTransactionWhereInput {
    @Field(() => [PointTransactionWhereInput], {nullable:true})
    AND?: Array<PointTransactionWhereInput>;
    @Field(() => [PointTransactionWhereInput], {nullable:true})
    OR?: Array<PointTransactionWhereInput>;
    @Field(() => [PointTransactionWhereInput], {nullable:true})
    NOT?: Array<PointTransactionWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @Field(() => EnumPointTypeFilter, {nullable:true})
    pointType?: InstanceType<typeof EnumPointTypeFilter>;
    @Field(() => EnumTransactionTypeFilter, {nullable:true})
    transactionType?: InstanceType<typeof EnumTransactionTypeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    currentBalance?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    User?: InstanceType<typeof UserRelationFilter>;
}

@ObjectType()
export class PointTransaction {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => PointType, {nullable:false})
    pointType!: keyof typeof PointType;
    @Field(() => TransactionType, {nullable:false})
    transactionType!: keyof typeof TransactionType;
    @Field(() => Float, {nullable:false,defaultValue:0})
    currentBalance!: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => User, {nullable:false})
    User?: InstanceType<typeof User>;
}

@ArgsType()
export class UpdateManyPointTransactionArgs {
    @Field(() => PointTransactionUpdateManyMutationInput, {nullable:false})
    @Type(() => PointTransactionUpdateManyMutationInput)
    data!: InstanceType<typeof PointTransactionUpdateManyMutationInput>;
    @Field(() => PointTransactionWhereInput, {nullable:true})
    @Type(() => PointTransactionWhereInput)
    where?: InstanceType<typeof PointTransactionWhereInput>;
}

@ArgsType()
export class UpdateOnePointTransactionArgs {
    @Field(() => PointTransactionUpdateInput, {nullable:false})
    @Type(() => PointTransactionUpdateInput)
    data!: InstanceType<typeof PointTransactionUpdateInput>;
    @Field(() => PointTransactionWhereUniqueInput, {nullable:false})
    @Type(() => PointTransactionWhereUniqueInput)
    where!: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOnePointTransactionArgs {
    @Field(() => PointTransactionWhereUniqueInput, {nullable:false})
    @Type(() => PointTransactionWhereUniqueInput)
    where!: Prisma.AtLeast<PointTransactionWhereUniqueInput, 'id'>;
    @Field(() => PointTransactionCreateInput, {nullable:false})
    @Type(() => PointTransactionCreateInput)
    create!: InstanceType<typeof PointTransactionCreateInput>;
    @Field(() => PointTransactionUpdateInput, {nullable:false})
    @Type(() => PointTransactionUpdateInput)
    update!: InstanceType<typeof PointTransactionUpdateInput>;
}

@ObjectType()
export class AffectedRows {
    @Field(() => Int, {nullable:false})
    count!: number;
}

@InputType()
export class BoolFieldUpdateOperationsInput {
    @Field(() => Boolean, {nullable:true})
    set?: boolean;
}

@InputType()
export class BoolFilter {
    @Field(() => Boolean, {nullable:true})
    equals?: boolean;
    @Field(() => NestedBoolFilter, {nullable:true})
    not?: InstanceType<typeof NestedBoolFilter>;
}

@InputType()
export class BoolWithAggregatesFilter {
    @Field(() => Boolean, {nullable:true})
    equals?: boolean;
    @Field(() => NestedBoolWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedBoolWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedBoolFilter, {nullable:true})
    _min?: InstanceType<typeof NestedBoolFilter>;
    @Field(() => NestedBoolFilter, {nullable:true})
    _max?: InstanceType<typeof NestedBoolFilter>;
}

@InputType()
export class DateTimeFieldUpdateOperationsInput {
    @Field(() => Date, {nullable:true})
    set?: Date | string;
}

@InputType()
export class DateTimeFilter {
    @Field(() => Date, {nullable:true})
    equals?: Date | string;
    @Field(() => [Date], {nullable:true})
    in?: Array<Date> | Array<string>;
    @Field(() => [Date], {nullable:true})
    notIn?: Array<Date> | Array<string>;
    @Field(() => Date, {nullable:true})
    lt?: Date | string;
    @Field(() => Date, {nullable:true})
    lte?: Date | string;
    @Field(() => Date, {nullable:true})
    gt?: Date | string;
    @Field(() => Date, {nullable:true})
    gte?: Date | string;
    @Field(() => NestedDateTimeFilter, {nullable:true})
    not?: InstanceType<typeof NestedDateTimeFilter>;
}

@InputType()
export class DateTimeNullableFilter {
    @Field(() => Date, {nullable:true})
    equals?: Date | string;
    @Field(() => [Date], {nullable:true})
    in?: Array<Date> | Array<string>;
    @Field(() => [Date], {nullable:true})
    notIn?: Array<Date> | Array<string>;
    @Field(() => Date, {nullable:true})
    lt?: Date | string;
    @Field(() => Date, {nullable:true})
    lte?: Date | string;
    @Field(() => Date, {nullable:true})
    gt?: Date | string;
    @Field(() => Date, {nullable:true})
    gte?: Date | string;
    @Field(() => NestedDateTimeNullableFilter, {nullable:true})
    not?: InstanceType<typeof NestedDateTimeNullableFilter>;
}

@InputType()
export class DateTimeNullableWithAggregatesFilter {
    @Field(() => Date, {nullable:true})
    equals?: Date | string;
    @Field(() => [Date], {nullable:true})
    in?: Array<Date> | Array<string>;
    @Field(() => [Date], {nullable:true})
    notIn?: Array<Date> | Array<string>;
    @Field(() => Date, {nullable:true})
    lt?: Date | string;
    @Field(() => Date, {nullable:true})
    lte?: Date | string;
    @Field(() => Date, {nullable:true})
    gt?: Date | string;
    @Field(() => Date, {nullable:true})
    gte?: Date | string;
    @Field(() => NestedDateTimeNullableWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedDateTimeNullableWithAggregatesFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedDateTimeNullableFilter, {nullable:true})
    _min?: InstanceType<typeof NestedDateTimeNullableFilter>;
    @Field(() => NestedDateTimeNullableFilter, {nullable:true})
    _max?: InstanceType<typeof NestedDateTimeNullableFilter>;
}

@InputType()
export class DateTimeWithAggregatesFilter {
    @Field(() => Date, {nullable:true})
    equals?: Date | string;
    @Field(() => [Date], {nullable:true})
    in?: Array<Date> | Array<string>;
    @Field(() => [Date], {nullable:true})
    notIn?: Array<Date> | Array<string>;
    @Field(() => Date, {nullable:true})
    lt?: Date | string;
    @Field(() => Date, {nullable:true})
    lte?: Date | string;
    @Field(() => Date, {nullable:true})
    gt?: Date | string;
    @Field(() => Date, {nullable:true})
    gte?: Date | string;
    @Field(() => NestedDateTimeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedDateTimeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedDateTimeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedDateTimeFilter>;
    @Field(() => NestedDateTimeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedDateTimeFilter>;
}

@InputType()
export class EnumAccountCategoryFieldUpdateOperationsInput {
    @Field(() => AccountCategory, {nullable:true})
    set?: keyof typeof AccountCategory;
}

@InputType()
export class EnumAccountCategoryFilter {
    @Field(() => AccountCategory, {nullable:true})
    equals?: keyof typeof AccountCategory;
    @Field(() => [AccountCategory], {nullable:true})
    in?: Array<keyof typeof AccountCategory>;
    @Field(() => [AccountCategory], {nullable:true})
    notIn?: Array<keyof typeof AccountCategory>;
    @Field(() => NestedEnumAccountCategoryFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumAccountCategoryFilter>;
}

@InputType()
export class EnumAccountCategoryWithAggregatesFilter {
    @Field(() => AccountCategory, {nullable:true})
    equals?: keyof typeof AccountCategory;
    @Field(() => [AccountCategory], {nullable:true})
    in?: Array<keyof typeof AccountCategory>;
    @Field(() => [AccountCategory], {nullable:true})
    notIn?: Array<keyof typeof AccountCategory>;
    @Field(() => NestedEnumAccountCategoryWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumAccountCategoryWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumAccountCategoryFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumAccountCategoryFilter>;
    @Field(() => NestedEnumAccountCategoryFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumAccountCategoryFilter>;
}

@InputType()
export class EnumFaqTypeFieldUpdateOperationsInput {
    @Field(() => FaqType, {nullable:true})
    set?: keyof typeof FaqType;
}

@InputType()
export class EnumFaqTypeFilter {
    @Field(() => FaqType, {nullable:true})
    equals?: keyof typeof FaqType;
    @Field(() => [FaqType], {nullable:true})
    in?: Array<keyof typeof FaqType>;
    @Field(() => [FaqType], {nullable:true})
    notIn?: Array<keyof typeof FaqType>;
    @Field(() => NestedEnumFaqTypeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumFaqTypeFilter>;
}

@InputType()
export class EnumFaqTypeWithAggregatesFilter {
    @Field(() => FaqType, {nullable:true})
    equals?: keyof typeof FaqType;
    @Field(() => [FaqType], {nullable:true})
    in?: Array<keyof typeof FaqType>;
    @Field(() => [FaqType], {nullable:true})
    notIn?: Array<keyof typeof FaqType>;
    @Field(() => NestedEnumFaqTypeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumFaqTypeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumFaqTypeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumFaqTypeFilter>;
    @Field(() => NestedEnumFaqTypeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumFaqTypeFilter>;
}

@InputType()
export class EnumFileTypeFieldUpdateOperationsInput {
    @Field(() => FileType, {nullable:true})
    set?: keyof typeof FileType;
}

@InputType()
export class EnumFileTypeFilter {
    @Field(() => FileType, {nullable:true})
    equals?: keyof typeof FileType;
    @Field(() => [FileType], {nullable:true})
    in?: Array<keyof typeof FileType>;
    @Field(() => [FileType], {nullable:true})
    notIn?: Array<keyof typeof FileType>;
    @Field(() => NestedEnumFileTypeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumFileTypeFilter>;
}

@InputType()
export class EnumFileTypeWithAggregatesFilter {
    @Field(() => FileType, {nullable:true})
    equals?: keyof typeof FileType;
    @Field(() => [FileType], {nullable:true})
    in?: Array<keyof typeof FileType>;
    @Field(() => [FileType], {nullable:true})
    notIn?: Array<keyof typeof FileType>;
    @Field(() => NestedEnumFileTypeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumFileTypeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumFileTypeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumFileTypeFilter>;
    @Field(() => NestedEnumFileTypeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumFileTypeFilter>;
}

@InputType()
export class EnumInstallmentStatusFieldUpdateOperationsInput {
    @Field(() => InstallmentStatus, {nullable:true})
    set?: keyof typeof InstallmentStatus;
}

@InputType()
export class EnumInstallmentStatusFilter {
    @Field(() => InstallmentStatus, {nullable:true})
    equals?: keyof typeof InstallmentStatus;
    @Field(() => [InstallmentStatus], {nullable:true})
    in?: Array<keyof typeof InstallmentStatus>;
    @Field(() => [InstallmentStatus], {nullable:true})
    notIn?: Array<keyof typeof InstallmentStatus>;
    @Field(() => NestedEnumInstallmentStatusFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumInstallmentStatusFilter>;
}

@InputType()
export class EnumInstallmentStatusWithAggregatesFilter {
    @Field(() => InstallmentStatus, {nullable:true})
    equals?: keyof typeof InstallmentStatus;
    @Field(() => [InstallmentStatus], {nullable:true})
    in?: Array<keyof typeof InstallmentStatus>;
    @Field(() => [InstallmentStatus], {nullable:true})
    notIn?: Array<keyof typeof InstallmentStatus>;
    @Field(() => NestedEnumInstallmentStatusWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumInstallmentStatusWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumInstallmentStatusFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumInstallmentStatusFilter>;
    @Field(() => NestedEnumInstallmentStatusFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumInstallmentStatusFilter>;
}

@InputType()
export class EnumPointTypeFieldUpdateOperationsInput {
    @Field(() => PointType, {nullable:true})
    set?: keyof typeof PointType;
}

@InputType()
export class EnumPointTypeFilter {
    @Field(() => PointType, {nullable:true})
    equals?: keyof typeof PointType;
    @Field(() => [PointType], {nullable:true})
    in?: Array<keyof typeof PointType>;
    @Field(() => [PointType], {nullable:true})
    notIn?: Array<keyof typeof PointType>;
    @Field(() => NestedEnumPointTypeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumPointTypeFilter>;
}

@InputType()
export class EnumPointTypeWithAggregatesFilter {
    @Field(() => PointType, {nullable:true})
    equals?: keyof typeof PointType;
    @Field(() => [PointType], {nullable:true})
    in?: Array<keyof typeof PointType>;
    @Field(() => [PointType], {nullable:true})
    notIn?: Array<keyof typeof PointType>;
    @Field(() => NestedEnumPointTypeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumPointTypeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumPointTypeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumPointTypeFilter>;
    @Field(() => NestedEnumPointTypeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumPointTypeFilter>;
}

@InputType()
export class EnumProjectCategoryFieldUpdateOperationsInput {
    @Field(() => ProjectCategory, {nullable:true})
    set?: keyof typeof ProjectCategory;
}

@InputType()
export class EnumProjectCategoryFilter {
    @Field(() => ProjectCategory, {nullable:true})
    equals?: keyof typeof ProjectCategory;
    @Field(() => [ProjectCategory], {nullable:true})
    in?: Array<keyof typeof ProjectCategory>;
    @Field(() => [ProjectCategory], {nullable:true})
    notIn?: Array<keyof typeof ProjectCategory>;
    @Field(() => NestedEnumProjectCategoryFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumProjectCategoryFilter>;
}

@InputType()
export class EnumProjectCategoryWithAggregatesFilter {
    @Field(() => ProjectCategory, {nullable:true})
    equals?: keyof typeof ProjectCategory;
    @Field(() => [ProjectCategory], {nullable:true})
    in?: Array<keyof typeof ProjectCategory>;
    @Field(() => [ProjectCategory], {nullable:true})
    notIn?: Array<keyof typeof ProjectCategory>;
    @Field(() => NestedEnumProjectCategoryWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumProjectCategoryWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumProjectCategoryFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumProjectCategoryFilter>;
    @Field(() => NestedEnumProjectCategoryFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumProjectCategoryFilter>;
}

@InputType()
export class EnumShippingStatusFieldUpdateOperationsInput {
    @Field(() => ShippingStatus, {nullable:true})
    set?: keyof typeof ShippingStatus;
}

@InputType()
export class EnumShippingStatusFilter {
    @Field(() => ShippingStatus, {nullable:true})
    equals?: keyof typeof ShippingStatus;
    @Field(() => [ShippingStatus], {nullable:true})
    in?: Array<keyof typeof ShippingStatus>;
    @Field(() => [ShippingStatus], {nullable:true})
    notIn?: Array<keyof typeof ShippingStatus>;
    @Field(() => NestedEnumShippingStatusFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumShippingStatusFilter>;
}

@InputType()
export class EnumShippingStatusWithAggregatesFilter {
    @Field(() => ShippingStatus, {nullable:true})
    equals?: keyof typeof ShippingStatus;
    @Field(() => [ShippingStatus], {nullable:true})
    in?: Array<keyof typeof ShippingStatus>;
    @Field(() => [ShippingStatus], {nullable:true})
    notIn?: Array<keyof typeof ShippingStatus>;
    @Field(() => NestedEnumShippingStatusWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumShippingStatusWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumShippingStatusFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumShippingStatusFilter>;
    @Field(() => NestedEnumShippingStatusFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumShippingStatusFilter>;
}

@InputType()
export class EnumThemeFieldUpdateOperationsInput {
    @Field(() => Theme, {nullable:true})
    set?: keyof typeof Theme;
}

@InputType()
export class EnumThemeFilter {
    @Field(() => Theme, {nullable:true})
    equals?: keyof typeof Theme;
    @Field(() => [Theme], {nullable:true})
    in?: Array<keyof typeof Theme>;
    @Field(() => [Theme], {nullable:true})
    notIn?: Array<keyof typeof Theme>;
    @Field(() => NestedEnumThemeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumThemeFilter>;
}

@InputType()
export class EnumThemeWithAggregatesFilter {
    @Field(() => Theme, {nullable:true})
    equals?: keyof typeof Theme;
    @Field(() => [Theme], {nullable:true})
    in?: Array<keyof typeof Theme>;
    @Field(() => [Theme], {nullable:true})
    notIn?: Array<keyof typeof Theme>;
    @Field(() => NestedEnumThemeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumThemeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumThemeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumThemeFilter>;
    @Field(() => NestedEnumThemeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumThemeFilter>;
}

@InputType()
export class EnumTransactionCategoryFieldUpdateOperationsInput {
    @Field(() => TransactionCategory, {nullable:true})
    set?: keyof typeof TransactionCategory;
}

@InputType()
export class EnumTransactionCategoryFilter {
    @Field(() => TransactionCategory, {nullable:true})
    equals?: keyof typeof TransactionCategory;
    @Field(() => [TransactionCategory], {nullable:true})
    in?: Array<keyof typeof TransactionCategory>;
    @Field(() => [TransactionCategory], {nullable:true})
    notIn?: Array<keyof typeof TransactionCategory>;
    @Field(() => NestedEnumTransactionCategoryFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionCategoryFilter>;
}

@InputType()
export class EnumTransactionCategoryWithAggregatesFilter {
    @Field(() => TransactionCategory, {nullable:true})
    equals?: keyof typeof TransactionCategory;
    @Field(() => [TransactionCategory], {nullable:true})
    in?: Array<keyof typeof TransactionCategory>;
    @Field(() => [TransactionCategory], {nullable:true})
    notIn?: Array<keyof typeof TransactionCategory>;
    @Field(() => NestedEnumTransactionCategoryWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionCategoryWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumTransactionCategoryFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumTransactionCategoryFilter>;
    @Field(() => NestedEnumTransactionCategoryFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumTransactionCategoryFilter>;
}

@InputType()
export class EnumTransactionStatusFieldUpdateOperationsInput {
    @Field(() => TransactionStatus, {nullable:true})
    set?: keyof typeof TransactionStatus;
}

@InputType()
export class EnumTransactionStatusFilter {
    @Field(() => TransactionStatus, {nullable:true})
    equals?: keyof typeof TransactionStatus;
    @Field(() => [TransactionStatus], {nullable:true})
    in?: Array<keyof typeof TransactionStatus>;
    @Field(() => [TransactionStatus], {nullable:true})
    notIn?: Array<keyof typeof TransactionStatus>;
    @Field(() => NestedEnumTransactionStatusFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionStatusFilter>;
}

@InputType()
export class EnumTransactionStatusWithAggregatesFilter {
    @Field(() => TransactionStatus, {nullable:true})
    equals?: keyof typeof TransactionStatus;
    @Field(() => [TransactionStatus], {nullable:true})
    in?: Array<keyof typeof TransactionStatus>;
    @Field(() => [TransactionStatus], {nullable:true})
    notIn?: Array<keyof typeof TransactionStatus>;
    @Field(() => NestedEnumTransactionStatusWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionStatusWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumTransactionStatusFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumTransactionStatusFilter>;
    @Field(() => NestedEnumTransactionStatusFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumTransactionStatusFilter>;
}

@InputType()
export class EnumTransactionTypeFieldUpdateOperationsInput {
    @Field(() => TransactionType, {nullable:true})
    set?: keyof typeof TransactionType;
}

@InputType()
export class EnumTransactionTypeFilter {
    @Field(() => TransactionType, {nullable:true})
    equals?: keyof typeof TransactionType;
    @Field(() => [TransactionType], {nullable:true})
    in?: Array<keyof typeof TransactionType>;
    @Field(() => [TransactionType], {nullable:true})
    notIn?: Array<keyof typeof TransactionType>;
    @Field(() => NestedEnumTransactionTypeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionTypeFilter>;
}

@InputType()
export class EnumTransactionTypeWithAggregatesFilter {
    @Field(() => TransactionType, {nullable:true})
    equals?: keyof typeof TransactionType;
    @Field(() => [TransactionType], {nullable:true})
    in?: Array<keyof typeof TransactionType>;
    @Field(() => [TransactionType], {nullable:true})
    notIn?: Array<keyof typeof TransactionType>;
    @Field(() => NestedEnumTransactionTypeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionTypeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumTransactionTypeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumTransactionTypeFilter>;
    @Field(() => NestedEnumTransactionTypeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumTransactionTypeFilter>;
}

@InputType()
export class EnumUserNotificationCategoryFieldUpdateOperationsInput {
    @Field(() => UserNotificationCategory, {nullable:true})
    set?: keyof typeof UserNotificationCategory;
}

@InputType()
export class EnumUserNotificationCategoryFilter {
    @Field(() => UserNotificationCategory, {nullable:true})
    equals?: keyof typeof UserNotificationCategory;
    @Field(() => [UserNotificationCategory], {nullable:true})
    in?: Array<keyof typeof UserNotificationCategory>;
    @Field(() => [UserNotificationCategory], {nullable:true})
    notIn?: Array<keyof typeof UserNotificationCategory>;
    @Field(() => NestedEnumUserNotificationCategoryFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserNotificationCategoryFilter>;
}

@InputType()
export class EnumUserNotificationCategoryWithAggregatesFilter {
    @Field(() => UserNotificationCategory, {nullable:true})
    equals?: keyof typeof UserNotificationCategory;
    @Field(() => [UserNotificationCategory], {nullable:true})
    in?: Array<keyof typeof UserNotificationCategory>;
    @Field(() => [UserNotificationCategory], {nullable:true})
    notIn?: Array<keyof typeof UserNotificationCategory>;
    @Field(() => NestedEnumUserNotificationCategoryWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserNotificationCategoryWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumUserNotificationCategoryFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumUserNotificationCategoryFilter>;
    @Field(() => NestedEnumUserNotificationCategoryFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumUserNotificationCategoryFilter>;
}

@InputType()
export class EnumUserRoleFieldUpdateOperationsInput {
    @Field(() => UserRole, {nullable:true})
    set?: keyof typeof UserRole;
}

@InputType()
export class EnumUserRoleFilter {
    @Field(() => UserRole, {nullable:true})
    equals?: keyof typeof UserRole;
    @Field(() => [UserRole], {nullable:true})
    in?: Array<keyof typeof UserRole>;
    @Field(() => [UserRole], {nullable:true})
    notIn?: Array<keyof typeof UserRole>;
    @Field(() => NestedEnumUserRoleFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserRoleFilter>;
}

@InputType()
export class EnumUserRoleWithAggregatesFilter {
    @Field(() => UserRole, {nullable:true})
    equals?: keyof typeof UserRole;
    @Field(() => [UserRole], {nullable:true})
    in?: Array<keyof typeof UserRole>;
    @Field(() => [UserRole], {nullable:true})
    notIn?: Array<keyof typeof UserRole>;
    @Field(() => NestedEnumUserRoleWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserRoleWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumUserRoleFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumUserRoleFilter>;
    @Field(() => NestedEnumUserRoleFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumUserRoleFilter>;
}

@InputType()
export class EnumUserStatusFieldUpdateOperationsInput {
    @Field(() => UserStatus, {nullable:true})
    set?: keyof typeof UserStatus;
}

@InputType()
export class EnumUserStatusFilter {
    @Field(() => UserStatus, {nullable:true})
    equals?: keyof typeof UserStatus;
    @Field(() => [UserStatus], {nullable:true})
    in?: Array<keyof typeof UserStatus>;
    @Field(() => [UserStatus], {nullable:true})
    notIn?: Array<keyof typeof UserStatus>;
    @Field(() => NestedEnumUserStatusFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserStatusFilter>;
}

@InputType()
export class EnumUserStatusWithAggregatesFilter {
    @Field(() => UserStatus, {nullable:true})
    equals?: keyof typeof UserStatus;
    @Field(() => [UserStatus], {nullable:true})
    in?: Array<keyof typeof UserStatus>;
    @Field(() => [UserStatus], {nullable:true})
    notIn?: Array<keyof typeof UserStatus>;
    @Field(() => NestedEnumUserStatusWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserStatusWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumUserStatusFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumUserStatusFilter>;
    @Field(() => NestedEnumUserStatusFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumUserStatusFilter>;
}

@InputType()
export class EnumUserTypeFieldUpdateOperationsInput {
    @Field(() => UserType, {nullable:true})
    set?: keyof typeof UserType;
}

@InputType()
export class EnumUserTypeFilter {
    @Field(() => UserType, {nullable:true})
    equals?: keyof typeof UserType;
    @Field(() => [UserType], {nullable:true})
    in?: Array<keyof typeof UserType>;
    @Field(() => [UserType], {nullable:true})
    notIn?: Array<keyof typeof UserType>;
    @Field(() => NestedEnumUserTypeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserTypeFilter>;
}

@InputType()
export class EnumUserTypeWithAggregatesFilter {
    @Field(() => UserType, {nullable:true})
    equals?: keyof typeof UserType;
    @Field(() => [UserType], {nullable:true})
    in?: Array<keyof typeof UserType>;
    @Field(() => [UserType], {nullable:true})
    notIn?: Array<keyof typeof UserType>;
    @Field(() => NestedEnumUserTypeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserTypeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumUserTypeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumUserTypeFilter>;
    @Field(() => NestedEnumUserTypeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumUserTypeFilter>;
}

@InputType()
export class FloatFieldUpdateOperationsInput {
    @Field(() => Float, {nullable:true})
    set?: number;
    @Field(() => Float, {nullable:true})
    increment?: number;
    @Field(() => Float, {nullable:true})
    decrement?: number;
    @Field(() => Float, {nullable:true})
    multiply?: number;
    @Field(() => Float, {nullable:true})
    divide?: number;
}

@InputType()
export class FloatFilter {
    @Field(() => Float, {nullable:true})
    equals?: number;
    @Field(() => [Float], {nullable:true})
    in?: Array<number>;
    @Field(() => [Float], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Float, {nullable:true})
    lt?: number;
    @Field(() => Float, {nullable:true})
    lte?: number;
    @Field(() => Float, {nullable:true})
    gt?: number;
    @Field(() => Float, {nullable:true})
    gte?: number;
    @Field(() => NestedFloatFilter, {nullable:true})
    not?: InstanceType<typeof NestedFloatFilter>;
}

@InputType()
export class FloatNullableFilter {
    @Field(() => Float, {nullable:true})
    equals?: number;
    @Field(() => [Float], {nullable:true})
    in?: Array<number>;
    @Field(() => [Float], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Float, {nullable:true})
    lt?: number;
    @Field(() => Float, {nullable:true})
    lte?: number;
    @Field(() => Float, {nullable:true})
    gt?: number;
    @Field(() => Float, {nullable:true})
    gte?: number;
    @Field(() => NestedFloatNullableFilter, {nullable:true})
    not?: InstanceType<typeof NestedFloatNullableFilter>;
}

@InputType()
export class FloatNullableWithAggregatesFilter {
    @Field(() => Float, {nullable:true})
    equals?: number;
    @Field(() => [Float], {nullable:true})
    in?: Array<number>;
    @Field(() => [Float], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Float, {nullable:true})
    lt?: number;
    @Field(() => Float, {nullable:true})
    lte?: number;
    @Field(() => Float, {nullable:true})
    gt?: number;
    @Field(() => Float, {nullable:true})
    gte?: number;
    @Field(() => NestedFloatNullableWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedFloatNullableWithAggregatesFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedFloatNullableFilter, {nullable:true})
    _avg?: InstanceType<typeof NestedFloatNullableFilter>;
    @Field(() => NestedFloatNullableFilter, {nullable:true})
    _sum?: InstanceType<typeof NestedFloatNullableFilter>;
    @Field(() => NestedFloatNullableFilter, {nullable:true})
    _min?: InstanceType<typeof NestedFloatNullableFilter>;
    @Field(() => NestedFloatNullableFilter, {nullable:true})
    _max?: InstanceType<typeof NestedFloatNullableFilter>;
}

@InputType()
export class FloatWithAggregatesFilter {
    @Field(() => Float, {nullable:true})
    equals?: number;
    @Field(() => [Float], {nullable:true})
    in?: Array<number>;
    @Field(() => [Float], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Float, {nullable:true})
    lt?: number;
    @Field(() => Float, {nullable:true})
    lte?: number;
    @Field(() => Float, {nullable:true})
    gt?: number;
    @Field(() => Float, {nullable:true})
    gte?: number;
    @Field(() => NestedFloatWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedFloatWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _avg?: InstanceType<typeof NestedFloatFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _sum?: InstanceType<typeof NestedFloatFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _min?: InstanceType<typeof NestedFloatFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _max?: InstanceType<typeof NestedFloatFilter>;
}

@InputType()
export class IntFieldUpdateOperationsInput {
    @Field(() => Int, {nullable:true})
    set?: number;
    @Field(() => Int, {nullable:true})
    increment?: number;
    @Field(() => Int, {nullable:true})
    decrement?: number;
    @Field(() => Int, {nullable:true})
    multiply?: number;
    @Field(() => Int, {nullable:true})
    divide?: number;
}

@InputType()
export class IntFilter {
    @Field(() => Int, {nullable:true})
    equals?: number;
    @Field(() => [Int], {nullable:true})
    in?: Array<number>;
    @Field(() => [Int], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Int, {nullable:true})
    lt?: number;
    @Field(() => Int, {nullable:true})
    lte?: number;
    @Field(() => Int, {nullable:true})
    gt?: number;
    @Field(() => Int, {nullable:true})
    gte?: number;
    @Field(() => NestedIntFilter, {nullable:true})
    not?: InstanceType<typeof NestedIntFilter>;
}

@InputType()
export class IntNullableFilter {
    @Field(() => Int, {nullable:true})
    equals?: number;
    @Field(() => [Int], {nullable:true})
    in?: Array<number>;
    @Field(() => [Int], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Int, {nullable:true})
    lt?: number;
    @Field(() => Int, {nullable:true})
    lte?: number;
    @Field(() => Int, {nullable:true})
    gt?: number;
    @Field(() => Int, {nullable:true})
    gte?: number;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    not?: InstanceType<typeof NestedIntNullableFilter>;
}

@InputType()
export class IntNullableWithAggregatesFilter {
    @Field(() => Int, {nullable:true})
    equals?: number;
    @Field(() => [Int], {nullable:true})
    in?: Array<number>;
    @Field(() => [Int], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Int, {nullable:true})
    lt?: number;
    @Field(() => Int, {nullable:true})
    lte?: number;
    @Field(() => Int, {nullable:true})
    gt?: number;
    @Field(() => Int, {nullable:true})
    gte?: number;
    @Field(() => NestedIntNullableWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedIntNullableWithAggregatesFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedFloatNullableFilter, {nullable:true})
    _avg?: InstanceType<typeof NestedFloatNullableFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _sum?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _min?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _max?: InstanceType<typeof NestedIntNullableFilter>;
}

@InputType()
export class IntWithAggregatesFilter {
    @Field(() => Int, {nullable:true})
    equals?: number;
    @Field(() => [Int], {nullable:true})
    in?: Array<number>;
    @Field(() => [Int], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Int, {nullable:true})
    lt?: number;
    @Field(() => Int, {nullable:true})
    lte?: number;
    @Field(() => Int, {nullable:true})
    gt?: number;
    @Field(() => Int, {nullable:true})
    gte?: number;
    @Field(() => NestedIntWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedIntWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _avg?: InstanceType<typeof NestedFloatFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _sum?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _min?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _max?: InstanceType<typeof NestedIntFilter>;
}

@InputType()
export class NestedBoolFilter {
    @Field(() => Boolean, {nullable:true})
    equals?: boolean;
    @Field(() => NestedBoolFilter, {nullable:true})
    not?: InstanceType<typeof NestedBoolFilter>;
}

@InputType()
export class NestedBoolWithAggregatesFilter {
    @Field(() => Boolean, {nullable:true})
    equals?: boolean;
    @Field(() => NestedBoolWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedBoolWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedBoolFilter, {nullable:true})
    _min?: InstanceType<typeof NestedBoolFilter>;
    @Field(() => NestedBoolFilter, {nullable:true})
    _max?: InstanceType<typeof NestedBoolFilter>;
}

@InputType()
export class NestedDateTimeFilter {
    @Field(() => Date, {nullable:true})
    equals?: Date | string;
    @Field(() => [Date], {nullable:true})
    in?: Array<Date> | Array<string>;
    @Field(() => [Date], {nullable:true})
    notIn?: Array<Date> | Array<string>;
    @Field(() => Date, {nullable:true})
    lt?: Date | string;
    @Field(() => Date, {nullable:true})
    lte?: Date | string;
    @Field(() => Date, {nullable:true})
    gt?: Date | string;
    @Field(() => Date, {nullable:true})
    gte?: Date | string;
    @Field(() => NestedDateTimeFilter, {nullable:true})
    not?: InstanceType<typeof NestedDateTimeFilter>;
}

@InputType()
export class NestedDateTimeNullableFilter {
    @Field(() => Date, {nullable:true})
    equals?: Date | string;
    @Field(() => [Date], {nullable:true})
    in?: Array<Date> | Array<string>;
    @Field(() => [Date], {nullable:true})
    notIn?: Array<Date> | Array<string>;
    @Field(() => Date, {nullable:true})
    lt?: Date | string;
    @Field(() => Date, {nullable:true})
    lte?: Date | string;
    @Field(() => Date, {nullable:true})
    gt?: Date | string;
    @Field(() => Date, {nullable:true})
    gte?: Date | string;
    @Field(() => NestedDateTimeNullableFilter, {nullable:true})
    not?: InstanceType<typeof NestedDateTimeNullableFilter>;
}

@InputType()
export class NestedDateTimeNullableWithAggregatesFilter {
    @Field(() => Date, {nullable:true})
    equals?: Date | string;
    @Field(() => [Date], {nullable:true})
    in?: Array<Date> | Array<string>;
    @Field(() => [Date], {nullable:true})
    notIn?: Array<Date> | Array<string>;
    @Field(() => Date, {nullable:true})
    lt?: Date | string;
    @Field(() => Date, {nullable:true})
    lte?: Date | string;
    @Field(() => Date, {nullable:true})
    gt?: Date | string;
    @Field(() => Date, {nullable:true})
    gte?: Date | string;
    @Field(() => NestedDateTimeNullableWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedDateTimeNullableWithAggregatesFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedDateTimeNullableFilter, {nullable:true})
    _min?: InstanceType<typeof NestedDateTimeNullableFilter>;
    @Field(() => NestedDateTimeNullableFilter, {nullable:true})
    _max?: InstanceType<typeof NestedDateTimeNullableFilter>;
}

@InputType()
export class NestedDateTimeWithAggregatesFilter {
    @Field(() => Date, {nullable:true})
    equals?: Date | string;
    @Field(() => [Date], {nullable:true})
    in?: Array<Date> | Array<string>;
    @Field(() => [Date], {nullable:true})
    notIn?: Array<Date> | Array<string>;
    @Field(() => Date, {nullable:true})
    lt?: Date | string;
    @Field(() => Date, {nullable:true})
    lte?: Date | string;
    @Field(() => Date, {nullable:true})
    gt?: Date | string;
    @Field(() => Date, {nullable:true})
    gte?: Date | string;
    @Field(() => NestedDateTimeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedDateTimeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedDateTimeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedDateTimeFilter>;
    @Field(() => NestedDateTimeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedDateTimeFilter>;
}

@InputType()
export class NestedEnumAccountCategoryFilter {
    @Field(() => AccountCategory, {nullable:true})
    equals?: keyof typeof AccountCategory;
    @Field(() => [AccountCategory], {nullable:true})
    in?: Array<keyof typeof AccountCategory>;
    @Field(() => [AccountCategory], {nullable:true})
    notIn?: Array<keyof typeof AccountCategory>;
    @Field(() => NestedEnumAccountCategoryFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumAccountCategoryFilter>;
}

@InputType()
export class NestedEnumAccountCategoryWithAggregatesFilter {
    @Field(() => AccountCategory, {nullable:true})
    equals?: keyof typeof AccountCategory;
    @Field(() => [AccountCategory], {nullable:true})
    in?: Array<keyof typeof AccountCategory>;
    @Field(() => [AccountCategory], {nullable:true})
    notIn?: Array<keyof typeof AccountCategory>;
    @Field(() => NestedEnumAccountCategoryWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumAccountCategoryWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumAccountCategoryFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumAccountCategoryFilter>;
    @Field(() => NestedEnumAccountCategoryFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumAccountCategoryFilter>;
}

@InputType()
export class NestedEnumFaqTypeFilter {
    @Field(() => FaqType, {nullable:true})
    equals?: keyof typeof FaqType;
    @Field(() => [FaqType], {nullable:true})
    in?: Array<keyof typeof FaqType>;
    @Field(() => [FaqType], {nullable:true})
    notIn?: Array<keyof typeof FaqType>;
    @Field(() => NestedEnumFaqTypeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumFaqTypeFilter>;
}

@InputType()
export class NestedEnumFaqTypeWithAggregatesFilter {
    @Field(() => FaqType, {nullable:true})
    equals?: keyof typeof FaqType;
    @Field(() => [FaqType], {nullable:true})
    in?: Array<keyof typeof FaqType>;
    @Field(() => [FaqType], {nullable:true})
    notIn?: Array<keyof typeof FaqType>;
    @Field(() => NestedEnumFaqTypeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumFaqTypeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumFaqTypeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumFaqTypeFilter>;
    @Field(() => NestedEnumFaqTypeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumFaqTypeFilter>;
}

@InputType()
export class NestedEnumFileTypeFilter {
    @Field(() => FileType, {nullable:true})
    equals?: keyof typeof FileType;
    @Field(() => [FileType], {nullable:true})
    in?: Array<keyof typeof FileType>;
    @Field(() => [FileType], {nullable:true})
    notIn?: Array<keyof typeof FileType>;
    @Field(() => NestedEnumFileTypeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumFileTypeFilter>;
}

@InputType()
export class NestedEnumFileTypeWithAggregatesFilter {
    @Field(() => FileType, {nullable:true})
    equals?: keyof typeof FileType;
    @Field(() => [FileType], {nullable:true})
    in?: Array<keyof typeof FileType>;
    @Field(() => [FileType], {nullable:true})
    notIn?: Array<keyof typeof FileType>;
    @Field(() => NestedEnumFileTypeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumFileTypeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumFileTypeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumFileTypeFilter>;
    @Field(() => NestedEnumFileTypeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumFileTypeFilter>;
}

@InputType()
export class NestedEnumInstallmentStatusFilter {
    @Field(() => InstallmentStatus, {nullable:true})
    equals?: keyof typeof InstallmentStatus;
    @Field(() => [InstallmentStatus], {nullable:true})
    in?: Array<keyof typeof InstallmentStatus>;
    @Field(() => [InstallmentStatus], {nullable:true})
    notIn?: Array<keyof typeof InstallmentStatus>;
    @Field(() => NestedEnumInstallmentStatusFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumInstallmentStatusFilter>;
}

@InputType()
export class NestedEnumInstallmentStatusWithAggregatesFilter {
    @Field(() => InstallmentStatus, {nullable:true})
    equals?: keyof typeof InstallmentStatus;
    @Field(() => [InstallmentStatus], {nullable:true})
    in?: Array<keyof typeof InstallmentStatus>;
    @Field(() => [InstallmentStatus], {nullable:true})
    notIn?: Array<keyof typeof InstallmentStatus>;
    @Field(() => NestedEnumInstallmentStatusWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumInstallmentStatusWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumInstallmentStatusFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumInstallmentStatusFilter>;
    @Field(() => NestedEnumInstallmentStatusFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumInstallmentStatusFilter>;
}

@InputType()
export class NestedEnumPointTypeFilter {
    @Field(() => PointType, {nullable:true})
    equals?: keyof typeof PointType;
    @Field(() => [PointType], {nullable:true})
    in?: Array<keyof typeof PointType>;
    @Field(() => [PointType], {nullable:true})
    notIn?: Array<keyof typeof PointType>;
    @Field(() => NestedEnumPointTypeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumPointTypeFilter>;
}

@InputType()
export class NestedEnumPointTypeWithAggregatesFilter {
    @Field(() => PointType, {nullable:true})
    equals?: keyof typeof PointType;
    @Field(() => [PointType], {nullable:true})
    in?: Array<keyof typeof PointType>;
    @Field(() => [PointType], {nullable:true})
    notIn?: Array<keyof typeof PointType>;
    @Field(() => NestedEnumPointTypeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumPointTypeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumPointTypeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumPointTypeFilter>;
    @Field(() => NestedEnumPointTypeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumPointTypeFilter>;
}

@InputType()
export class NestedEnumProjectCategoryFilter {
    @Field(() => ProjectCategory, {nullable:true})
    equals?: keyof typeof ProjectCategory;
    @Field(() => [ProjectCategory], {nullable:true})
    in?: Array<keyof typeof ProjectCategory>;
    @Field(() => [ProjectCategory], {nullable:true})
    notIn?: Array<keyof typeof ProjectCategory>;
    @Field(() => NestedEnumProjectCategoryFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumProjectCategoryFilter>;
}

@InputType()
export class NestedEnumProjectCategoryWithAggregatesFilter {
    @Field(() => ProjectCategory, {nullable:true})
    equals?: keyof typeof ProjectCategory;
    @Field(() => [ProjectCategory], {nullable:true})
    in?: Array<keyof typeof ProjectCategory>;
    @Field(() => [ProjectCategory], {nullable:true})
    notIn?: Array<keyof typeof ProjectCategory>;
    @Field(() => NestedEnumProjectCategoryWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumProjectCategoryWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumProjectCategoryFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumProjectCategoryFilter>;
    @Field(() => NestedEnumProjectCategoryFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumProjectCategoryFilter>;
}

@InputType()
export class NestedEnumShippingStatusFilter {
    @Field(() => ShippingStatus, {nullable:true})
    equals?: keyof typeof ShippingStatus;
    @Field(() => [ShippingStatus], {nullable:true})
    in?: Array<keyof typeof ShippingStatus>;
    @Field(() => [ShippingStatus], {nullable:true})
    notIn?: Array<keyof typeof ShippingStatus>;
    @Field(() => NestedEnumShippingStatusFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumShippingStatusFilter>;
}

@InputType()
export class NestedEnumShippingStatusWithAggregatesFilter {
    @Field(() => ShippingStatus, {nullable:true})
    equals?: keyof typeof ShippingStatus;
    @Field(() => [ShippingStatus], {nullable:true})
    in?: Array<keyof typeof ShippingStatus>;
    @Field(() => [ShippingStatus], {nullable:true})
    notIn?: Array<keyof typeof ShippingStatus>;
    @Field(() => NestedEnumShippingStatusWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumShippingStatusWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumShippingStatusFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumShippingStatusFilter>;
    @Field(() => NestedEnumShippingStatusFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumShippingStatusFilter>;
}

@InputType()
export class NestedEnumThemeFilter {
    @Field(() => Theme, {nullable:true})
    equals?: keyof typeof Theme;
    @Field(() => [Theme], {nullable:true})
    in?: Array<keyof typeof Theme>;
    @Field(() => [Theme], {nullable:true})
    notIn?: Array<keyof typeof Theme>;
    @Field(() => NestedEnumThemeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumThemeFilter>;
}

@InputType()
export class NestedEnumThemeWithAggregatesFilter {
    @Field(() => Theme, {nullable:true})
    equals?: keyof typeof Theme;
    @Field(() => [Theme], {nullable:true})
    in?: Array<keyof typeof Theme>;
    @Field(() => [Theme], {nullable:true})
    notIn?: Array<keyof typeof Theme>;
    @Field(() => NestedEnumThemeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumThemeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumThemeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumThemeFilter>;
    @Field(() => NestedEnumThemeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumThemeFilter>;
}

@InputType()
export class NestedEnumTransactionCategoryFilter {
    @Field(() => TransactionCategory, {nullable:true})
    equals?: keyof typeof TransactionCategory;
    @Field(() => [TransactionCategory], {nullable:true})
    in?: Array<keyof typeof TransactionCategory>;
    @Field(() => [TransactionCategory], {nullable:true})
    notIn?: Array<keyof typeof TransactionCategory>;
    @Field(() => NestedEnumTransactionCategoryFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionCategoryFilter>;
}

@InputType()
export class NestedEnumTransactionCategoryWithAggregatesFilter {
    @Field(() => TransactionCategory, {nullable:true})
    equals?: keyof typeof TransactionCategory;
    @Field(() => [TransactionCategory], {nullable:true})
    in?: Array<keyof typeof TransactionCategory>;
    @Field(() => [TransactionCategory], {nullable:true})
    notIn?: Array<keyof typeof TransactionCategory>;
    @Field(() => NestedEnumTransactionCategoryWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionCategoryWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumTransactionCategoryFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumTransactionCategoryFilter>;
    @Field(() => NestedEnumTransactionCategoryFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumTransactionCategoryFilter>;
}

@InputType()
export class NestedEnumTransactionStatusFilter {
    @Field(() => TransactionStatus, {nullable:true})
    equals?: keyof typeof TransactionStatus;
    @Field(() => [TransactionStatus], {nullable:true})
    in?: Array<keyof typeof TransactionStatus>;
    @Field(() => [TransactionStatus], {nullable:true})
    notIn?: Array<keyof typeof TransactionStatus>;
    @Field(() => NestedEnumTransactionStatusFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionStatusFilter>;
}

@InputType()
export class NestedEnumTransactionStatusWithAggregatesFilter {
    @Field(() => TransactionStatus, {nullable:true})
    equals?: keyof typeof TransactionStatus;
    @Field(() => [TransactionStatus], {nullable:true})
    in?: Array<keyof typeof TransactionStatus>;
    @Field(() => [TransactionStatus], {nullable:true})
    notIn?: Array<keyof typeof TransactionStatus>;
    @Field(() => NestedEnumTransactionStatusWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionStatusWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumTransactionStatusFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumTransactionStatusFilter>;
    @Field(() => NestedEnumTransactionStatusFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumTransactionStatusFilter>;
}

@InputType()
export class NestedEnumTransactionTypeFilter {
    @Field(() => TransactionType, {nullable:true})
    equals?: keyof typeof TransactionType;
    @Field(() => [TransactionType], {nullable:true})
    in?: Array<keyof typeof TransactionType>;
    @Field(() => [TransactionType], {nullable:true})
    notIn?: Array<keyof typeof TransactionType>;
    @Field(() => NestedEnumTransactionTypeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionTypeFilter>;
}

@InputType()
export class NestedEnumTransactionTypeWithAggregatesFilter {
    @Field(() => TransactionType, {nullable:true})
    equals?: keyof typeof TransactionType;
    @Field(() => [TransactionType], {nullable:true})
    in?: Array<keyof typeof TransactionType>;
    @Field(() => [TransactionType], {nullable:true})
    notIn?: Array<keyof typeof TransactionType>;
    @Field(() => NestedEnumTransactionTypeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumTransactionTypeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumTransactionTypeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumTransactionTypeFilter>;
    @Field(() => NestedEnumTransactionTypeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumTransactionTypeFilter>;
}

@InputType()
export class NestedEnumUserNotificationCategoryFilter {
    @Field(() => UserNotificationCategory, {nullable:true})
    equals?: keyof typeof UserNotificationCategory;
    @Field(() => [UserNotificationCategory], {nullable:true})
    in?: Array<keyof typeof UserNotificationCategory>;
    @Field(() => [UserNotificationCategory], {nullable:true})
    notIn?: Array<keyof typeof UserNotificationCategory>;
    @Field(() => NestedEnumUserNotificationCategoryFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserNotificationCategoryFilter>;
}

@InputType()
export class NestedEnumUserNotificationCategoryWithAggregatesFilter {
    @Field(() => UserNotificationCategory, {nullable:true})
    equals?: keyof typeof UserNotificationCategory;
    @Field(() => [UserNotificationCategory], {nullable:true})
    in?: Array<keyof typeof UserNotificationCategory>;
    @Field(() => [UserNotificationCategory], {nullable:true})
    notIn?: Array<keyof typeof UserNotificationCategory>;
    @Field(() => NestedEnumUserNotificationCategoryWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserNotificationCategoryWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumUserNotificationCategoryFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumUserNotificationCategoryFilter>;
    @Field(() => NestedEnumUserNotificationCategoryFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumUserNotificationCategoryFilter>;
}

@InputType()
export class NestedEnumUserRoleFilter {
    @Field(() => UserRole, {nullable:true})
    equals?: keyof typeof UserRole;
    @Field(() => [UserRole], {nullable:true})
    in?: Array<keyof typeof UserRole>;
    @Field(() => [UserRole], {nullable:true})
    notIn?: Array<keyof typeof UserRole>;
    @Field(() => NestedEnumUserRoleFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserRoleFilter>;
}

@InputType()
export class NestedEnumUserRoleWithAggregatesFilter {
    @Field(() => UserRole, {nullable:true})
    equals?: keyof typeof UserRole;
    @Field(() => [UserRole], {nullable:true})
    in?: Array<keyof typeof UserRole>;
    @Field(() => [UserRole], {nullable:true})
    notIn?: Array<keyof typeof UserRole>;
    @Field(() => NestedEnumUserRoleWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserRoleWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumUserRoleFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumUserRoleFilter>;
    @Field(() => NestedEnumUserRoleFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumUserRoleFilter>;
}

@InputType()
export class NestedEnumUserStatusFilter {
    @Field(() => UserStatus, {nullable:true})
    equals?: keyof typeof UserStatus;
    @Field(() => [UserStatus], {nullable:true})
    in?: Array<keyof typeof UserStatus>;
    @Field(() => [UserStatus], {nullable:true})
    notIn?: Array<keyof typeof UserStatus>;
    @Field(() => NestedEnumUserStatusFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserStatusFilter>;
}

@InputType()
export class NestedEnumUserStatusWithAggregatesFilter {
    @Field(() => UserStatus, {nullable:true})
    equals?: keyof typeof UserStatus;
    @Field(() => [UserStatus], {nullable:true})
    in?: Array<keyof typeof UserStatus>;
    @Field(() => [UserStatus], {nullable:true})
    notIn?: Array<keyof typeof UserStatus>;
    @Field(() => NestedEnumUserStatusWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserStatusWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumUserStatusFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumUserStatusFilter>;
    @Field(() => NestedEnumUserStatusFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumUserStatusFilter>;
}

@InputType()
export class NestedEnumUserTypeFilter {
    @Field(() => UserType, {nullable:true})
    equals?: keyof typeof UserType;
    @Field(() => [UserType], {nullable:true})
    in?: Array<keyof typeof UserType>;
    @Field(() => [UserType], {nullable:true})
    notIn?: Array<keyof typeof UserType>;
    @Field(() => NestedEnumUserTypeFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserTypeFilter>;
}

@InputType()
export class NestedEnumUserTypeWithAggregatesFilter {
    @Field(() => UserType, {nullable:true})
    equals?: keyof typeof UserType;
    @Field(() => [UserType], {nullable:true})
    in?: Array<keyof typeof UserType>;
    @Field(() => [UserType], {nullable:true})
    notIn?: Array<keyof typeof UserType>;
    @Field(() => NestedEnumUserTypeWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedEnumUserTypeWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedEnumUserTypeFilter, {nullable:true})
    _min?: InstanceType<typeof NestedEnumUserTypeFilter>;
    @Field(() => NestedEnumUserTypeFilter, {nullable:true})
    _max?: InstanceType<typeof NestedEnumUserTypeFilter>;
}

@InputType()
export class NestedFloatFilter {
    @Field(() => Float, {nullable:true})
    equals?: number;
    @Field(() => [Float], {nullable:true})
    in?: Array<number>;
    @Field(() => [Float], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Float, {nullable:true})
    lt?: number;
    @Field(() => Float, {nullable:true})
    lte?: number;
    @Field(() => Float, {nullable:true})
    gt?: number;
    @Field(() => Float, {nullable:true})
    gte?: number;
    @Field(() => NestedFloatFilter, {nullable:true})
    not?: InstanceType<typeof NestedFloatFilter>;
}

@InputType()
export class NestedFloatNullableFilter {
    @Field(() => Float, {nullable:true})
    equals?: number;
    @Field(() => [Float], {nullable:true})
    in?: Array<number>;
    @Field(() => [Float], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Float, {nullable:true})
    lt?: number;
    @Field(() => Float, {nullable:true})
    lte?: number;
    @Field(() => Float, {nullable:true})
    gt?: number;
    @Field(() => Float, {nullable:true})
    gte?: number;
    @Field(() => NestedFloatNullableFilter, {nullable:true})
    not?: InstanceType<typeof NestedFloatNullableFilter>;
}

@InputType()
export class NestedFloatNullableWithAggregatesFilter {
    @Field(() => Float, {nullable:true})
    equals?: number;
    @Field(() => [Float], {nullable:true})
    in?: Array<number>;
    @Field(() => [Float], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Float, {nullable:true})
    lt?: number;
    @Field(() => Float, {nullable:true})
    lte?: number;
    @Field(() => Float, {nullable:true})
    gt?: number;
    @Field(() => Float, {nullable:true})
    gte?: number;
    @Field(() => NestedFloatNullableWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedFloatNullableWithAggregatesFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedFloatNullableFilter, {nullable:true})
    _avg?: InstanceType<typeof NestedFloatNullableFilter>;
    @Field(() => NestedFloatNullableFilter, {nullable:true})
    _sum?: InstanceType<typeof NestedFloatNullableFilter>;
    @Field(() => NestedFloatNullableFilter, {nullable:true})
    _min?: InstanceType<typeof NestedFloatNullableFilter>;
    @Field(() => NestedFloatNullableFilter, {nullable:true})
    _max?: InstanceType<typeof NestedFloatNullableFilter>;
}

@InputType()
export class NestedFloatWithAggregatesFilter {
    @Field(() => Float, {nullable:true})
    equals?: number;
    @Field(() => [Float], {nullable:true})
    in?: Array<number>;
    @Field(() => [Float], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Float, {nullable:true})
    lt?: number;
    @Field(() => Float, {nullable:true})
    lte?: number;
    @Field(() => Float, {nullable:true})
    gt?: number;
    @Field(() => Float, {nullable:true})
    gte?: number;
    @Field(() => NestedFloatWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedFloatWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _avg?: InstanceType<typeof NestedFloatFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _sum?: InstanceType<typeof NestedFloatFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _min?: InstanceType<typeof NestedFloatFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _max?: InstanceType<typeof NestedFloatFilter>;
}

@InputType()
export class NestedIntFilter {
    @Field(() => Int, {nullable:true})
    equals?: number;
    @Field(() => [Int], {nullable:true})
    in?: Array<number>;
    @Field(() => [Int], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Int, {nullable:true})
    lt?: number;
    @Field(() => Int, {nullable:true})
    lte?: number;
    @Field(() => Int, {nullable:true})
    gt?: number;
    @Field(() => Int, {nullable:true})
    gte?: number;
    @Field(() => NestedIntFilter, {nullable:true})
    not?: InstanceType<typeof NestedIntFilter>;
}

@InputType()
export class NestedIntNullableFilter {
    @Field(() => Int, {nullable:true})
    equals?: number;
    @Field(() => [Int], {nullable:true})
    in?: Array<number>;
    @Field(() => [Int], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Int, {nullable:true})
    lt?: number;
    @Field(() => Int, {nullable:true})
    lte?: number;
    @Field(() => Int, {nullable:true})
    gt?: number;
    @Field(() => Int, {nullable:true})
    gte?: number;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    not?: InstanceType<typeof NestedIntNullableFilter>;
}

@InputType()
export class NestedIntNullableWithAggregatesFilter {
    @Field(() => Int, {nullable:true})
    equals?: number;
    @Field(() => [Int], {nullable:true})
    in?: Array<number>;
    @Field(() => [Int], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Int, {nullable:true})
    lt?: number;
    @Field(() => Int, {nullable:true})
    lte?: number;
    @Field(() => Int, {nullable:true})
    gt?: number;
    @Field(() => Int, {nullable:true})
    gte?: number;
    @Field(() => NestedIntNullableWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedIntNullableWithAggregatesFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedFloatNullableFilter, {nullable:true})
    _avg?: InstanceType<typeof NestedFloatNullableFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _sum?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _min?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _max?: InstanceType<typeof NestedIntNullableFilter>;
}

@InputType()
export class NestedIntWithAggregatesFilter {
    @Field(() => Int, {nullable:true})
    equals?: number;
    @Field(() => [Int], {nullable:true})
    in?: Array<number>;
    @Field(() => [Int], {nullable:true})
    notIn?: Array<number>;
    @Field(() => Int, {nullable:true})
    lt?: number;
    @Field(() => Int, {nullable:true})
    lte?: number;
    @Field(() => Int, {nullable:true})
    gt?: number;
    @Field(() => Int, {nullable:true})
    gte?: number;
    @Field(() => NestedIntWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedIntWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedFloatFilter, {nullable:true})
    _avg?: InstanceType<typeof NestedFloatFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _sum?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _min?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _max?: InstanceType<typeof NestedIntFilter>;
}

@InputType()
export class NestedStringFilter {
    @Field(() => String, {nullable:true})
    equals?: string;
    @Field(() => [String], {nullable:true})
    in?: Array<string>;
    @Field(() => [String], {nullable:true})
    notIn?: Array<string>;
    @Field(() => String, {nullable:true})
    lt?: string;
    @Field(() => String, {nullable:true})
    lte?: string;
    @Field(() => String, {nullable:true})
    gt?: string;
    @Field(() => String, {nullable:true})
    gte?: string;
    @Field(() => String, {nullable:true})
    contains?: string;
    @Field(() => String, {nullable:true})
    startsWith?: string;
    @Field(() => String, {nullable:true})
    endsWith?: string;
    @Field(() => NestedStringFilter, {nullable:true})
    not?: InstanceType<typeof NestedStringFilter>;
}

@InputType()
export class NestedStringNullableFilter {
    @Field(() => String, {nullable:true})
    equals?: string;
    @Field(() => [String], {nullable:true})
    in?: Array<string>;
    @Field(() => [String], {nullable:true})
    notIn?: Array<string>;
    @Field(() => String, {nullable:true})
    lt?: string;
    @Field(() => String, {nullable:true})
    lte?: string;
    @Field(() => String, {nullable:true})
    gt?: string;
    @Field(() => String, {nullable:true})
    gte?: string;
    @Field(() => String, {nullable:true})
    contains?: string;
    @Field(() => String, {nullable:true})
    startsWith?: string;
    @Field(() => String, {nullable:true})
    endsWith?: string;
    @Field(() => NestedStringNullableFilter, {nullable:true})
    not?: InstanceType<typeof NestedStringNullableFilter>;
}

@InputType()
export class NestedStringNullableWithAggregatesFilter {
    @Field(() => String, {nullable:true})
    equals?: string;
    @Field(() => [String], {nullable:true})
    in?: Array<string>;
    @Field(() => [String], {nullable:true})
    notIn?: Array<string>;
    @Field(() => String, {nullable:true})
    lt?: string;
    @Field(() => String, {nullable:true})
    lte?: string;
    @Field(() => String, {nullable:true})
    gt?: string;
    @Field(() => String, {nullable:true})
    gte?: string;
    @Field(() => String, {nullable:true})
    contains?: string;
    @Field(() => String, {nullable:true})
    startsWith?: string;
    @Field(() => String, {nullable:true})
    endsWith?: string;
    @Field(() => NestedStringNullableWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedStringNullableWithAggregatesFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedStringNullableFilter, {nullable:true})
    _min?: InstanceType<typeof NestedStringNullableFilter>;
    @Field(() => NestedStringNullableFilter, {nullable:true})
    _max?: InstanceType<typeof NestedStringNullableFilter>;
}

@InputType()
export class NestedStringWithAggregatesFilter {
    @Field(() => String, {nullable:true})
    equals?: string;
    @Field(() => [String], {nullable:true})
    in?: Array<string>;
    @Field(() => [String], {nullable:true})
    notIn?: Array<string>;
    @Field(() => String, {nullable:true})
    lt?: string;
    @Field(() => String, {nullable:true})
    lte?: string;
    @Field(() => String, {nullable:true})
    gt?: string;
    @Field(() => String, {nullable:true})
    gte?: string;
    @Field(() => String, {nullable:true})
    contains?: string;
    @Field(() => String, {nullable:true})
    startsWith?: string;
    @Field(() => String, {nullable:true})
    endsWith?: string;
    @Field(() => NestedStringWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedStringWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedStringFilter, {nullable:true})
    _min?: InstanceType<typeof NestedStringFilter>;
    @Field(() => NestedStringFilter, {nullable:true})
    _max?: InstanceType<typeof NestedStringFilter>;
}

@InputType()
export class NullableDateTimeFieldUpdateOperationsInput {
    @Field(() => Date, {nullable:true})
    set?: Date | string;
}

@InputType()
export class NullableFloatFieldUpdateOperationsInput {
    @Field(() => Float, {nullable:true})
    set?: number;
    @Field(() => Float, {nullable:true})
    increment?: number;
    @Field(() => Float, {nullable:true})
    decrement?: number;
    @Field(() => Float, {nullable:true})
    multiply?: number;
    @Field(() => Float, {nullable:true})
    divide?: number;
}

@InputType()
export class NullableIntFieldUpdateOperationsInput {
    @Field(() => Int, {nullable:true})
    set?: number;
    @Field(() => Int, {nullable:true})
    increment?: number;
    @Field(() => Int, {nullable:true})
    decrement?: number;
    @Field(() => Int, {nullable:true})
    multiply?: number;
    @Field(() => Int, {nullable:true})
    divide?: number;
}

@InputType()
export class NullableStringFieldUpdateOperationsInput {
    @Field(() => String, {nullable:true})
    set?: string;
}

@InputType()
export class SortOrderInput {
    @Field(() => SortOrder, {nullable:false})
    sort!: keyof typeof SortOrder;
    @Field(() => NullsOrder, {nullable:true})
    nulls?: keyof typeof NullsOrder;
}

@InputType()
export class StringFieldUpdateOperationsInput {
    @Field(() => String, {nullable:true})
    set?: string;
}

@InputType()
export class StringFilter {
    @Field(() => String, {nullable:true})
    equals?: string;
    @Field(() => [String], {nullable:true})
    in?: Array<string>;
    @Field(() => [String], {nullable:true})
    notIn?: Array<string>;
    @Field(() => String, {nullable:true})
    lt?: string;
    @Field(() => String, {nullable:true})
    lte?: string;
    @Field(() => String, {nullable:true})
    gt?: string;
    @Field(() => String, {nullable:true})
    gte?: string;
    @Field(() => String, {nullable:true})
    contains?: string;
    @Field(() => String, {nullable:true})
    startsWith?: string;
    @Field(() => String, {nullable:true})
    endsWith?: string;
    @Field(() => NestedStringFilter, {nullable:true})
    not?: InstanceType<typeof NestedStringFilter>;
}

@InputType()
export class StringNullableFilter {
    @Field(() => String, {nullable:true})
    equals?: string;
    @Field(() => [String], {nullable:true})
    in?: Array<string>;
    @Field(() => [String], {nullable:true})
    notIn?: Array<string>;
    @Field(() => String, {nullable:true})
    lt?: string;
    @Field(() => String, {nullable:true})
    lte?: string;
    @Field(() => String, {nullable:true})
    gt?: string;
    @Field(() => String, {nullable:true})
    gte?: string;
    @Field(() => String, {nullable:true})
    contains?: string;
    @Field(() => String, {nullable:true})
    startsWith?: string;
    @Field(() => String, {nullable:true})
    endsWith?: string;
    @Field(() => NestedStringNullableFilter, {nullable:true})
    not?: InstanceType<typeof NestedStringNullableFilter>;
}

@InputType()
export class StringNullableWithAggregatesFilter {
    @Field(() => String, {nullable:true})
    equals?: string;
    @Field(() => [String], {nullable:true})
    in?: Array<string>;
    @Field(() => [String], {nullable:true})
    notIn?: Array<string>;
    @Field(() => String, {nullable:true})
    lt?: string;
    @Field(() => String, {nullable:true})
    lte?: string;
    @Field(() => String, {nullable:true})
    gt?: string;
    @Field(() => String, {nullable:true})
    gte?: string;
    @Field(() => String, {nullable:true})
    contains?: string;
    @Field(() => String, {nullable:true})
    startsWith?: string;
    @Field(() => String, {nullable:true})
    endsWith?: string;
    @Field(() => NestedStringNullableWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedStringNullableWithAggregatesFilter>;
    @Field(() => NestedIntNullableFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntNullableFilter>;
    @Field(() => NestedStringNullableFilter, {nullable:true})
    _min?: InstanceType<typeof NestedStringNullableFilter>;
    @Field(() => NestedStringNullableFilter, {nullable:true})
    _max?: InstanceType<typeof NestedStringNullableFilter>;
}

@InputType()
export class StringWithAggregatesFilter {
    @Field(() => String, {nullable:true})
    equals?: string;
    @Field(() => [String], {nullable:true})
    in?: Array<string>;
    @Field(() => [String], {nullable:true})
    notIn?: Array<string>;
    @Field(() => String, {nullable:true})
    lt?: string;
    @Field(() => String, {nullable:true})
    lte?: string;
    @Field(() => String, {nullable:true})
    gt?: string;
    @Field(() => String, {nullable:true})
    gte?: string;
    @Field(() => String, {nullable:true})
    contains?: string;
    @Field(() => String, {nullable:true})
    startsWith?: string;
    @Field(() => String, {nullable:true})
    endsWith?: string;
    @Field(() => NestedStringWithAggregatesFilter, {nullable:true})
    not?: InstanceType<typeof NestedStringWithAggregatesFilter>;
    @Field(() => NestedIntFilter, {nullable:true})
    _count?: InstanceType<typeof NestedIntFilter>;
    @Field(() => NestedStringFilter, {nullable:true})
    _min?: InstanceType<typeof NestedStringFilter>;
    @Field(() => NestedStringFilter, {nullable:true})
    _max?: InstanceType<typeof NestedStringFilter>;
}

@ObjectType()
export class AggregateProgram {
    @Field(() => ProgramCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ProgramCountAggregate>;
    @Field(() => ProgramAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ProgramAvgAggregate>;
    @Field(() => ProgramSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ProgramSumAggregate>;
    @Field(() => ProgramMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ProgramMinAggregate>;
    @Field(() => ProgramMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ProgramMaxAggregate>;
}

@ArgsType()
export class CreateManyProgramArgs {
    @Field(() => [ProgramCreateManyInput], {nullable:false})
    @Type(() => ProgramCreateManyInput)
    data!: Array<ProgramCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneProgramArgs {
    @Field(() => ProgramCreateInput, {nullable:false})
    @Type(() => ProgramCreateInput)
    data!: InstanceType<typeof ProgramCreateInput>;
}

@ArgsType()
export class DeleteManyProgramArgs {
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    where?: InstanceType<typeof ProgramWhereInput>;
}

@ArgsType()
export class DeleteOneProgramArgs {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstProgramOrThrowArgs {
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    where?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => [ProgramOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProgramOrderByWithRelationInput>;
    @Field(() => ProgramWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProgramScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProgramScalarFieldEnum>;
}

@ArgsType()
export class FindFirstProgramArgs {
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    where?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => [ProgramOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProgramOrderByWithRelationInput>;
    @Field(() => ProgramWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProgramScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProgramScalarFieldEnum>;
}

@ArgsType()
export class FindManyProgramArgs {
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    where?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => [ProgramOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProgramOrderByWithRelationInput>;
    @Field(() => ProgramWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProgramScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProgramScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueProgramOrThrowArgs {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueProgramArgs {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
}

@ArgsType()
export class ProgramAggregateArgs {
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    where?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => [ProgramOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProgramOrderByWithRelationInput>;
    @Field(() => ProgramWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ProgramCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProgramCountAggregateInput>;
    @Field(() => ProgramAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProgramAvgAggregateInput>;
    @Field(() => ProgramSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProgramSumAggregateInput>;
    @Field(() => ProgramMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProgramMinAggregateInput>;
    @Field(() => ProgramMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProgramMaxAggregateInput>;
}

@InputType()
export class ProgramAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    categoryId?: true;
}

@ObjectType()
export class ProgramAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    categoryId?: number;
}

@InputType()
export class ProgramAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    categoryId?: keyof typeof SortOrder;
}

@InputType()
export class ProgramCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    startDate?: true;
    @Field(() => Boolean, {nullable:true})
    dueDate?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    createdById?: true;
    @Field(() => Boolean, {nullable:true})
    categoryId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class ProgramCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    startDate!: number;
    @Field(() => Int, {nullable:false})
    dueDate!: number;
    @Field(() => Int, {nullable:false})
    description!: number;
    @Field(() => Int, {nullable:false})
    createdById!: number;
    @Field(() => Int, {nullable:false})
    categoryId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class ProgramCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    dueDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    categoryId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@ObjectType()
export class ProgramCount {
    @Field(() => Int, {nullable:false})
    Images?: number;
    @Field(() => Int, {nullable:false})
    participant?: number;
}

@InputType()
export class ProgramCreateManyCategoryInputEnvelope {
    @Field(() => [ProgramCreateManyCategoryInput], {nullable:false})
    @Type(() => ProgramCreateManyCategoryInput)
    data!: Array<ProgramCreateManyCategoryInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class ProgramCreateManyCategoryInput {
    @HideField()
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class ProgramCreateManyCreatedByInputEnvelope {
    @Field(() => [ProgramCreateManyCreatedByInput], {nullable:false})
    @Type(() => ProgramCreateManyCreatedByInput)
    data!: Array<ProgramCreateManyCreatedByInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class ProgramCreateManyCreatedByInput {
    @HideField()
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @HideField()
    categoryId!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class ProgramCreateManyInput {
    @HideField()
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @HideField()
    categoryId!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class ProgramCreateNestedManyWithoutCategoryInput {
    @Field(() => [ProgramCreateWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramCreateWithoutCategoryInput)
    create?: Array<ProgramCreateWithoutCategoryInput>;
    @Field(() => [ProgramCreateOrConnectWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutCategoryInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutCategoryInput>;
    @Field(() => ProgramCreateManyCategoryInputEnvelope, {nullable:true})
    @Type(() => ProgramCreateManyCategoryInputEnvelope)
    createMany?: InstanceType<typeof ProgramCreateManyCategoryInputEnvelope>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
}

@InputType()
export class ProgramCreateNestedManyWithoutCreatedByInput {
    @Field(() => [ProgramCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramCreateWithoutCreatedByInput)
    create?: Array<ProgramCreateWithoutCreatedByInput>;
    @Field(() => [ProgramCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutCreatedByInput>;
    @Field(() => ProgramCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => ProgramCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof ProgramCreateManyCreatedByInputEnvelope>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
}

@InputType()
export class ProgramCreateNestedManyWithoutParticipantInput {
    @Field(() => [ProgramCreateWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramCreateWithoutParticipantInput)
    create?: Array<ProgramCreateWithoutParticipantInput>;
    @Field(() => [ProgramCreateOrConnectWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutParticipantInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutParticipantInput>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
}

@InputType()
export class ProgramCreateNestedOneWithoutImagesInput {
    @Field(() => ProgramCreateWithoutImagesInput, {nullable:true})
    @Type(() => ProgramCreateWithoutImagesInput)
    create?: InstanceType<typeof ProgramCreateWithoutImagesInput>;
    @Field(() => ProgramCreateOrConnectWithoutImagesInput, {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutImagesInput)
    connectOrCreate?: InstanceType<typeof ProgramCreateOrConnectWithoutImagesInput>;
    @Field(() => ProgramWhereUniqueInput, {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
}

@InputType()
export class ProgramCreateOrConnectWithoutCategoryInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
    @Field(() => ProgramCreateWithoutCategoryInput, {nullable:false})
    @Type(() => ProgramCreateWithoutCategoryInput)
    create!: InstanceType<typeof ProgramCreateWithoutCategoryInput>;
}

@InputType()
export class ProgramCreateOrConnectWithoutCreatedByInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
    @Field(() => ProgramCreateWithoutCreatedByInput, {nullable:false})
    @Type(() => ProgramCreateWithoutCreatedByInput)
    create!: InstanceType<typeof ProgramCreateWithoutCreatedByInput>;
}

@InputType()
export class ProgramCreateOrConnectWithoutImagesInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
    @Field(() => ProgramCreateWithoutImagesInput, {nullable:false})
    @Type(() => ProgramCreateWithoutImagesInput)
    create!: InstanceType<typeof ProgramCreateWithoutImagesInput>;
}

@InputType()
export class ProgramCreateOrConnectWithoutParticipantInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
    @Field(() => ProgramCreateWithoutParticipantInput, {nullable:false})
    @Type(() => ProgramCreateWithoutParticipantInput)
    create!: InstanceType<typeof ProgramCreateWithoutParticipantInput>;
}

@InputType()
export class ProgramCreateWithoutCategoryInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutProgramImageInput, {nullable:true})
    Images?: InstanceType<typeof ImagesCreateNestedManyWithoutProgramImageInput>;
    @Field(() => UserCreateNestedOneWithoutProgramsCreatedInput, {nullable:false})
    createdBy!: InstanceType<typeof UserCreateNestedOneWithoutProgramsCreatedInput>;
    @HideField()
    participant?: InstanceType<typeof UserCreateNestedManyWithoutProgramsParticipationInput>;
}

@InputType()
export class ProgramCreateWithoutCreatedByInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutProgramImageInput, {nullable:true})
    Images?: InstanceType<typeof ImagesCreateNestedManyWithoutProgramImageInput>;
    @HideField()
    participant?: InstanceType<typeof UserCreateNestedManyWithoutProgramsParticipationInput>;
    @Field(() => ProgramCategoryCreateNestedOneWithoutProgramsInput, {nullable:false})
    category!: InstanceType<typeof ProgramCategoryCreateNestedOneWithoutProgramsInput>;
}

@InputType()
export class ProgramCreateWithoutImagesInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutProgramsCreatedInput, {nullable:false})
    createdBy!: InstanceType<typeof UserCreateNestedOneWithoutProgramsCreatedInput>;
    @HideField()
    participant?: InstanceType<typeof UserCreateNestedManyWithoutProgramsParticipationInput>;
    @Field(() => ProgramCategoryCreateNestedOneWithoutProgramsInput, {nullable:false})
    category!: InstanceType<typeof ProgramCategoryCreateNestedOneWithoutProgramsInput>;
}

@InputType()
export class ProgramCreateWithoutParticipantInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutProgramImageInput, {nullable:true})
    Images?: InstanceType<typeof ImagesCreateNestedManyWithoutProgramImageInput>;
    @Field(() => UserCreateNestedOneWithoutProgramsCreatedInput, {nullable:false})
    createdBy!: InstanceType<typeof UserCreateNestedOneWithoutProgramsCreatedInput>;
    @Field(() => ProgramCategoryCreateNestedOneWithoutProgramsInput, {nullable:false})
    category!: InstanceType<typeof ProgramCategoryCreateNestedOneWithoutProgramsInput>;
}

@InputType()
export class ProgramCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutProgramImageInput, {nullable:true})
    Images?: InstanceType<typeof ImagesCreateNestedManyWithoutProgramImageInput>;
    @Field(() => UserCreateNestedOneWithoutProgramsCreatedInput, {nullable:false})
    createdBy!: InstanceType<typeof UserCreateNestedOneWithoutProgramsCreatedInput>;
    @HideField()
    participant?: InstanceType<typeof UserCreateNestedManyWithoutProgramsParticipationInput>;
    @Field(() => ProgramCategoryCreateNestedOneWithoutProgramsInput, {nullable:false})
    category!: InstanceType<typeof ProgramCategoryCreateNestedOneWithoutProgramsInput>;
}

@ArgsType()
export class ProgramGroupByArgs {
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    where?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => [ProgramOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<ProgramOrderByWithAggregationInput>;
    @Field(() => [ProgramScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof ProgramScalarFieldEnum>;
    @Field(() => ProgramScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof ProgramScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ProgramCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProgramCountAggregateInput>;
    @Field(() => ProgramAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProgramAvgAggregateInput>;
    @Field(() => ProgramSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProgramSumAggregateInput>;
    @Field(() => ProgramMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProgramMinAggregateInput>;
    @Field(() => ProgramMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProgramMaxAggregateInput>;
}

@ObjectType()
export class ProgramGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Int, {nullable:false})
    categoryId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => ProgramCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ProgramCountAggregate>;
    @Field(() => ProgramAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ProgramAvgAggregate>;
    @Field(() => ProgramSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ProgramSumAggregate>;
    @Field(() => ProgramMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ProgramMinAggregate>;
    @Field(() => ProgramMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ProgramMaxAggregate>;
}

@InputType()
export class ProgramListRelationFilter {
    @Field(() => ProgramWhereInput, {nullable:true})
    every?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => ProgramWhereInput, {nullable:true})
    some?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => ProgramWhereInput, {nullable:true})
    none?: InstanceType<typeof ProgramWhereInput>;
}

@InputType()
export class ProgramMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    startDate?: true;
    @Field(() => Boolean, {nullable:true})
    dueDate?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    createdById?: true;
    @Field(() => Boolean, {nullable:true})
    categoryId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class ProgramMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Date, {nullable:true})
    startDate?: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => String, {nullable:true})
    createdById?: string;
    @Field(() => Int, {nullable:true})
    categoryId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProgramMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    dueDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    categoryId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ProgramMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    startDate?: true;
    @Field(() => Boolean, {nullable:true})
    dueDate?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    createdById?: true;
    @Field(() => Boolean, {nullable:true})
    categoryId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class ProgramMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Date, {nullable:true})
    startDate?: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => String, {nullable:true})
    createdById?: string;
    @Field(() => Int, {nullable:true})
    categoryId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProgramMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    dueDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    categoryId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ProgramNullableRelationFilter {
    @Field(() => ProgramWhereInput, {nullable:true})
    is?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => ProgramWhereInput, {nullable:true})
    isNot?: InstanceType<typeof ProgramWhereInput>;
}

@InputType()
export class ProgramOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class ProgramOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    dueDate?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    categoryId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => ProgramCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProgramCountOrderByAggregateInput>;
    @Field(() => ProgramAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProgramAvgOrderByAggregateInput>;
    @Field(() => ProgramMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProgramMaxOrderByAggregateInput>;
    @Field(() => ProgramMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProgramMinOrderByAggregateInput>;
    @Field(() => ProgramSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProgramSumOrderByAggregateInput>;
}

@InputType()
export class ProgramOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    dueDate?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    categoryId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => ImagesOrderByRelationAggregateInput, {nullable:true})
    Images?: InstanceType<typeof ImagesOrderByRelationAggregateInput>;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    createdBy?: InstanceType<typeof UserOrderByWithRelationInput>;
    @Field(() => UserOrderByRelationAggregateInput, {nullable:true})
    participant?: InstanceType<typeof UserOrderByRelationAggregateInput>;
    @Field(() => ProgramCategoryOrderByWithRelationInput, {nullable:true})
    category?: InstanceType<typeof ProgramCategoryOrderByWithRelationInput>;
}

@InputType()
export class ProgramScalarWhereWithAggregatesInput {
    @Field(() => [ProgramScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<ProgramScalarWhereWithAggregatesInput>;
    @Field(() => [ProgramScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<ProgramScalarWhereWithAggregatesInput>;
    @Field(() => [ProgramScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<ProgramScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeNullableWithAggregatesFilter, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeNullableWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    description?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    createdById?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    categoryId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class ProgramScalarWhereInput {
    @Field(() => [ProgramScalarWhereInput], {nullable:true})
    AND?: Array<ProgramScalarWhereInput>;
    @Field(() => [ProgramScalarWhereInput], {nullable:true})
    OR?: Array<ProgramScalarWhereInput>;
    @Field(() => [ProgramScalarWhereInput], {nullable:true})
    NOT?: Array<ProgramScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeNullableFilter, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    createdById?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    categoryId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class ProgramSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    categoryId?: true;
}

@ObjectType()
export class ProgramSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    categoryId?: number;
}

@InputType()
export class ProgramSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    categoryId?: keyof typeof SortOrder;
}

@InputType()
export class ProgramUncheckedCreateNestedManyWithoutCategoryInput {
    @Field(() => [ProgramCreateWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramCreateWithoutCategoryInput)
    create?: Array<ProgramCreateWithoutCategoryInput>;
    @Field(() => [ProgramCreateOrConnectWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutCategoryInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutCategoryInput>;
    @Field(() => ProgramCreateManyCategoryInputEnvelope, {nullable:true})
    @Type(() => ProgramCreateManyCategoryInputEnvelope)
    createMany?: InstanceType<typeof ProgramCreateManyCategoryInputEnvelope>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
}

@InputType()
export class ProgramUncheckedCreateNestedManyWithoutCreatedByInput {
    @Field(() => [ProgramCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramCreateWithoutCreatedByInput)
    create?: Array<ProgramCreateWithoutCreatedByInput>;
    @Field(() => [ProgramCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutCreatedByInput>;
    @Field(() => ProgramCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => ProgramCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof ProgramCreateManyCreatedByInputEnvelope>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
}

@InputType()
export class ProgramUncheckedCreateNestedManyWithoutParticipantInput {
    @Field(() => [ProgramCreateWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramCreateWithoutParticipantInput)
    create?: Array<ProgramCreateWithoutParticipantInput>;
    @Field(() => [ProgramCreateOrConnectWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutParticipantInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutParticipantInput>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
}

@InputType()
export class ProgramUncheckedCreateWithoutCategoryInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutProgramImageInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutProgramImageInput>;
    @Field(() => UserUncheckedCreateNestedManyWithoutProgramsParticipationInput, {nullable:true})
    participant?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutProgramsParticipationInput>;
}

@InputType()
export class ProgramUncheckedCreateWithoutCreatedByInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => Int, {nullable:false})
    categoryId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutProgramImageInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutProgramImageInput>;
    @Field(() => UserUncheckedCreateNestedManyWithoutProgramsParticipationInput, {nullable:true})
    participant?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutProgramsParticipationInput>;
}

@InputType()
export class ProgramUncheckedCreateWithoutImagesInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Int, {nullable:false})
    categoryId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserUncheckedCreateNestedManyWithoutProgramsParticipationInput, {nullable:true})
    participant?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutProgramsParticipationInput>;
}

@InputType()
export class ProgramUncheckedCreateWithoutParticipantInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Int, {nullable:false})
    categoryId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutProgramImageInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutProgramImageInput>;
}

@InputType()
export class ProgramUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:true})
    dueDate?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    description!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Int, {nullable:false})
    categoryId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutProgramImageInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutProgramImageInput>;
    @Field(() => UserUncheckedCreateNestedManyWithoutProgramsParticipationInput, {nullable:true})
    participant?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutProgramsParticipationInput>;
}

@InputType()
export class ProgramUncheckedUpdateManyWithoutCategoryNestedInput {
    @Field(() => [ProgramCreateWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramCreateWithoutCategoryInput)
    create?: Array<ProgramCreateWithoutCategoryInput>;
    @Field(() => [ProgramCreateOrConnectWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutCategoryInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutCategoryInput>;
    @Field(() => [ProgramUpsertWithWhereUniqueWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramUpsertWithWhereUniqueWithoutCategoryInput)
    upsert?: Array<ProgramUpsertWithWhereUniqueWithoutCategoryInput>;
    @Field(() => ProgramCreateManyCategoryInputEnvelope, {nullable:true})
    @Type(() => ProgramCreateManyCategoryInputEnvelope)
    createMany?: InstanceType<typeof ProgramCreateManyCategoryInputEnvelope>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramUpdateWithWhereUniqueWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramUpdateWithWhereUniqueWithoutCategoryInput)
    update?: Array<ProgramUpdateWithWhereUniqueWithoutCategoryInput>;
    @Field(() => [ProgramUpdateManyWithWhereWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramUpdateManyWithWhereWithoutCategoryInput)
    updateMany?: Array<ProgramUpdateManyWithWhereWithoutCategoryInput>;
    @Field(() => [ProgramScalarWhereInput], {nullable:true})
    @Type(() => ProgramScalarWhereInput)
    deleteMany?: Array<ProgramScalarWhereInput>;
}

@InputType()
export class ProgramUncheckedUpdateManyWithoutCategoryInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProgramUncheckedUpdateManyWithoutCreatedByNestedInput {
    @Field(() => [ProgramCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramCreateWithoutCreatedByInput)
    create?: Array<ProgramCreateWithoutCreatedByInput>;
    @Field(() => [ProgramCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutCreatedByInput>;
    @Field(() => [ProgramUpsertWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramUpsertWithWhereUniqueWithoutCreatedByInput)
    upsert?: Array<ProgramUpsertWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => ProgramCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => ProgramCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof ProgramCreateManyCreatedByInputEnvelope>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramUpdateWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramUpdateWithWhereUniqueWithoutCreatedByInput)
    update?: Array<ProgramUpdateWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => [ProgramUpdateManyWithWhereWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramUpdateManyWithWhereWithoutCreatedByInput)
    updateMany?: Array<ProgramUpdateManyWithWhereWithoutCreatedByInput>;
    @Field(() => [ProgramScalarWhereInput], {nullable:true})
    @Type(() => ProgramScalarWhereInput)
    deleteMany?: Array<ProgramScalarWhereInput>;
}

@InputType()
export class ProgramUncheckedUpdateManyWithoutCreatedByInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    categoryId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProgramUncheckedUpdateManyWithoutParticipantNestedInput {
    @Field(() => [ProgramCreateWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramCreateWithoutParticipantInput)
    create?: Array<ProgramCreateWithoutParticipantInput>;
    @Field(() => [ProgramCreateOrConnectWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutParticipantInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutParticipantInput>;
    @Field(() => [ProgramUpsertWithWhereUniqueWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramUpsertWithWhereUniqueWithoutParticipantInput)
    upsert?: Array<ProgramUpsertWithWhereUniqueWithoutParticipantInput>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramUpdateWithWhereUniqueWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramUpdateWithWhereUniqueWithoutParticipantInput)
    update?: Array<ProgramUpdateWithWhereUniqueWithoutParticipantInput>;
    @Field(() => [ProgramUpdateManyWithWhereWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramUpdateManyWithWhereWithoutParticipantInput)
    updateMany?: Array<ProgramUpdateManyWithWhereWithoutParticipantInput>;
    @Field(() => [ProgramScalarWhereInput], {nullable:true})
    @Type(() => ProgramScalarWhereInput)
    deleteMany?: Array<ProgramScalarWhereInput>;
}

@InputType()
export class ProgramUncheckedUpdateManyWithoutParticipantInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    categoryId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProgramUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    categoryId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProgramUncheckedUpdateWithoutCategoryInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutProgramImageNestedInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutProgramImageNestedInput>;
    @Field(() => UserUncheckedUpdateManyWithoutProgramsParticipationNestedInput, {nullable:true})
    participant?: InstanceType<typeof UserUncheckedUpdateManyWithoutProgramsParticipationNestedInput>;
}

@InputType()
export class ProgramUncheckedUpdateWithoutCreatedByInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    categoryId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutProgramImageNestedInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutProgramImageNestedInput>;
    @Field(() => UserUncheckedUpdateManyWithoutProgramsParticipationNestedInput, {nullable:true})
    participant?: InstanceType<typeof UserUncheckedUpdateManyWithoutProgramsParticipationNestedInput>;
}

@InputType()
export class ProgramUncheckedUpdateWithoutImagesInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    categoryId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutProgramsParticipationNestedInput, {nullable:true})
    participant?: InstanceType<typeof UserUncheckedUpdateManyWithoutProgramsParticipationNestedInput>;
}

@InputType()
export class ProgramUncheckedUpdateWithoutParticipantInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    categoryId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutProgramImageNestedInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutProgramImageNestedInput>;
}

@InputType()
export class ProgramUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    createdById?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    categoryId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutProgramImageNestedInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutProgramImageNestedInput>;
    @Field(() => UserUncheckedUpdateManyWithoutProgramsParticipationNestedInput, {nullable:true})
    participant?: InstanceType<typeof UserUncheckedUpdateManyWithoutProgramsParticipationNestedInput>;
}

@InputType()
export class ProgramUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProgramUpdateManyWithWhereWithoutCategoryInput {
    @Field(() => ProgramScalarWhereInput, {nullable:false})
    @Type(() => ProgramScalarWhereInput)
    where!: InstanceType<typeof ProgramScalarWhereInput>;
    @Field(() => ProgramUpdateManyMutationInput, {nullable:false})
    @Type(() => ProgramUpdateManyMutationInput)
    data!: InstanceType<typeof ProgramUpdateManyMutationInput>;
}

@InputType()
export class ProgramUpdateManyWithWhereWithoutCreatedByInput {
    @Field(() => ProgramScalarWhereInput, {nullable:false})
    @Type(() => ProgramScalarWhereInput)
    where!: InstanceType<typeof ProgramScalarWhereInput>;
    @Field(() => ProgramUpdateManyMutationInput, {nullable:false})
    @Type(() => ProgramUpdateManyMutationInput)
    data!: InstanceType<typeof ProgramUpdateManyMutationInput>;
}

@InputType()
export class ProgramUpdateManyWithWhereWithoutParticipantInput {
    @Field(() => ProgramScalarWhereInput, {nullable:false})
    @Type(() => ProgramScalarWhereInput)
    where!: InstanceType<typeof ProgramScalarWhereInput>;
    @Field(() => ProgramUpdateManyMutationInput, {nullable:false})
    @Type(() => ProgramUpdateManyMutationInput)
    data!: InstanceType<typeof ProgramUpdateManyMutationInput>;
}

@InputType()
export class ProgramUpdateManyWithoutCategoryNestedInput {
    @Field(() => [ProgramCreateWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramCreateWithoutCategoryInput)
    create?: Array<ProgramCreateWithoutCategoryInput>;
    @Field(() => [ProgramCreateOrConnectWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutCategoryInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutCategoryInput>;
    @Field(() => [ProgramUpsertWithWhereUniqueWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramUpsertWithWhereUniqueWithoutCategoryInput)
    upsert?: Array<ProgramUpsertWithWhereUniqueWithoutCategoryInput>;
    @Field(() => ProgramCreateManyCategoryInputEnvelope, {nullable:true})
    @Type(() => ProgramCreateManyCategoryInputEnvelope)
    createMany?: InstanceType<typeof ProgramCreateManyCategoryInputEnvelope>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramUpdateWithWhereUniqueWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramUpdateWithWhereUniqueWithoutCategoryInput)
    update?: Array<ProgramUpdateWithWhereUniqueWithoutCategoryInput>;
    @Field(() => [ProgramUpdateManyWithWhereWithoutCategoryInput], {nullable:true})
    @Type(() => ProgramUpdateManyWithWhereWithoutCategoryInput)
    updateMany?: Array<ProgramUpdateManyWithWhereWithoutCategoryInput>;
    @Field(() => [ProgramScalarWhereInput], {nullable:true})
    @Type(() => ProgramScalarWhereInput)
    deleteMany?: Array<ProgramScalarWhereInput>;
}

@InputType()
export class ProgramUpdateManyWithoutCreatedByNestedInput {
    @Field(() => [ProgramCreateWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramCreateWithoutCreatedByInput)
    create?: Array<ProgramCreateWithoutCreatedByInput>;
    @Field(() => [ProgramCreateOrConnectWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutCreatedByInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutCreatedByInput>;
    @Field(() => [ProgramUpsertWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramUpsertWithWhereUniqueWithoutCreatedByInput)
    upsert?: Array<ProgramUpsertWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => ProgramCreateManyCreatedByInputEnvelope, {nullable:true})
    @Type(() => ProgramCreateManyCreatedByInputEnvelope)
    createMany?: InstanceType<typeof ProgramCreateManyCreatedByInputEnvelope>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramUpdateWithWhereUniqueWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramUpdateWithWhereUniqueWithoutCreatedByInput)
    update?: Array<ProgramUpdateWithWhereUniqueWithoutCreatedByInput>;
    @Field(() => [ProgramUpdateManyWithWhereWithoutCreatedByInput], {nullable:true})
    @Type(() => ProgramUpdateManyWithWhereWithoutCreatedByInput)
    updateMany?: Array<ProgramUpdateManyWithWhereWithoutCreatedByInput>;
    @Field(() => [ProgramScalarWhereInput], {nullable:true})
    @Type(() => ProgramScalarWhereInput)
    deleteMany?: Array<ProgramScalarWhereInput>;
}

@InputType()
export class ProgramUpdateManyWithoutParticipantNestedInput {
    @Field(() => [ProgramCreateWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramCreateWithoutParticipantInput)
    create?: Array<ProgramCreateWithoutParticipantInput>;
    @Field(() => [ProgramCreateOrConnectWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutParticipantInput)
    connectOrCreate?: Array<ProgramCreateOrConnectWithoutParticipantInput>;
    @Field(() => [ProgramUpsertWithWhereUniqueWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramUpsertWithWhereUniqueWithoutParticipantInput)
    upsert?: Array<ProgramUpsertWithWhereUniqueWithoutParticipantInput>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    set?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramWhereUniqueInput], {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>>;
    @Field(() => [ProgramUpdateWithWhereUniqueWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramUpdateWithWhereUniqueWithoutParticipantInput)
    update?: Array<ProgramUpdateWithWhereUniqueWithoutParticipantInput>;
    @Field(() => [ProgramUpdateManyWithWhereWithoutParticipantInput], {nullable:true})
    @Type(() => ProgramUpdateManyWithWhereWithoutParticipantInput)
    updateMany?: Array<ProgramUpdateManyWithWhereWithoutParticipantInput>;
    @Field(() => [ProgramScalarWhereInput], {nullable:true})
    @Type(() => ProgramScalarWhereInput)
    deleteMany?: Array<ProgramScalarWhereInput>;
}

@InputType()
export class ProgramUpdateOneWithoutImagesNestedInput {
    @Field(() => ProgramCreateWithoutImagesInput, {nullable:true})
    @Type(() => ProgramCreateWithoutImagesInput)
    create?: InstanceType<typeof ProgramCreateWithoutImagesInput>;
    @Field(() => ProgramCreateOrConnectWithoutImagesInput, {nullable:true})
    @Type(() => ProgramCreateOrConnectWithoutImagesInput)
    connectOrCreate?: InstanceType<typeof ProgramCreateOrConnectWithoutImagesInput>;
    @Field(() => ProgramUpsertWithoutImagesInput, {nullable:true})
    @Type(() => ProgramUpsertWithoutImagesInput)
    upsert?: InstanceType<typeof ProgramUpsertWithoutImagesInput>;
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    disconnect?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    delete?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => ProgramWhereUniqueInput, {nullable:true})
    @Type(() => ProgramWhereUniqueInput)
    connect?: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
    @Field(() => ProgramUpdateToOneWithWhereWithoutImagesInput, {nullable:true})
    @Type(() => ProgramUpdateToOneWithWhereWithoutImagesInput)
    update?: InstanceType<typeof ProgramUpdateToOneWithWhereWithoutImagesInput>;
}

@InputType()
export class ProgramUpdateToOneWithWhereWithoutImagesInput {
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    where?: InstanceType<typeof ProgramWhereInput>;
    @Field(() => ProgramUpdateWithoutImagesInput, {nullable:false})
    @Type(() => ProgramUpdateWithoutImagesInput)
    data!: InstanceType<typeof ProgramUpdateWithoutImagesInput>;
}

@InputType()
export class ProgramUpdateWithWhereUniqueWithoutCategoryInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
    @Field(() => ProgramUpdateWithoutCategoryInput, {nullable:false})
    @Type(() => ProgramUpdateWithoutCategoryInput)
    data!: InstanceType<typeof ProgramUpdateWithoutCategoryInput>;
}

@InputType()
export class ProgramUpdateWithWhereUniqueWithoutCreatedByInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
    @Field(() => ProgramUpdateWithoutCreatedByInput, {nullable:false})
    @Type(() => ProgramUpdateWithoutCreatedByInput)
    data!: InstanceType<typeof ProgramUpdateWithoutCreatedByInput>;
}

@InputType()
export class ProgramUpdateWithWhereUniqueWithoutParticipantInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
    @Field(() => ProgramUpdateWithoutParticipantInput, {nullable:false})
    @Type(() => ProgramUpdateWithoutParticipantInput)
    data!: InstanceType<typeof ProgramUpdateWithoutParticipantInput>;
}

@InputType()
export class ProgramUpdateWithoutCategoryInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutProgramImageNestedInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUpdateManyWithoutProgramImageNestedInput>;
    @Field(() => UserUpdateOneRequiredWithoutProgramsCreatedNestedInput, {nullable:true})
    createdBy?: InstanceType<typeof UserUpdateOneRequiredWithoutProgramsCreatedNestedInput>;
    @Field(() => UserUpdateManyWithoutProgramsParticipationNestedInput, {nullable:true})
    participant?: InstanceType<typeof UserUpdateManyWithoutProgramsParticipationNestedInput>;
}

@InputType()
export class ProgramUpdateWithoutCreatedByInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutProgramImageNestedInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUpdateManyWithoutProgramImageNestedInput>;
    @Field(() => UserUpdateManyWithoutProgramsParticipationNestedInput, {nullable:true})
    participant?: InstanceType<typeof UserUpdateManyWithoutProgramsParticipationNestedInput>;
    @Field(() => ProgramCategoryUpdateOneRequiredWithoutProgramsNestedInput, {nullable:true})
    category?: InstanceType<typeof ProgramCategoryUpdateOneRequiredWithoutProgramsNestedInput>;
}

@InputType()
export class ProgramUpdateWithoutImagesInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutProgramsCreatedNestedInput, {nullable:true})
    createdBy?: InstanceType<typeof UserUpdateOneRequiredWithoutProgramsCreatedNestedInput>;
    @Field(() => UserUpdateManyWithoutProgramsParticipationNestedInput, {nullable:true})
    participant?: InstanceType<typeof UserUpdateManyWithoutProgramsParticipationNestedInput>;
    @Field(() => ProgramCategoryUpdateOneRequiredWithoutProgramsNestedInput, {nullable:true})
    category?: InstanceType<typeof ProgramCategoryUpdateOneRequiredWithoutProgramsNestedInput>;
}

@InputType()
export class ProgramUpdateWithoutParticipantInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutProgramImageNestedInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUpdateManyWithoutProgramImageNestedInput>;
    @Field(() => UserUpdateOneRequiredWithoutProgramsCreatedNestedInput, {nullable:true})
    createdBy?: InstanceType<typeof UserUpdateOneRequiredWithoutProgramsCreatedNestedInput>;
    @Field(() => ProgramCategoryUpdateOneRequiredWithoutProgramsNestedInput, {nullable:true})
    category?: InstanceType<typeof ProgramCategoryUpdateOneRequiredWithoutProgramsNestedInput>;
}

@InputType()
export class ProgramUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    dueDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutProgramImageNestedInput, {nullable:true})
    Images?: InstanceType<typeof ImagesUpdateManyWithoutProgramImageNestedInput>;
    @Field(() => UserUpdateOneRequiredWithoutProgramsCreatedNestedInput, {nullable:true})
    createdBy?: InstanceType<typeof UserUpdateOneRequiredWithoutProgramsCreatedNestedInput>;
    @Field(() => UserUpdateManyWithoutProgramsParticipationNestedInput, {nullable:true})
    participant?: InstanceType<typeof UserUpdateManyWithoutProgramsParticipationNestedInput>;
    @Field(() => ProgramCategoryUpdateOneRequiredWithoutProgramsNestedInput, {nullable:true})
    category?: InstanceType<typeof ProgramCategoryUpdateOneRequiredWithoutProgramsNestedInput>;
}

@InputType()
export class ProgramUpsertWithWhereUniqueWithoutCategoryInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
    @Field(() => ProgramUpdateWithoutCategoryInput, {nullable:false})
    @Type(() => ProgramUpdateWithoutCategoryInput)
    update!: InstanceType<typeof ProgramUpdateWithoutCategoryInput>;
    @Field(() => ProgramCreateWithoutCategoryInput, {nullable:false})
    @Type(() => ProgramCreateWithoutCategoryInput)
    create!: InstanceType<typeof ProgramCreateWithoutCategoryInput>;
}

@InputType()
export class ProgramUpsertWithWhereUniqueWithoutCreatedByInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
    @Field(() => ProgramUpdateWithoutCreatedByInput, {nullable:false})
    @Type(() => ProgramUpdateWithoutCreatedByInput)
    update!: InstanceType<typeof ProgramUpdateWithoutCreatedByInput>;
    @Field(() => ProgramCreateWithoutCreatedByInput, {nullable:false})
    @Type(() => ProgramCreateWithoutCreatedByInput)
    create!: InstanceType<typeof ProgramCreateWithoutCreatedByInput>;
}

@InputType()
export class ProgramUpsertWithWhereUniqueWithoutParticipantInput {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
    @Field(() => ProgramUpdateWithoutParticipantInput, {nullable:false})
    @Type(() => ProgramUpdateWithoutParticipantInput)
    update!: InstanceType<typeof ProgramUpdateWithoutParticipantInput>;
    @Field(() => ProgramCreateWithoutParticipantInput, {nullable:false})
    @Type(() => ProgramCreateWithoutParticipantInput)
    create!: InstanceType<typeof ProgramCreateWithoutParticipantInput>;
}

@InputType()
export class ProgramUpsertWithoutImagesInput {
    @Field(() => ProgramUpdateWithoutImagesInput, {nullable:false})
    @Type(() => ProgramUpdateWithoutImagesInput)
    update!: InstanceType<typeof ProgramUpdateWithoutImagesInput>;
    @Field(() => ProgramCreateWithoutImagesInput, {nullable:false})
    @Type(() => ProgramCreateWithoutImagesInput)
    create!: InstanceType<typeof ProgramCreateWithoutImagesInput>;
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    where?: InstanceType<typeof ProgramWhereInput>;
}

@InputType()
export class ProgramWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [ProgramWhereInput], {nullable:true})
    AND?: Array<ProgramWhereInput>;
    @Field(() => [ProgramWhereInput], {nullable:true})
    OR?: Array<ProgramWhereInput>;
    @Field(() => [ProgramWhereInput], {nullable:true})
    NOT?: Array<ProgramWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeNullableFilter, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    createdById?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    categoryId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => ImagesListRelationFilter, {nullable:true})
    Images?: InstanceType<typeof ImagesListRelationFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    createdBy?: InstanceType<typeof UserRelationFilter>;
    @Field(() => UserListRelationFilter, {nullable:true})
    participant?: InstanceType<typeof UserListRelationFilter>;
    @Field(() => ProgramCategoryRelationFilter, {nullable:true})
    category?: InstanceType<typeof ProgramCategoryRelationFilter>;
}

@InputType()
export class ProgramWhereInput {
    @Field(() => [ProgramWhereInput], {nullable:true})
    AND?: Array<ProgramWhereInput>;
    @Field(() => [ProgramWhereInput], {nullable:true})
    OR?: Array<ProgramWhereInput>;
    @Field(() => [ProgramWhereInput], {nullable:true})
    NOT?: Array<ProgramWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeNullableFilter, {nullable:true})
    dueDate?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    createdById?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    categoryId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => ImagesListRelationFilter, {nullable:true})
    Images?: InstanceType<typeof ImagesListRelationFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    createdBy?: InstanceType<typeof UserRelationFilter>;
    @Field(() => UserListRelationFilter, {nullable:true})
    participant?: InstanceType<typeof UserListRelationFilter>;
    @Field(() => ProgramCategoryRelationFilter, {nullable:true})
    category?: InstanceType<typeof ProgramCategoryRelationFilter>;
}

@ObjectType()
export class Program {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Date, {nullable:false})
    startDate!: Date;
    @Field(() => Date, {nullable:true})
    dueDate!: Date | null;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => String, {nullable:false})
    createdById!: string;
    @Field(() => Int, {nullable:false})
    categoryId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => [Images], {nullable:true})
    Images?: Array<Images>;
    @Field(() => User, {nullable:false})
    createdBy?: InstanceType<typeof User>;
    @Field(() => [User], {nullable:true})
    participant?: Array<User>;
    @Field(() => ProgramCategory, {nullable:false})
    category?: InstanceType<typeof ProgramCategory>;
    @Field(() => ProgramCount, {nullable:false})
    _count?: InstanceType<typeof ProgramCount>;
}

@ArgsType()
export class UpdateManyProgramArgs {
    @Field(() => ProgramUpdateManyMutationInput, {nullable:false})
    @Type(() => ProgramUpdateManyMutationInput)
    data!: InstanceType<typeof ProgramUpdateManyMutationInput>;
    @Field(() => ProgramWhereInput, {nullable:true})
    @Type(() => ProgramWhereInput)
    where?: InstanceType<typeof ProgramWhereInput>;
}

@ArgsType()
export class UpdateOneProgramArgs {
    @Field(() => ProgramUpdateInput, {nullable:false})
    @Type(() => ProgramUpdateInput)
    data!: InstanceType<typeof ProgramUpdateInput>;
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneProgramArgs {
    @Field(() => ProgramWhereUniqueInput, {nullable:false})
    @Type(() => ProgramWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramWhereUniqueInput, 'id'>;
    @Field(() => ProgramCreateInput, {nullable:false})
    @Type(() => ProgramCreateInput)
    create!: InstanceType<typeof ProgramCreateInput>;
    @Field(() => ProgramUpdateInput, {nullable:false})
    @Type(() => ProgramUpdateInput)
    update!: InstanceType<typeof ProgramUpdateInput>;
}

@ObjectType()
export class AggregateProgramCategory {
    @Field(() => ProgramCategoryCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ProgramCategoryCountAggregate>;
    @Field(() => ProgramCategoryAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ProgramCategoryAvgAggregate>;
    @Field(() => ProgramCategorySumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ProgramCategorySumAggregate>;
    @Field(() => ProgramCategoryMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ProgramCategoryMinAggregate>;
    @Field(() => ProgramCategoryMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ProgramCategoryMaxAggregate>;
}

@ArgsType()
export class CreateManyProgramCategoryArgs {
    @Field(() => [ProgramCategoryCreateManyInput], {nullable:false})
    @Type(() => ProgramCategoryCreateManyInput)
    data!: Array<ProgramCategoryCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneProgramCategoryArgs {
    @Field(() => ProgramCategoryCreateInput, {nullable:false})
    @Type(() => ProgramCategoryCreateInput)
    data!: InstanceType<typeof ProgramCategoryCreateInput>;
}

@ArgsType()
export class DeleteManyProgramCategoryArgs {
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    @Type(() => ProgramCategoryWhereInput)
    where?: InstanceType<typeof ProgramCategoryWhereInput>;
}

@ArgsType()
export class DeleteOneProgramCategoryArgs {
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:false})
    @Type(() => ProgramCategoryWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstProgramCategoryOrThrowArgs {
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    @Type(() => ProgramCategoryWhereInput)
    where?: InstanceType<typeof ProgramCategoryWhereInput>;
    @Field(() => [ProgramCategoryOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProgramCategoryOrderByWithRelationInput>;
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProgramCategoryScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProgramCategoryScalarFieldEnum>;
}

@ArgsType()
export class FindFirstProgramCategoryArgs {
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    @Type(() => ProgramCategoryWhereInput)
    where?: InstanceType<typeof ProgramCategoryWhereInput>;
    @Field(() => [ProgramCategoryOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProgramCategoryOrderByWithRelationInput>;
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProgramCategoryScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProgramCategoryScalarFieldEnum>;
}

@ArgsType()
export class FindManyProgramCategoryArgs {
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    @Type(() => ProgramCategoryWhereInput)
    where?: InstanceType<typeof ProgramCategoryWhereInput>;
    @Field(() => [ProgramCategoryOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProgramCategoryOrderByWithRelationInput>;
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProgramCategoryScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProgramCategoryScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueProgramCategoryOrThrowArgs {
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:false})
    @Type(() => ProgramCategoryWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueProgramCategoryArgs {
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:false})
    @Type(() => ProgramCategoryWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
}

@ArgsType()
export class ProgramCategoryAggregateArgs {
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    @Type(() => ProgramCategoryWhereInput)
    where?: InstanceType<typeof ProgramCategoryWhereInput>;
    @Field(() => [ProgramCategoryOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProgramCategoryOrderByWithRelationInput>;
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ProgramCategoryCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProgramCategoryCountAggregateInput>;
    @Field(() => ProgramCategoryAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProgramCategoryAvgAggregateInput>;
    @Field(() => ProgramCategorySumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProgramCategorySumAggregateInput>;
    @Field(() => ProgramCategoryMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProgramCategoryMinAggregateInput>;
    @Field(() => ProgramCategoryMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProgramCategoryMaxAggregateInput>;
}

@InputType()
export class ProgramCategoryAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
}

@ObjectType()
export class ProgramCategoryAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
}

@InputType()
export class ProgramCategoryAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
}

@InputType()
export class ProgramCategoryCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class ProgramCategoryCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class ProgramCategoryCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@ObjectType()
export class ProgramCategoryCount {
    @Field(() => Int, {nullable:false})
    programs?: number;
}

@InputType()
export class ProgramCategoryCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class ProgramCategoryCreateNestedOneWithoutProgramsInput {
    @Field(() => ProgramCategoryCreateWithoutProgramsInput, {nullable:true})
    @Type(() => ProgramCategoryCreateWithoutProgramsInput)
    create?: InstanceType<typeof ProgramCategoryCreateWithoutProgramsInput>;
    @Field(() => ProgramCategoryCreateOrConnectWithoutProgramsInput, {nullable:true})
    @Type(() => ProgramCategoryCreateOrConnectWithoutProgramsInput)
    connectOrCreate?: InstanceType<typeof ProgramCategoryCreateOrConnectWithoutProgramsInput>;
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:true})
    @Type(() => ProgramCategoryWhereUniqueInput)
    connect?: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
}

@InputType()
export class ProgramCategoryCreateOrConnectWithoutProgramsInput {
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:false})
    @Type(() => ProgramCategoryWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
    @Field(() => ProgramCategoryCreateWithoutProgramsInput, {nullable:false})
    @Type(() => ProgramCategoryCreateWithoutProgramsInput)
    create!: InstanceType<typeof ProgramCategoryCreateWithoutProgramsInput>;
}

@InputType()
export class ProgramCategoryCreateWithoutProgramsInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class ProgramCategoryCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => ProgramCreateNestedManyWithoutCategoryInput, {nullable:true})
    programs?: InstanceType<typeof ProgramCreateNestedManyWithoutCategoryInput>;
}

@ArgsType()
export class ProgramCategoryGroupByArgs {
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    @Type(() => ProgramCategoryWhereInput)
    where?: InstanceType<typeof ProgramCategoryWhereInput>;
    @Field(() => [ProgramCategoryOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<ProgramCategoryOrderByWithAggregationInput>;
    @Field(() => [ProgramCategoryScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof ProgramCategoryScalarFieldEnum>;
    @Field(() => ProgramCategoryScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof ProgramCategoryScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ProgramCategoryCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProgramCategoryCountAggregateInput>;
    @Field(() => ProgramCategoryAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProgramCategoryAvgAggregateInput>;
    @Field(() => ProgramCategorySumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProgramCategorySumAggregateInput>;
    @Field(() => ProgramCategoryMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProgramCategoryMinAggregateInput>;
    @Field(() => ProgramCategoryMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProgramCategoryMaxAggregateInput>;
}

@ObjectType()
export class ProgramCategoryGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => ProgramCategoryCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ProgramCategoryCountAggregate>;
    @Field(() => ProgramCategoryAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ProgramCategoryAvgAggregate>;
    @Field(() => ProgramCategorySumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ProgramCategorySumAggregate>;
    @Field(() => ProgramCategoryMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ProgramCategoryMinAggregate>;
    @Field(() => ProgramCategoryMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ProgramCategoryMaxAggregate>;
}

@InputType()
export class ProgramCategoryMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class ProgramCategoryMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProgramCategoryMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ProgramCategoryMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class ProgramCategoryMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProgramCategoryMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ProgramCategoryOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => ProgramCategoryCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProgramCategoryCountOrderByAggregateInput>;
    @Field(() => ProgramCategoryAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProgramCategoryAvgOrderByAggregateInput>;
    @Field(() => ProgramCategoryMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProgramCategoryMaxOrderByAggregateInput>;
    @Field(() => ProgramCategoryMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProgramCategoryMinOrderByAggregateInput>;
    @Field(() => ProgramCategorySumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProgramCategorySumOrderByAggregateInput>;
}

@InputType()
export class ProgramCategoryOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => ProgramOrderByRelationAggregateInput, {nullable:true})
    programs?: InstanceType<typeof ProgramOrderByRelationAggregateInput>;
}

@InputType()
export class ProgramCategoryRelationFilter {
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    is?: InstanceType<typeof ProgramCategoryWhereInput>;
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    isNot?: InstanceType<typeof ProgramCategoryWhereInput>;
}

@InputType()
export class ProgramCategoryScalarWhereWithAggregatesInput {
    @Field(() => [ProgramCategoryScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<ProgramCategoryScalarWhereWithAggregatesInput>;
    @Field(() => [ProgramCategoryScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<ProgramCategoryScalarWhereWithAggregatesInput>;
    @Field(() => [ProgramCategoryScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<ProgramCategoryScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class ProgramCategorySumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
}

@ObjectType()
export class ProgramCategorySumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
}

@InputType()
export class ProgramCategorySumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
}

@InputType()
export class ProgramCategoryUncheckedCreateWithoutProgramsInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProgramCategoryUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutCategoryInput, {nullable:true})
    programs?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCategoryInput>;
}

@InputType()
export class ProgramCategoryUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProgramCategoryUncheckedUpdateWithoutProgramsInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProgramCategoryUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutCategoryNestedInput, {nullable:true})
    programs?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCategoryNestedInput>;
}

@InputType()
export class ProgramCategoryUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProgramCategoryUpdateOneRequiredWithoutProgramsNestedInput {
    @Field(() => ProgramCategoryCreateWithoutProgramsInput, {nullable:true})
    @Type(() => ProgramCategoryCreateWithoutProgramsInput)
    create?: InstanceType<typeof ProgramCategoryCreateWithoutProgramsInput>;
    @Field(() => ProgramCategoryCreateOrConnectWithoutProgramsInput, {nullable:true})
    @Type(() => ProgramCategoryCreateOrConnectWithoutProgramsInput)
    connectOrCreate?: InstanceType<typeof ProgramCategoryCreateOrConnectWithoutProgramsInput>;
    @Field(() => ProgramCategoryUpsertWithoutProgramsInput, {nullable:true})
    @Type(() => ProgramCategoryUpsertWithoutProgramsInput)
    upsert?: InstanceType<typeof ProgramCategoryUpsertWithoutProgramsInput>;
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:true})
    @Type(() => ProgramCategoryWhereUniqueInput)
    connect?: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
    @Field(() => ProgramCategoryUpdateToOneWithWhereWithoutProgramsInput, {nullable:true})
    @Type(() => ProgramCategoryUpdateToOneWithWhereWithoutProgramsInput)
    update?: InstanceType<typeof ProgramCategoryUpdateToOneWithWhereWithoutProgramsInput>;
}

@InputType()
export class ProgramCategoryUpdateToOneWithWhereWithoutProgramsInput {
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    @Type(() => ProgramCategoryWhereInput)
    where?: InstanceType<typeof ProgramCategoryWhereInput>;
    @Field(() => ProgramCategoryUpdateWithoutProgramsInput, {nullable:false})
    @Type(() => ProgramCategoryUpdateWithoutProgramsInput)
    data!: InstanceType<typeof ProgramCategoryUpdateWithoutProgramsInput>;
}

@InputType()
export class ProgramCategoryUpdateWithoutProgramsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProgramCategoryUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ProgramUpdateManyWithoutCategoryNestedInput, {nullable:true})
    programs?: InstanceType<typeof ProgramUpdateManyWithoutCategoryNestedInput>;
}

@InputType()
export class ProgramCategoryUpsertWithoutProgramsInput {
    @Field(() => ProgramCategoryUpdateWithoutProgramsInput, {nullable:false})
    @Type(() => ProgramCategoryUpdateWithoutProgramsInput)
    update!: InstanceType<typeof ProgramCategoryUpdateWithoutProgramsInput>;
    @Field(() => ProgramCategoryCreateWithoutProgramsInput, {nullable:false})
    @Type(() => ProgramCategoryCreateWithoutProgramsInput)
    create!: InstanceType<typeof ProgramCategoryCreateWithoutProgramsInput>;
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    @Type(() => ProgramCategoryWhereInput)
    where?: InstanceType<typeof ProgramCategoryWhereInput>;
}

@InputType()
export class ProgramCategoryWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [ProgramCategoryWhereInput], {nullable:true})
    AND?: Array<ProgramCategoryWhereInput>;
    @Field(() => [ProgramCategoryWhereInput], {nullable:true})
    OR?: Array<ProgramCategoryWhereInput>;
    @Field(() => [ProgramCategoryWhereInput], {nullable:true})
    NOT?: Array<ProgramCategoryWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => ProgramListRelationFilter, {nullable:true})
    programs?: InstanceType<typeof ProgramListRelationFilter>;
}

@InputType()
export class ProgramCategoryWhereInput {
    @Field(() => [ProgramCategoryWhereInput], {nullable:true})
    AND?: Array<ProgramCategoryWhereInput>;
    @Field(() => [ProgramCategoryWhereInput], {nullable:true})
    OR?: Array<ProgramCategoryWhereInput>;
    @Field(() => [ProgramCategoryWhereInput], {nullable:true})
    NOT?: Array<ProgramCategoryWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => ProgramListRelationFilter, {nullable:true})
    programs?: InstanceType<typeof ProgramListRelationFilter>;
}

@ObjectType()
export class ProgramCategory {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => [Program], {nullable:true})
    programs?: Array<Program>;
    @Field(() => ProgramCategoryCount, {nullable:false})
    _count?: InstanceType<typeof ProgramCategoryCount>;
}

@ArgsType()
export class UpdateManyProgramCategoryArgs {
    @Field(() => ProgramCategoryUpdateManyMutationInput, {nullable:false})
    @Type(() => ProgramCategoryUpdateManyMutationInput)
    data!: InstanceType<typeof ProgramCategoryUpdateManyMutationInput>;
    @Field(() => ProgramCategoryWhereInput, {nullable:true})
    @Type(() => ProgramCategoryWhereInput)
    where?: InstanceType<typeof ProgramCategoryWhereInput>;
}

@ArgsType()
export class UpdateOneProgramCategoryArgs {
    @Field(() => ProgramCategoryUpdateInput, {nullable:false})
    @Type(() => ProgramCategoryUpdateInput)
    data!: InstanceType<typeof ProgramCategoryUpdateInput>;
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:false})
    @Type(() => ProgramCategoryWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneProgramCategoryArgs {
    @Field(() => ProgramCategoryWhereUniqueInput, {nullable:false})
    @Type(() => ProgramCategoryWhereUniqueInput)
    where!: Prisma.AtLeast<ProgramCategoryWhereUniqueInput, 'id'>;
    @Field(() => ProgramCategoryCreateInput, {nullable:false})
    @Type(() => ProgramCategoryCreateInput)
    create!: InstanceType<typeof ProgramCategoryCreateInput>;
    @Field(() => ProgramCategoryUpdateInput, {nullable:false})
    @Type(() => ProgramCategoryUpdateInput)
    update!: InstanceType<typeof ProgramCategoryUpdateInput>;
}

@ObjectType()
export class AggregateProject {
    @Field(() => ProjectCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ProjectCountAggregate>;
    @Field(() => ProjectAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ProjectAvgAggregate>;
    @Field(() => ProjectSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ProjectSumAggregate>;
    @Field(() => ProjectMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ProjectMinAggregate>;
    @Field(() => ProjectMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ProjectMaxAggregate>;
}

@ArgsType()
export class CreateManyProjectArgs {
    @Field(() => [ProjectCreateManyInput], {nullable:false})
    @Type(() => ProjectCreateManyInput)
    data!: Array<ProjectCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneProjectArgs {
    @Field(() => ProjectCreateInput, {nullable:false})
    @Type(() => ProjectCreateInput)
    data!: InstanceType<typeof ProjectCreateInput>;
}

@ArgsType()
export class DeleteManyProjectArgs {
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
}

@ArgsType()
export class DeleteOneProjectArgs {
    @Field(() => ProjectWhereUniqueInput, {nullable:false})
    @Type(() => ProjectWhereUniqueInput)
    where!: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
}

@ArgsType()
export class FindFirstProjectOrThrowArgs {
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => [ProjectOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProjectOrderByWithRelationInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProjectScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProjectScalarFieldEnum>;
}

@ArgsType()
export class FindFirstProjectArgs {
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => [ProjectOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProjectOrderByWithRelationInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProjectScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProjectScalarFieldEnum>;
}

@ArgsType()
export class FindManyProjectArgs {
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => [ProjectOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProjectOrderByWithRelationInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProjectScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProjectScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueProjectOrThrowArgs {
    @Field(() => ProjectWhereUniqueInput, {nullable:false})
    @Type(() => ProjectWhereUniqueInput)
    where!: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
}

@ArgsType()
export class FindUniqueProjectArgs {
    @Field(() => ProjectWhereUniqueInput, {nullable:false})
    @Type(() => ProjectWhereUniqueInput)
    where!: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
}

@ArgsType()
export class ProjectAggregateArgs {
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => [ProjectOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProjectOrderByWithRelationInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ProjectCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProjectCountAggregateInput>;
    @Field(() => ProjectAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProjectAvgAggregateInput>;
    @Field(() => ProjectSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProjectSumAggregateInput>;
    @Field(() => ProjectMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProjectMinAggregateInput>;
    @Field(() => ProjectMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProjectMaxAggregateInput>;
}

@InputType()
export class ProjectAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    returnRate?: true;
    @Field(() => Boolean, {nullable:true})
    goalAmount?: true;
    @Field(() => Boolean, {nullable:true})
    minimumInvestment?: true;
    @Field(() => Boolean, {nullable:true})
    maxInvestor?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
}

@ObjectType()
export class ProjectAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    returnRate?: number;
    @Field(() => Float, {nullable:true})
    goalAmount?: number;
    @Field(() => Float, {nullable:true})
    minimumInvestment?: number;
    @Field(() => Float, {nullable:true})
    maxInvestor?: number;
    @Field(() => Float, {nullable:true})
    accountId?: number;
}

@InputType()
export class ProjectAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    returnRate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    goalAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    minimumInvestment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    maxInvestor?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
}

@InputType()
export class ProjectCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    projectCategory?: true;
    @Field(() => Boolean, {nullable:true})
    startDate?: true;
    @Field(() => Boolean, {nullable:true})
    endDate?: true;
    @Field(() => Boolean, {nullable:true})
    returnRate?: true;
    @Field(() => Boolean, {nullable:true})
    goalAmount?: true;
    @Field(() => Boolean, {nullable:true})
    minimumInvestment?: true;
    @Field(() => Boolean, {nullable:true})
    maxInvestor?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class ProjectCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    description!: number;
    @Field(() => Int, {nullable:false})
    projectCategory!: number;
    @Field(() => Int, {nullable:false})
    startDate!: number;
    @Field(() => Int, {nullable:false})
    endDate!: number;
    @Field(() => Int, {nullable:false})
    returnRate!: number;
    @Field(() => Int, {nullable:false})
    goalAmount!: number;
    @Field(() => Int, {nullable:false})
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    maxInvestor!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class ProjectCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    endDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    returnRate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    goalAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    minimumInvestment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    maxInvestor?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@ObjectType()
export class ProjectCount {
    @Field(() => Int, {nullable:false})
    images?: number;
    @Field(() => Int, {nullable:false})
    orderCart?: number;
}

@InputType()
export class ProjectCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    returnRate!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    maxInvestor!: number;
    @HideField()
    accountId!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class ProjectCreateNestedOneWithoutAccountInput {
    @Field(() => ProjectCreateWithoutAccountInput, {nullable:true})
    @Type(() => ProjectCreateWithoutAccountInput)
    create?: InstanceType<typeof ProjectCreateWithoutAccountInput>;
    @Field(() => ProjectCreateOrConnectWithoutAccountInput, {nullable:true})
    @Type(() => ProjectCreateOrConnectWithoutAccountInput)
    connectOrCreate?: InstanceType<typeof ProjectCreateOrConnectWithoutAccountInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    connect?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
}

@InputType()
export class ProjectCreateNestedOneWithoutImagesInput {
    @Field(() => ProjectCreateWithoutImagesInput, {nullable:true})
    @Type(() => ProjectCreateWithoutImagesInput)
    create?: InstanceType<typeof ProjectCreateWithoutImagesInput>;
    @Field(() => ProjectCreateOrConnectWithoutImagesInput, {nullable:true})
    @Type(() => ProjectCreateOrConnectWithoutImagesInput)
    connectOrCreate?: InstanceType<typeof ProjectCreateOrConnectWithoutImagesInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    connect?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
}

@InputType()
export class ProjectCreateNestedOneWithoutOrderCartInput {
    @Field(() => ProjectCreateWithoutOrderCartInput, {nullable:true})
    @Type(() => ProjectCreateWithoutOrderCartInput)
    create?: InstanceType<typeof ProjectCreateWithoutOrderCartInput>;
    @Field(() => ProjectCreateOrConnectWithoutOrderCartInput, {nullable:true})
    @Type(() => ProjectCreateOrConnectWithoutOrderCartInput)
    connectOrCreate?: InstanceType<typeof ProjectCreateOrConnectWithoutOrderCartInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    connect?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
}

@InputType()
export class ProjectCreateOrConnectWithoutAccountInput {
    @Field(() => ProjectWhereUniqueInput, {nullable:false})
    @Type(() => ProjectWhereUniqueInput)
    where!: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => ProjectCreateWithoutAccountInput, {nullable:false})
    @Type(() => ProjectCreateWithoutAccountInput)
    create!: InstanceType<typeof ProjectCreateWithoutAccountInput>;
}

@InputType()
export class ProjectCreateOrConnectWithoutImagesInput {
    @Field(() => ProjectWhereUniqueInput, {nullable:false})
    @Type(() => ProjectWhereUniqueInput)
    where!: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => ProjectCreateWithoutImagesInput, {nullable:false})
    @Type(() => ProjectCreateWithoutImagesInput)
    create!: InstanceType<typeof ProjectCreateWithoutImagesInput>;
}

@InputType()
export class ProjectCreateOrConnectWithoutOrderCartInput {
    @Field(() => ProjectWhereUniqueInput, {nullable:false})
    @Type(() => ProjectWhereUniqueInput)
    where!: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => ProjectCreateWithoutOrderCartInput, {nullable:false})
    @Type(() => ProjectCreateWithoutOrderCartInput)
    create!: InstanceType<typeof ProjectCreateWithoutOrderCartInput>;
}

@InputType()
export class ProjectCreateWithoutAccountInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    returnRate!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    maxInvestor!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutProjectImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesCreateNestedManyWithoutProjectImageInput>;
    @HideField()
    orderCart?: InstanceType<typeof CartCreateNestedManyWithoutProjectItemInput>;
}

@InputType()
export class ProjectCreateWithoutImagesInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    returnRate!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    maxInvestor!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    orderCart?: InstanceType<typeof CartCreateNestedManyWithoutProjectItemInput>;
    @HideField()
    account!: InstanceType<typeof AccountCreateNestedOneWithoutProjectInput>;
}

@InputType()
export class ProjectCreateWithoutOrderCartInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    returnRate!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    maxInvestor!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutProjectImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesCreateNestedManyWithoutProjectImageInput>;
    @HideField()
    account!: InstanceType<typeof AccountCreateNestedOneWithoutProjectInput>;
}

@InputType()
export class ProjectCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    returnRate!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    maxInvestor!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutProjectImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesCreateNestedManyWithoutProjectImageInput>;
    @HideField()
    orderCart?: InstanceType<typeof CartCreateNestedManyWithoutProjectItemInput>;
    @HideField()
    account!: InstanceType<typeof AccountCreateNestedOneWithoutProjectInput>;
}

@ArgsType()
export class ProjectGroupByArgs {
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => [ProjectOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<ProjectOrderByWithAggregationInput>;
    @Field(() => [ProjectScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof ProjectScalarFieldEnum>;
    @Field(() => ProjectScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof ProjectScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ProjectCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProjectCountAggregateInput>;
    @Field(() => ProjectAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProjectAvgAggregateInput>;
    @Field(() => ProjectSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProjectSumAggregateInput>;
    @Field(() => ProjectMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProjectMinAggregateInput>;
    @Field(() => ProjectMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProjectMaxAggregateInput>;
}

@ObjectType()
export class ProjectGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    returnRate!: number;
    @Field(() => Float, {nullable:false})
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    maxInvestor!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => ProjectCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ProjectCountAggregate>;
    @Field(() => ProjectAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ProjectAvgAggregate>;
    @Field(() => ProjectSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ProjectSumAggregate>;
    @Field(() => ProjectMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ProjectMinAggregate>;
    @Field(() => ProjectMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ProjectMaxAggregate>;
}

@InputType()
export class ProjectMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    projectCategory?: true;
    @Field(() => Boolean, {nullable:true})
    startDate?: true;
    @Field(() => Boolean, {nullable:true})
    endDate?: true;
    @Field(() => Boolean, {nullable:true})
    returnRate?: true;
    @Field(() => Boolean, {nullable:true})
    goalAmount?: true;
    @Field(() => Boolean, {nullable:true})
    minimumInvestment?: true;
    @Field(() => Boolean, {nullable:true})
    maxInvestor?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class ProjectMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => ProjectCategory, {nullable:true})
    projectCategory?: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:true})
    startDate?: Date | string;
    @Field(() => Date, {nullable:true})
    endDate?: Date | string;
    @Field(() => Float, {nullable:true})
    returnRate?: number;
    @Field(() => Float, {nullable:true})
    goalAmount?: number;
    @Field(() => Float, {nullable:true})
    minimumInvestment?: number;
    @Field(() => Int, {nullable:true})
    maxInvestor?: number;
    @Field(() => Int, {nullable:true})
    accountId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProjectMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    endDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    returnRate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    goalAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    minimumInvestment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    maxInvestor?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ProjectMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @Field(() => Boolean, {nullable:true})
    projectCategory?: true;
    @Field(() => Boolean, {nullable:true})
    startDate?: true;
    @Field(() => Boolean, {nullable:true})
    endDate?: true;
    @Field(() => Boolean, {nullable:true})
    returnRate?: true;
    @Field(() => Boolean, {nullable:true})
    goalAmount?: true;
    @Field(() => Boolean, {nullable:true})
    minimumInvestment?: true;
    @Field(() => Boolean, {nullable:true})
    maxInvestor?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class ProjectMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => ProjectCategory, {nullable:true})
    projectCategory?: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:true})
    startDate?: Date | string;
    @Field(() => Date, {nullable:true})
    endDate?: Date | string;
    @Field(() => Float, {nullable:true})
    returnRate?: number;
    @Field(() => Float, {nullable:true})
    goalAmount?: number;
    @Field(() => Float, {nullable:true})
    minimumInvestment?: number;
    @Field(() => Int, {nullable:true})
    maxInvestor?: number;
    @Field(() => Int, {nullable:true})
    accountId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ProjectMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    endDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    returnRate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    goalAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    minimumInvestment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    maxInvestor?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ProjectNullableRelationFilter {
    @Field(() => ProjectWhereInput, {nullable:true})
    is?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    isNot?: InstanceType<typeof ProjectWhereInput>;
}

@InputType()
export class ProjectOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    endDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    returnRate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    goalAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    minimumInvestment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    maxInvestor?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => ProjectCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProjectCountOrderByAggregateInput>;
    @Field(() => ProjectAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProjectAvgOrderByAggregateInput>;
    @Field(() => ProjectMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProjectMaxOrderByAggregateInput>;
    @Field(() => ProjectMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProjectMinOrderByAggregateInput>;
    @Field(() => ProjectSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProjectSumOrderByAggregateInput>;
}

@InputType()
export class ProjectOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    projectCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    startDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    endDate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    returnRate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    goalAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    minimumInvestment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    maxInvestor?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => ImagesOrderByRelationAggregateInput, {nullable:true})
    images?: InstanceType<typeof ImagesOrderByRelationAggregateInput>;
    @Field(() => CartOrderByRelationAggregateInput, {nullable:true})
    orderCart?: InstanceType<typeof CartOrderByRelationAggregateInput>;
    @Field(() => AccountOrderByWithRelationInput, {nullable:true})
    account?: InstanceType<typeof AccountOrderByWithRelationInput>;
}

@InputType()
export class ProjectScalarWhereWithAggregatesInput {
    @Field(() => [ProjectScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<ProjectScalarWhereWithAggregatesInput>;
    @Field(() => [ProjectScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<ProjectScalarWhereWithAggregatesInput>;
    @Field(() => [ProjectScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<ProjectScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    description?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => EnumProjectCategoryWithAggregatesFilter, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    endDate?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    returnRate?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    goalAmount?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    minimumInvestment?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    maxInvestor?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    accountId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class ProjectSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    returnRate?: true;
    @Field(() => Boolean, {nullable:true})
    goalAmount?: true;
    @Field(() => Boolean, {nullable:true})
    minimumInvestment?: true;
    @Field(() => Boolean, {nullable:true})
    maxInvestor?: true;
    @Field(() => Boolean, {nullable:true})
    accountId?: true;
}

@ObjectType()
export class ProjectSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    returnRate?: number;
    @Field(() => Float, {nullable:true})
    goalAmount?: number;
    @Field(() => Float, {nullable:true})
    minimumInvestment?: number;
    @Field(() => Int, {nullable:true})
    maxInvestor?: number;
    @Field(() => Int, {nullable:true})
    accountId?: number;
}

@InputType()
export class ProjectSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    returnRate?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    goalAmount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    minimumInvestment?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    maxInvestor?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    accountId?: keyof typeof SortOrder;
}

@InputType()
export class ProjectUncheckedCreateNestedOneWithoutAccountInput {
    @Field(() => ProjectCreateWithoutAccountInput, {nullable:true})
    @Type(() => ProjectCreateWithoutAccountInput)
    create?: InstanceType<typeof ProjectCreateWithoutAccountInput>;
    @Field(() => ProjectCreateOrConnectWithoutAccountInput, {nullable:true})
    @Type(() => ProjectCreateOrConnectWithoutAccountInput)
    connectOrCreate?: InstanceType<typeof ProjectCreateOrConnectWithoutAccountInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    connect?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
}

@InputType()
export class ProjectUncheckedCreateWithoutAccountInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    returnRate!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    maxInvestor!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutProjectImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutProjectImageInput>;
    @Field(() => CartUncheckedCreateNestedManyWithoutProjectItemInput, {nullable:true})
    orderCart?: InstanceType<typeof CartUncheckedCreateNestedManyWithoutProjectItemInput>;
}

@InputType()
export class ProjectUncheckedCreateWithoutImagesInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    returnRate!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    maxInvestor!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => CartUncheckedCreateNestedManyWithoutProjectItemInput, {nullable:true})
    orderCart?: InstanceType<typeof CartUncheckedCreateNestedManyWithoutProjectItemInput>;
}

@InputType()
export class ProjectUncheckedCreateWithoutOrderCartInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    returnRate!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    maxInvestor!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutProjectImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutProjectImageInput>;
}

@InputType()
export class ProjectUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date | string;
    @Field(() => Date, {nullable:false})
    endDate!: Date | string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    returnRate!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNotEmpty()
    @Validator.IsNumber()
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    maxInvestor!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutProjectImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutProjectImageInput>;
    @Field(() => CartUncheckedCreateNestedManyWithoutProjectItemInput, {nullable:true})
    orderCart?: InstanceType<typeof CartUncheckedCreateNestedManyWithoutProjectItemInput>;
}

@InputType()
export class ProjectUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProjectUncheckedUpdateOneWithoutAccountNestedInput {
    @Field(() => ProjectCreateWithoutAccountInput, {nullable:true})
    @Type(() => ProjectCreateWithoutAccountInput)
    create?: InstanceType<typeof ProjectCreateWithoutAccountInput>;
    @Field(() => ProjectCreateOrConnectWithoutAccountInput, {nullable:true})
    @Type(() => ProjectCreateOrConnectWithoutAccountInput)
    connectOrCreate?: InstanceType<typeof ProjectCreateOrConnectWithoutAccountInput>;
    @Field(() => ProjectUpsertWithoutAccountInput, {nullable:true})
    @Type(() => ProjectUpsertWithoutAccountInput)
    upsert?: InstanceType<typeof ProjectUpsertWithoutAccountInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    disconnect?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    delete?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    connect?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => ProjectUpdateToOneWithWhereWithoutAccountInput, {nullable:true})
    @Type(() => ProjectUpdateToOneWithWhereWithoutAccountInput)
    update?: InstanceType<typeof ProjectUpdateToOneWithWhereWithoutAccountInput>;
}

@InputType()
export class ProjectUncheckedUpdateWithoutAccountInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutProjectImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutProjectImageNestedInput>;
    @Field(() => CartUncheckedUpdateManyWithoutProjectItemNestedInput, {nullable:true})
    orderCart?: InstanceType<typeof CartUncheckedUpdateManyWithoutProjectItemNestedInput>;
}

@InputType()
export class ProjectUncheckedUpdateWithoutImagesInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => CartUncheckedUpdateManyWithoutProjectItemNestedInput, {nullable:true})
    orderCart?: InstanceType<typeof CartUncheckedUpdateManyWithoutProjectItemNestedInput>;
}

@InputType()
export class ProjectUncheckedUpdateWithoutOrderCartInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutProjectImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutProjectImageNestedInput>;
}

@InputType()
export class ProjectUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    accountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutProjectImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutProjectImageNestedInput>;
    @Field(() => CartUncheckedUpdateManyWithoutProjectItemNestedInput, {nullable:true})
    orderCart?: InstanceType<typeof CartUncheckedUpdateManyWithoutProjectItemNestedInput>;
}

@InputType()
export class ProjectUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ProjectUpdateOneWithoutAccountNestedInput {
    @Field(() => ProjectCreateWithoutAccountInput, {nullable:true})
    @Type(() => ProjectCreateWithoutAccountInput)
    create?: InstanceType<typeof ProjectCreateWithoutAccountInput>;
    @Field(() => ProjectCreateOrConnectWithoutAccountInput, {nullable:true})
    @Type(() => ProjectCreateOrConnectWithoutAccountInput)
    connectOrCreate?: InstanceType<typeof ProjectCreateOrConnectWithoutAccountInput>;
    @Field(() => ProjectUpsertWithoutAccountInput, {nullable:true})
    @Type(() => ProjectUpsertWithoutAccountInput)
    upsert?: InstanceType<typeof ProjectUpsertWithoutAccountInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    disconnect?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    delete?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    connect?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => ProjectUpdateToOneWithWhereWithoutAccountInput, {nullable:true})
    @Type(() => ProjectUpdateToOneWithWhereWithoutAccountInput)
    update?: InstanceType<typeof ProjectUpdateToOneWithWhereWithoutAccountInput>;
}

@InputType()
export class ProjectUpdateOneWithoutImagesNestedInput {
    @Field(() => ProjectCreateWithoutImagesInput, {nullable:true})
    @Type(() => ProjectCreateWithoutImagesInput)
    create?: InstanceType<typeof ProjectCreateWithoutImagesInput>;
    @Field(() => ProjectCreateOrConnectWithoutImagesInput, {nullable:true})
    @Type(() => ProjectCreateOrConnectWithoutImagesInput)
    connectOrCreate?: InstanceType<typeof ProjectCreateOrConnectWithoutImagesInput>;
    @Field(() => ProjectUpsertWithoutImagesInput, {nullable:true})
    @Type(() => ProjectUpsertWithoutImagesInput)
    upsert?: InstanceType<typeof ProjectUpsertWithoutImagesInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    disconnect?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    delete?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    connect?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => ProjectUpdateToOneWithWhereWithoutImagesInput, {nullable:true})
    @Type(() => ProjectUpdateToOneWithWhereWithoutImagesInput)
    update?: InstanceType<typeof ProjectUpdateToOneWithWhereWithoutImagesInput>;
}

@InputType()
export class ProjectUpdateOneWithoutOrderCartNestedInput {
    @Field(() => ProjectCreateWithoutOrderCartInput, {nullable:true})
    @Type(() => ProjectCreateWithoutOrderCartInput)
    create?: InstanceType<typeof ProjectCreateWithoutOrderCartInput>;
    @Field(() => ProjectCreateOrConnectWithoutOrderCartInput, {nullable:true})
    @Type(() => ProjectCreateOrConnectWithoutOrderCartInput)
    connectOrCreate?: InstanceType<typeof ProjectCreateOrConnectWithoutOrderCartInput>;
    @Field(() => ProjectUpsertWithoutOrderCartInput, {nullable:true})
    @Type(() => ProjectUpsertWithoutOrderCartInput)
    upsert?: InstanceType<typeof ProjectUpsertWithoutOrderCartInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    disconnect?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    delete?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:true})
    @Type(() => ProjectWhereUniqueInput)
    connect?: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => ProjectUpdateToOneWithWhereWithoutOrderCartInput, {nullable:true})
    @Type(() => ProjectUpdateToOneWithWhereWithoutOrderCartInput)
    update?: InstanceType<typeof ProjectUpdateToOneWithWhereWithoutOrderCartInput>;
}

@InputType()
export class ProjectUpdateToOneWithWhereWithoutAccountInput {
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectUpdateWithoutAccountInput, {nullable:false})
    @Type(() => ProjectUpdateWithoutAccountInput)
    data!: InstanceType<typeof ProjectUpdateWithoutAccountInput>;
}

@InputType()
export class ProjectUpdateToOneWithWhereWithoutImagesInput {
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectUpdateWithoutImagesInput, {nullable:false})
    @Type(() => ProjectUpdateWithoutImagesInput)
    data!: InstanceType<typeof ProjectUpdateWithoutImagesInput>;
}

@InputType()
export class ProjectUpdateToOneWithWhereWithoutOrderCartInput {
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
    @Field(() => ProjectUpdateWithoutOrderCartInput, {nullable:false})
    @Type(() => ProjectUpdateWithoutOrderCartInput)
    data!: InstanceType<typeof ProjectUpdateWithoutOrderCartInput>;
}

@InputType()
export class ProjectUpdateWithoutAccountInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutProjectImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUpdateManyWithoutProjectImageNestedInput>;
    @HideField()
    orderCart?: InstanceType<typeof CartUpdateManyWithoutProjectItemNestedInput>;
}

@InputType()
export class ProjectUpdateWithoutImagesInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    orderCart?: InstanceType<typeof CartUpdateManyWithoutProjectItemNestedInput>;
    @HideField()
    account?: InstanceType<typeof AccountUpdateOneRequiredWithoutProjectNestedInput>;
}

@InputType()
export class ProjectUpdateWithoutOrderCartInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutProjectImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUpdateManyWithoutProjectImageNestedInput>;
    @HideField()
    account?: InstanceType<typeof AccountUpdateOneRequiredWithoutProjectNestedInput>;
}

@InputType()
export class ProjectUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumProjectCategoryFieldUpdateOperationsInput, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    returnRate?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    goalAmount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    minimumInvestment?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutProjectImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUpdateManyWithoutProjectImageNestedInput>;
    @HideField()
    orderCart?: InstanceType<typeof CartUpdateManyWithoutProjectItemNestedInput>;
    @HideField()
    account?: InstanceType<typeof AccountUpdateOneRequiredWithoutProjectNestedInput>;
}

@InputType()
export class ProjectUpsertWithoutAccountInput {
    @Field(() => ProjectUpdateWithoutAccountInput, {nullable:false})
    @Type(() => ProjectUpdateWithoutAccountInput)
    update!: InstanceType<typeof ProjectUpdateWithoutAccountInput>;
    @Field(() => ProjectCreateWithoutAccountInput, {nullable:false})
    @Type(() => ProjectCreateWithoutAccountInput)
    create!: InstanceType<typeof ProjectCreateWithoutAccountInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
}

@InputType()
export class ProjectUpsertWithoutImagesInput {
    @Field(() => ProjectUpdateWithoutImagesInput, {nullable:false})
    @Type(() => ProjectUpdateWithoutImagesInput)
    update!: InstanceType<typeof ProjectUpdateWithoutImagesInput>;
    @Field(() => ProjectCreateWithoutImagesInput, {nullable:false})
    @Type(() => ProjectCreateWithoutImagesInput)
    create!: InstanceType<typeof ProjectCreateWithoutImagesInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
}

@InputType()
export class ProjectUpsertWithoutOrderCartInput {
    @Field(() => ProjectUpdateWithoutOrderCartInput, {nullable:false})
    @Type(() => ProjectUpdateWithoutOrderCartInput)
    update!: InstanceType<typeof ProjectUpdateWithoutOrderCartInput>;
    @Field(() => ProjectCreateWithoutOrderCartInput, {nullable:false})
    @Type(() => ProjectCreateWithoutOrderCartInput)
    create!: InstanceType<typeof ProjectCreateWithoutOrderCartInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
}

@InputType()
export class ProjectWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    accountId?: number;
    @Field(() => [ProjectWhereInput], {nullable:true})
    AND?: Array<ProjectWhereInput>;
    @Field(() => [ProjectWhereInput], {nullable:true})
    OR?: Array<ProjectWhereInput>;
    @Field(() => [ProjectWhereInput], {nullable:true})
    NOT?: Array<ProjectWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => EnumProjectCategoryFilter, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    returnRate?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    goalAmount?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    minimumInvestment?: InstanceType<typeof FloatFilter>;
    @Field(() => IntFilter, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => ImagesListRelationFilter, {nullable:true})
    images?: InstanceType<typeof ImagesListRelationFilter>;
    @Field(() => CartListRelationFilter, {nullable:true})
    orderCart?: InstanceType<typeof CartListRelationFilter>;
    @Field(() => AccountRelationFilter, {nullable:true})
    account?: InstanceType<typeof AccountRelationFilter>;
}

@InputType()
export class ProjectWhereInput {
    @Field(() => [ProjectWhereInput], {nullable:true})
    AND?: Array<ProjectWhereInput>;
    @Field(() => [ProjectWhereInput], {nullable:true})
    OR?: Array<ProjectWhereInput>;
    @Field(() => [ProjectWhereInput], {nullable:true})
    NOT?: Array<ProjectWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @Field(() => EnumProjectCategoryFilter, {nullable:true})
    projectCategory?: InstanceType<typeof EnumProjectCategoryFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    startDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    endDate?: InstanceType<typeof DateTimeFilter>;
    @Field(() => FloatFilter, {nullable:true})
    returnRate?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    goalAmount?: InstanceType<typeof FloatFilter>;
    @Field(() => FloatFilter, {nullable:true})
    minimumInvestment?: InstanceType<typeof FloatFilter>;
    @Field(() => IntFilter, {nullable:true})
    maxInvestor?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    accountId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => ImagesListRelationFilter, {nullable:true})
    images?: InstanceType<typeof ImagesListRelationFilter>;
    @Field(() => CartListRelationFilter, {nullable:true})
    orderCart?: InstanceType<typeof CartListRelationFilter>;
    @Field(() => AccountRelationFilter, {nullable:true})
    account?: InstanceType<typeof AccountRelationFilter>;
}

@ObjectType()
export class Project {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => ProjectCategory, {nullable:false})
    projectCategory!: keyof typeof ProjectCategory;
    @Field(() => Date, {nullable:false})
    startDate!: Date;
    @Field(() => Date, {nullable:false})
    endDate!: Date;
    @Field(() => Float, {nullable:false})
    returnRate!: number;
    @Field(() => Float, {nullable:false})
    goalAmount!: number;
    @Field(() => Float, {nullable:false})
    minimumInvestment!: number;
    @Field(() => Int, {nullable:false})
    maxInvestor!: number;
    @Field(() => Int, {nullable:false})
    accountId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => [Images], {nullable:true})
    images?: Array<Images>;
    @Field(() => [Cart], {nullable:true})
    orderCart?: Array<Cart>;
    @Field(() => Account, {nullable:false})
    account?: InstanceType<typeof Account>;
    @Field(() => ProjectCount, {nullable:false})
    _count?: InstanceType<typeof ProjectCount>;
}

@ArgsType()
export class UpdateManyProjectArgs {
    @Field(() => ProjectUpdateManyMutationInput, {nullable:false})
    @Type(() => ProjectUpdateManyMutationInput)
    data!: InstanceType<typeof ProjectUpdateManyMutationInput>;
    @Field(() => ProjectWhereInput, {nullable:true})
    @Type(() => ProjectWhereInput)
    where?: InstanceType<typeof ProjectWhereInput>;
}

@ArgsType()
export class UpdateOneProjectArgs {
    @Field(() => ProjectUpdateInput, {nullable:false})
    @Type(() => ProjectUpdateInput)
    data!: InstanceType<typeof ProjectUpdateInput>;
    @Field(() => ProjectWhereUniqueInput, {nullable:false})
    @Type(() => ProjectWhereUniqueInput)
    where!: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
}

@ArgsType()
export class UpsertOneProjectArgs {
    @Field(() => ProjectWhereUniqueInput, {nullable:false})
    @Type(() => ProjectWhereUniqueInput)
    where!: Prisma.AtLeast<ProjectWhereUniqueInput, 'id' | 'accountId'>;
    @Field(() => ProjectCreateInput, {nullable:false})
    @Type(() => ProjectCreateInput)
    create!: InstanceType<typeof ProjectCreateInput>;
    @Field(() => ProjectUpdateInput, {nullable:false})
    @Type(() => ProjectUpdateInput)
    update!: InstanceType<typeof ProjectUpdateInput>;
}

@ObjectType()
export class AggregateProvince {
    @Field(() => ProvinceCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ProvinceCountAggregate>;
    @Field(() => ProvinceAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ProvinceAvgAggregate>;
    @Field(() => ProvinceSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ProvinceSumAggregate>;
    @Field(() => ProvinceMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ProvinceMinAggregate>;
    @Field(() => ProvinceMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ProvinceMaxAggregate>;
}

@ArgsType()
export class CreateManyProvinceArgs {
    @Field(() => [ProvinceCreateManyInput], {nullable:false})
    @Type(() => ProvinceCreateManyInput)
    data!: Array<ProvinceCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneProvinceArgs {
    @Field(() => ProvinceCreateInput, {nullable:false})
    @Type(() => ProvinceCreateInput)
    data!: InstanceType<typeof ProvinceCreateInput>;
}

@ArgsType()
export class DeleteManyProvinceArgs {
    @Field(() => ProvinceWhereInput, {nullable:true})
    @Type(() => ProvinceWhereInput)
    where?: InstanceType<typeof ProvinceWhereInput>;
}

@ArgsType()
export class DeleteOneProvinceArgs {
    @Field(() => ProvinceWhereUniqueInput, {nullable:false})
    @Type(() => ProvinceWhereUniqueInput)
    where!: Prisma.AtLeast<ProvinceWhereUniqueInput, 'id' | 'name'>;
}

@ArgsType()
export class FindFirstProvinceOrThrowArgs {
    @Field(() => ProvinceWhereInput, {nullable:true})
    @Type(() => ProvinceWhereInput)
    where?: InstanceType<typeof ProvinceWhereInput>;
    @Field(() => [ProvinceOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProvinceOrderByWithRelationInput>;
    @Field(() => ProvinceWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProvinceWhereUniqueInput, 'id' | 'name'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProvinceScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProvinceScalarFieldEnum>;
}

@ArgsType()
export class FindFirstProvinceArgs {
    @Field(() => ProvinceWhereInput, {nullable:true})
    @Type(() => ProvinceWhereInput)
    where?: InstanceType<typeof ProvinceWhereInput>;
    @Field(() => [ProvinceOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProvinceOrderByWithRelationInput>;
    @Field(() => ProvinceWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProvinceWhereUniqueInput, 'id' | 'name'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProvinceScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProvinceScalarFieldEnum>;
}

@ArgsType()
export class FindManyProvinceArgs {
    @Field(() => ProvinceWhereInput, {nullable:true})
    @Type(() => ProvinceWhereInput)
    where?: InstanceType<typeof ProvinceWhereInput>;
    @Field(() => [ProvinceOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProvinceOrderByWithRelationInput>;
    @Field(() => ProvinceWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProvinceWhereUniqueInput, 'id' | 'name'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ProvinceScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ProvinceScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueProvinceOrThrowArgs {
    @Field(() => ProvinceWhereUniqueInput, {nullable:false})
    @Type(() => ProvinceWhereUniqueInput)
    where!: Prisma.AtLeast<ProvinceWhereUniqueInput, 'id' | 'name'>;
}

@ArgsType()
export class FindUniqueProvinceArgs {
    @Field(() => ProvinceWhereUniqueInput, {nullable:false})
    @Type(() => ProvinceWhereUniqueInput)
    where!: Prisma.AtLeast<ProvinceWhereUniqueInput, 'id' | 'name'>;
}

@ArgsType()
export class ProvinceAggregateArgs {
    @Field(() => ProvinceWhereInput, {nullable:true})
    @Type(() => ProvinceWhereInput)
    where?: InstanceType<typeof ProvinceWhereInput>;
    @Field(() => [ProvinceOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ProvinceOrderByWithRelationInput>;
    @Field(() => ProvinceWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ProvinceWhereUniqueInput, 'id' | 'name'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ProvinceCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProvinceCountAggregateInput>;
    @Field(() => ProvinceAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProvinceAvgAggregateInput>;
    @Field(() => ProvinceSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProvinceSumAggregateInput>;
    @Field(() => ProvinceMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProvinceMinAggregateInput>;
    @Field(() => ProvinceMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProvinceMaxAggregateInput>;
}

@InputType()
export class ProvinceAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
}

@ObjectType()
export class ProvinceAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
}

@InputType()
export class ProvinceAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
}

@InputType()
export class ProvinceCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class ProvinceCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class ProvinceCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
}

@ObjectType()
export class ProvinceCount {
    @Field(() => Int, {nullable:false})
    cities?: number;
}

@InputType()
export class ProvinceCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
}

@InputType()
export class ProvinceCreateNestedOneWithoutCitiesInput {
    @Field(() => ProvinceCreateWithoutCitiesInput, {nullable:true})
    @Type(() => ProvinceCreateWithoutCitiesInput)
    create?: InstanceType<typeof ProvinceCreateWithoutCitiesInput>;
    @Field(() => ProvinceCreateOrConnectWithoutCitiesInput, {nullable:true})
    @Type(() => ProvinceCreateOrConnectWithoutCitiesInput)
    connectOrCreate?: InstanceType<typeof ProvinceCreateOrConnectWithoutCitiesInput>;
    @Field(() => ProvinceWhereUniqueInput, {nullable:true})
    @Type(() => ProvinceWhereUniqueInput)
    connect?: Prisma.AtLeast<ProvinceWhereUniqueInput, 'id' | 'name'>;
}

@InputType()
export class ProvinceCreateOrConnectWithoutCitiesInput {
    @Field(() => ProvinceWhereUniqueInput, {nullable:false})
    @Type(() => ProvinceWhereUniqueInput)
    where!: Prisma.AtLeast<ProvinceWhereUniqueInput, 'id' | 'name'>;
    @Field(() => ProvinceCreateWithoutCitiesInput, {nullable:false})
    @Type(() => ProvinceCreateWithoutCitiesInput)
    create!: InstanceType<typeof ProvinceCreateWithoutCitiesInput>;
}

@InputType()
export class ProvinceCreateWithoutCitiesInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
}

@InputType()
export class ProvinceCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => CityCreateNestedManyWithoutProvinceInput, {nullable:true})
    cities?: InstanceType<typeof CityCreateNestedManyWithoutProvinceInput>;
}

@ArgsType()
export class ProvinceGroupByArgs {
    @Field(() => ProvinceWhereInput, {nullable:true})
    @Type(() => ProvinceWhereInput)
    where?: InstanceType<typeof ProvinceWhereInput>;
    @Field(() => [ProvinceOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<ProvinceOrderByWithAggregationInput>;
    @Field(() => [ProvinceScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof ProvinceScalarFieldEnum>;
    @Field(() => ProvinceScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof ProvinceScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ProvinceCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProvinceCountAggregateInput>;
    @Field(() => ProvinceAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProvinceAvgAggregateInput>;
    @Field(() => ProvinceSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProvinceSumAggregateInput>;
    @Field(() => ProvinceMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProvinceMinAggregateInput>;
    @Field(() => ProvinceMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProvinceMaxAggregateInput>;
}

@ObjectType()
export class ProvinceGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => ProvinceCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ProvinceCountAggregate>;
    @Field(() => ProvinceAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ProvinceAvgAggregate>;
    @Field(() => ProvinceSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ProvinceSumAggregate>;
    @Field(() => ProvinceMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ProvinceMinAggregate>;
    @Field(() => ProvinceMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ProvinceMaxAggregate>;
}

@InputType()
export class ProvinceMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
}

@ObjectType()
export class ProvinceMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
}

@InputType()
export class ProvinceMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
}

@InputType()
export class ProvinceMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
}

@ObjectType()
export class ProvinceMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
}

@InputType()
export class ProvinceMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
}

@InputType()
export class ProvinceOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => ProvinceCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ProvinceCountOrderByAggregateInput>;
    @Field(() => ProvinceAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ProvinceAvgOrderByAggregateInput>;
    @Field(() => ProvinceMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ProvinceMaxOrderByAggregateInput>;
    @Field(() => ProvinceMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ProvinceMinOrderByAggregateInput>;
    @Field(() => ProvinceSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ProvinceSumOrderByAggregateInput>;
}

@InputType()
export class ProvinceOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => CityOrderByRelationAggregateInput, {nullable:true})
    cities?: InstanceType<typeof CityOrderByRelationAggregateInput>;
}

@InputType()
export class ProvinceRelationFilter {
    @Field(() => ProvinceWhereInput, {nullable:true})
    is?: InstanceType<typeof ProvinceWhereInput>;
    @Field(() => ProvinceWhereInput, {nullable:true})
    isNot?: InstanceType<typeof ProvinceWhereInput>;
}

@InputType()
export class ProvinceScalarWhereWithAggregatesInput {
    @Field(() => [ProvinceScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<ProvinceScalarWhereWithAggregatesInput>;
    @Field(() => [ProvinceScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<ProvinceScalarWhereWithAggregatesInput>;
    @Field(() => [ProvinceScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<ProvinceScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
}

@InputType()
export class ProvinceSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
}

@ObjectType()
export class ProvinceSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
}

@InputType()
export class ProvinceSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
}

@InputType()
export class ProvinceUncheckedCreateWithoutCitiesInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
}

@InputType()
export class ProvinceUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name!: string;
    @Field(() => CityUncheckedCreateNestedManyWithoutProvinceInput, {nullable:true})
    cities?: InstanceType<typeof CityUncheckedCreateNestedManyWithoutProvinceInput>;
}

@InputType()
export class ProvinceUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class ProvinceUncheckedUpdateWithoutCitiesInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class ProvinceUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => CityUncheckedUpdateManyWithoutProvinceNestedInput, {nullable:true})
    cities?: InstanceType<typeof CityUncheckedUpdateManyWithoutProvinceNestedInput>;
}

@InputType()
export class ProvinceUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class ProvinceUpdateOneRequiredWithoutCitiesNestedInput {
    @Field(() => ProvinceCreateWithoutCitiesInput, {nullable:true})
    @Type(() => ProvinceCreateWithoutCitiesInput)
    create?: InstanceType<typeof ProvinceCreateWithoutCitiesInput>;
    @Field(() => ProvinceCreateOrConnectWithoutCitiesInput, {nullable:true})
    @Type(() => ProvinceCreateOrConnectWithoutCitiesInput)
    connectOrCreate?: InstanceType<typeof ProvinceCreateOrConnectWithoutCitiesInput>;
    @Field(() => ProvinceUpsertWithoutCitiesInput, {nullable:true})
    @Type(() => ProvinceUpsertWithoutCitiesInput)
    upsert?: InstanceType<typeof ProvinceUpsertWithoutCitiesInput>;
    @Field(() => ProvinceWhereUniqueInput, {nullable:true})
    @Type(() => ProvinceWhereUniqueInput)
    connect?: Prisma.AtLeast<ProvinceWhereUniqueInput, 'id' | 'name'>;
    @Field(() => ProvinceUpdateToOneWithWhereWithoutCitiesInput, {nullable:true})
    @Type(() => ProvinceUpdateToOneWithWhereWithoutCitiesInput)
    update?: InstanceType<typeof ProvinceUpdateToOneWithWhereWithoutCitiesInput>;
}

@InputType()
export class ProvinceUpdateToOneWithWhereWithoutCitiesInput {
    @Field(() => ProvinceWhereInput, {nullable:true})
    @Type(() => ProvinceWhereInput)
    where?: InstanceType<typeof ProvinceWhereInput>;
    @Field(() => ProvinceUpdateWithoutCitiesInput, {nullable:false})
    @Type(() => ProvinceUpdateWithoutCitiesInput)
    data!: InstanceType<typeof ProvinceUpdateWithoutCitiesInput>;
}

@InputType()
export class ProvinceUpdateWithoutCitiesInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class ProvinceUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => CityUpdateManyWithoutProvinceNestedInput, {nullable:true})
    cities?: InstanceType<typeof CityUpdateManyWithoutProvinceNestedInput>;
}

@InputType()
export class ProvinceUpsertWithoutCitiesInput {
    @Field(() => ProvinceUpdateWithoutCitiesInput, {nullable:false})
    @Type(() => ProvinceUpdateWithoutCitiesInput)
    update!: InstanceType<typeof ProvinceUpdateWithoutCitiesInput>;
    @Field(() => ProvinceCreateWithoutCitiesInput, {nullable:false})
    @Type(() => ProvinceCreateWithoutCitiesInput)
    create!: InstanceType<typeof ProvinceCreateWithoutCitiesInput>;
    @Field(() => ProvinceWhereInput, {nullable:true})
    @Type(() => ProvinceWhereInput)
    where?: InstanceType<typeof ProvinceWhereInput>;
}

@InputType()
export class ProvinceWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.IsNotEmpty()
    name?: string;
    @Field(() => [ProvinceWhereInput], {nullable:true})
    AND?: Array<ProvinceWhereInput>;
    @Field(() => [ProvinceWhereInput], {nullable:true})
    OR?: Array<ProvinceWhereInput>;
    @Field(() => [ProvinceWhereInput], {nullable:true})
    NOT?: Array<ProvinceWhereInput>;
    @Field(() => CityListRelationFilter, {nullable:true})
    cities?: InstanceType<typeof CityListRelationFilter>;
}

@InputType()
export class ProvinceWhereInput {
    @Field(() => [ProvinceWhereInput], {nullable:true})
    AND?: Array<ProvinceWhereInput>;
    @Field(() => [ProvinceWhereInput], {nullable:true})
    OR?: Array<ProvinceWhereInput>;
    @Field(() => [ProvinceWhereInput], {nullable:true})
    NOT?: Array<ProvinceWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => CityListRelationFilter, {nullable:true})
    cities?: InstanceType<typeof CityListRelationFilter>;
}

@ObjectType()
export class Province {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @HideField()
    cities?: Array<City>;
    @Field(() => ProvinceCount, {nullable:false})
    _count?: InstanceType<typeof ProvinceCount>;
}

@ArgsType()
export class UpdateManyProvinceArgs {
    @Field(() => ProvinceUpdateManyMutationInput, {nullable:false})
    @Type(() => ProvinceUpdateManyMutationInput)
    data!: InstanceType<typeof ProvinceUpdateManyMutationInput>;
    @Field(() => ProvinceWhereInput, {nullable:true})
    @Type(() => ProvinceWhereInput)
    where?: InstanceType<typeof ProvinceWhereInput>;
}

@ArgsType()
export class UpdateOneProvinceArgs {
    @Field(() => ProvinceUpdateInput, {nullable:false})
    @Type(() => ProvinceUpdateInput)
    data!: InstanceType<typeof ProvinceUpdateInput>;
    @Field(() => ProvinceWhereUniqueInput, {nullable:false})
    @Type(() => ProvinceWhereUniqueInput)
    where!: Prisma.AtLeast<ProvinceWhereUniqueInput, 'id' | 'name'>;
}

@ArgsType()
export class UpsertOneProvinceArgs {
    @Field(() => ProvinceWhereUniqueInput, {nullable:false})
    @Type(() => ProvinceWhereUniqueInput)
    where!: Prisma.AtLeast<ProvinceWhereUniqueInput, 'id' | 'name'>;
    @Field(() => ProvinceCreateInput, {nullable:false})
    @Type(() => ProvinceCreateInput)
    create!: InstanceType<typeof ProvinceCreateInput>;
    @Field(() => ProvinceUpdateInput, {nullable:false})
    @Type(() => ProvinceUpdateInput)
    update!: InstanceType<typeof ProvinceUpdateInput>;
}

@ObjectType()
export class AggregateReward {
    @Field(() => RewardCountAggregate, {nullable:true})
    _count?: InstanceType<typeof RewardCountAggregate>;
    @Field(() => RewardAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof RewardAvgAggregate>;
    @Field(() => RewardSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof RewardSumAggregate>;
    @Field(() => RewardMinAggregate, {nullable:true})
    _min?: InstanceType<typeof RewardMinAggregate>;
    @Field(() => RewardMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof RewardMaxAggregate>;
}

@ArgsType()
export class CreateManyRewardArgs {
    @Field(() => [RewardCreateManyInput], {nullable:false})
    @Type(() => RewardCreateManyInput)
    data!: Array<RewardCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneRewardArgs {
    @Field(() => RewardCreateInput, {nullable:false})
    @Type(() => RewardCreateInput)
    data!: InstanceType<typeof RewardCreateInput>;
}

@ArgsType()
export class DeleteManyRewardArgs {
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
}

@ArgsType()
export class DeleteOneRewardArgs {
    @Field(() => RewardWhereUniqueInput, {nullable:false})
    @Type(() => RewardWhereUniqueInput)
    where!: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstRewardOrThrowArgs {
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
    @Field(() => [RewardOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<RewardOrderByWithRelationInput>;
    @Field(() => RewardWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [RewardScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof RewardScalarFieldEnum>;
}

@ArgsType()
export class FindFirstRewardArgs {
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
    @Field(() => [RewardOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<RewardOrderByWithRelationInput>;
    @Field(() => RewardWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [RewardScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof RewardScalarFieldEnum>;
}

@ArgsType()
export class FindManyRewardArgs {
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
    @Field(() => [RewardOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<RewardOrderByWithRelationInput>;
    @Field(() => RewardWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [RewardScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof RewardScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueRewardOrThrowArgs {
    @Field(() => RewardWhereUniqueInput, {nullable:false})
    @Type(() => RewardWhereUniqueInput)
    where!: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueRewardArgs {
    @Field(() => RewardWhereUniqueInput, {nullable:false})
    @Type(() => RewardWhereUniqueInput)
    where!: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
}

@ArgsType()
export class RewardAggregateArgs {
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
    @Field(() => [RewardOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<RewardOrderByWithRelationInput>;
    @Field(() => RewardWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => RewardCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof RewardCountAggregateInput>;
    @Field(() => RewardAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof RewardAvgAggregateInput>;
    @Field(() => RewardSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof RewardSumAggregateInput>;
    @Field(() => RewardMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof RewardMinAggregateInput>;
    @Field(() => RewardMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof RewardMaxAggregateInput>;
}

@InputType()
export class RewardAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    pointCost?: true;
}

@ObjectType()
export class RewardAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    pointCost?: number;
}

@InputType()
export class RewardAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointCost?: keyof typeof SortOrder;
}

@InputType()
export class RewardCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    pointCost?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @HideField()
    createdAt?: true;
    @HideField()
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class RewardCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    pointCost!: number;
    @Field(() => Int, {nullable:false})
    description!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class RewardCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointCost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
}

@ObjectType()
export class RewardCount {
    @Field(() => Int, {nullable:false})
    images?: number;
    @Field(() => Int, {nullable:false})
    RewardClaim?: number;
}

@InputType()
export class RewardCreateManyInput {
    @HideField()
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    pointCost!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class RewardCreateNestedOneWithoutImagesInput {
    @Field(() => RewardCreateWithoutImagesInput, {nullable:true})
    @Type(() => RewardCreateWithoutImagesInput)
    create?: InstanceType<typeof RewardCreateWithoutImagesInput>;
    @Field(() => RewardCreateOrConnectWithoutImagesInput, {nullable:true})
    @Type(() => RewardCreateOrConnectWithoutImagesInput)
    connectOrCreate?: InstanceType<typeof RewardCreateOrConnectWithoutImagesInput>;
    @Field(() => RewardWhereUniqueInput, {nullable:true})
    @Type(() => RewardWhereUniqueInput)
    connect?: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
}

@InputType()
export class RewardCreateNestedOneWithoutRewardClaimInput {
    @Field(() => RewardCreateWithoutRewardClaimInput, {nullable:true})
    @Type(() => RewardCreateWithoutRewardClaimInput)
    create?: InstanceType<typeof RewardCreateWithoutRewardClaimInput>;
    @Field(() => RewardCreateOrConnectWithoutRewardClaimInput, {nullable:true})
    @Type(() => RewardCreateOrConnectWithoutRewardClaimInput)
    connectOrCreate?: InstanceType<typeof RewardCreateOrConnectWithoutRewardClaimInput>;
    @Field(() => RewardWhereUniqueInput, {nullable:true})
    @Type(() => RewardWhereUniqueInput)
    connect?: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
}

@InputType()
export class RewardCreateOrConnectWithoutImagesInput {
    @Field(() => RewardWhereUniqueInput, {nullable:false})
    @Type(() => RewardWhereUniqueInput)
    where!: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
    @Field(() => RewardCreateWithoutImagesInput, {nullable:false})
    @Type(() => RewardCreateWithoutImagesInput)
    create!: InstanceType<typeof RewardCreateWithoutImagesInput>;
}

@InputType()
export class RewardCreateOrConnectWithoutRewardClaimInput {
    @Field(() => RewardWhereUniqueInput, {nullable:false})
    @Type(() => RewardWhereUniqueInput)
    where!: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
    @Field(() => RewardCreateWithoutRewardClaimInput, {nullable:false})
    @Type(() => RewardCreateWithoutRewardClaimInput)
    create!: InstanceType<typeof RewardCreateWithoutRewardClaimInput>;
}

@InputType()
export class RewardCreateWithoutImagesInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    pointCost!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    RewardClaim?: InstanceType<typeof RewardClaimCreateNestedManyWithoutRewardInput>;
}

@InputType()
export class RewardCreateWithoutRewardClaimInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    pointCost!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutRewardImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesCreateNestedManyWithoutRewardImageInput>;
}

@InputType()
export class RewardCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    pointCost!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => ImagesCreateNestedManyWithoutRewardImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesCreateNestedManyWithoutRewardImageInput>;
    @HideField()
    RewardClaim?: InstanceType<typeof RewardClaimCreateNestedManyWithoutRewardInput>;
}

@ArgsType()
export class RewardGroupByArgs {
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
    @Field(() => [RewardOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<RewardOrderByWithAggregationInput>;
    @Field(() => [RewardScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof RewardScalarFieldEnum>;
    @Field(() => RewardScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof RewardScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => RewardCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof RewardCountAggregateInput>;
    @Field(() => RewardAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof RewardAvgAggregateInput>;
    @Field(() => RewardSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof RewardSumAggregateInput>;
    @Field(() => RewardMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof RewardMinAggregateInput>;
    @Field(() => RewardMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof RewardMaxAggregateInput>;
}

@ObjectType()
export class RewardGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Float, {nullable:false})
    pointCost!: number;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => RewardCountAggregate, {nullable:true})
    _count?: InstanceType<typeof RewardCountAggregate>;
    @Field(() => RewardAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof RewardAvgAggregate>;
    @Field(() => RewardSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof RewardSumAggregate>;
    @Field(() => RewardMinAggregate, {nullable:true})
    _min?: InstanceType<typeof RewardMinAggregate>;
    @Field(() => RewardMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof RewardMaxAggregate>;
}

@InputType()
export class RewardMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    pointCost?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @HideField()
    createdAt?: true;
    @HideField()
    updatedAt?: true;
}

@ObjectType()
export class RewardMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Float, {nullable:true})
    pointCost?: number;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class RewardMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointCost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class RewardMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    pointCost?: true;
    @Field(() => Boolean, {nullable:true})
    description?: true;
    @HideField()
    createdAt?: true;
    @HideField()
    updatedAt?: true;
}

@ObjectType()
export class RewardMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Float, {nullable:true})
    pointCost?: number;
    @Field(() => String, {nullable:true})
    description?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class RewardMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointCost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class RewardNullableRelationFilter {
    @Field(() => RewardWhereInput, {nullable:true})
    is?: InstanceType<typeof RewardWhereInput>;
    @Field(() => RewardWhereInput, {nullable:true})
    isNot?: InstanceType<typeof RewardWhereInput>;
}

@InputType()
export class RewardOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointCost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
    @Field(() => RewardCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof RewardCountOrderByAggregateInput>;
    @Field(() => RewardAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof RewardAvgOrderByAggregateInput>;
    @Field(() => RewardMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof RewardMaxOrderByAggregateInput>;
    @Field(() => RewardMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof RewardMinOrderByAggregateInput>;
    @Field(() => RewardSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof RewardSumOrderByAggregateInput>;
}

@InputType()
export class RewardOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointCost?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    description?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
    @Field(() => ImagesOrderByRelationAggregateInput, {nullable:true})
    images?: InstanceType<typeof ImagesOrderByRelationAggregateInput>;
    @Field(() => RewardClaimOrderByRelationAggregateInput, {nullable:true})
    RewardClaim?: InstanceType<typeof RewardClaimOrderByRelationAggregateInput>;
}

@InputType()
export class RewardRelationFilter {
    @Field(() => RewardWhereInput, {nullable:true})
    is?: InstanceType<typeof RewardWhereInput>;
    @Field(() => RewardWhereInput, {nullable:true})
    isNot?: InstanceType<typeof RewardWhereInput>;
}

@InputType()
export class RewardScalarWhereWithAggregatesInput {
    @Field(() => [RewardScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<RewardScalarWhereWithAggregatesInput>;
    @Field(() => [RewardScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<RewardScalarWhereWithAggregatesInput>;
    @Field(() => [RewardScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<RewardScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    pointCost?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    description?: InstanceType<typeof StringWithAggregatesFilter>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class RewardSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    pointCost?: true;
}

@ObjectType()
export class RewardSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    pointCost?: number;
}

@InputType()
export class RewardSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    pointCost?: keyof typeof SortOrder;
}

@InputType()
export class RewardUncheckedCreateWithoutImagesInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    pointCost!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => RewardClaimUncheckedCreateNestedManyWithoutRewardInput, {nullable:true})
    RewardClaim?: InstanceType<typeof RewardClaimUncheckedCreateNestedManyWithoutRewardInput>;
}

@InputType()
export class RewardUncheckedCreateWithoutRewardClaimInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    pointCost!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutRewardImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutRewardImageInput>;
}

@InputType()
export class RewardUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsNotEmpty()
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    pointCost!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(10)
    @Validator.IsNotEmpty()
    description!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => ImagesUncheckedCreateNestedManyWithoutRewardImageInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedCreateNestedManyWithoutRewardImageInput>;
    @Field(() => RewardClaimUncheckedCreateNestedManyWithoutRewardInput, {nullable:true})
    RewardClaim?: InstanceType<typeof RewardClaimUncheckedCreateNestedManyWithoutRewardInput>;
}

@InputType()
export class RewardUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    pointCost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class RewardUncheckedUpdateWithoutImagesInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    pointCost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => RewardClaimUncheckedUpdateManyWithoutRewardNestedInput, {nullable:true})
    RewardClaim?: InstanceType<typeof RewardClaimUncheckedUpdateManyWithoutRewardNestedInput>;
}

@InputType()
export class RewardUncheckedUpdateWithoutRewardClaimInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    pointCost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutRewardImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutRewardImageNestedInput>;
}

@InputType()
export class RewardUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    pointCost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUncheckedUpdateManyWithoutRewardImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUncheckedUpdateManyWithoutRewardImageNestedInput>;
    @Field(() => RewardClaimUncheckedUpdateManyWithoutRewardNestedInput, {nullable:true})
    RewardClaim?: InstanceType<typeof RewardClaimUncheckedUpdateManyWithoutRewardNestedInput>;
}

@InputType()
export class RewardUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    pointCost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class RewardUpdateOneRequiredWithoutRewardClaimNestedInput {
    @Field(() => RewardCreateWithoutRewardClaimInput, {nullable:true})
    @Type(() => RewardCreateWithoutRewardClaimInput)
    create?: InstanceType<typeof RewardCreateWithoutRewardClaimInput>;
    @Field(() => RewardCreateOrConnectWithoutRewardClaimInput, {nullable:true})
    @Type(() => RewardCreateOrConnectWithoutRewardClaimInput)
    connectOrCreate?: InstanceType<typeof RewardCreateOrConnectWithoutRewardClaimInput>;
    @Field(() => RewardUpsertWithoutRewardClaimInput, {nullable:true})
    @Type(() => RewardUpsertWithoutRewardClaimInput)
    upsert?: InstanceType<typeof RewardUpsertWithoutRewardClaimInput>;
    @Field(() => RewardWhereUniqueInput, {nullable:true})
    @Type(() => RewardWhereUniqueInput)
    connect?: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
    @Field(() => RewardUpdateToOneWithWhereWithoutRewardClaimInput, {nullable:true})
    @Type(() => RewardUpdateToOneWithWhereWithoutRewardClaimInput)
    update?: InstanceType<typeof RewardUpdateToOneWithWhereWithoutRewardClaimInput>;
}

@InputType()
export class RewardUpdateOneWithoutImagesNestedInput {
    @Field(() => RewardCreateWithoutImagesInput, {nullable:true})
    @Type(() => RewardCreateWithoutImagesInput)
    create?: InstanceType<typeof RewardCreateWithoutImagesInput>;
    @Field(() => RewardCreateOrConnectWithoutImagesInput, {nullable:true})
    @Type(() => RewardCreateOrConnectWithoutImagesInput)
    connectOrCreate?: InstanceType<typeof RewardCreateOrConnectWithoutImagesInput>;
    @Field(() => RewardUpsertWithoutImagesInput, {nullable:true})
    @Type(() => RewardUpsertWithoutImagesInput)
    upsert?: InstanceType<typeof RewardUpsertWithoutImagesInput>;
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    disconnect?: InstanceType<typeof RewardWhereInput>;
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    delete?: InstanceType<typeof RewardWhereInput>;
    @Field(() => RewardWhereUniqueInput, {nullable:true})
    @Type(() => RewardWhereUniqueInput)
    connect?: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
    @Field(() => RewardUpdateToOneWithWhereWithoutImagesInput, {nullable:true})
    @Type(() => RewardUpdateToOneWithWhereWithoutImagesInput)
    update?: InstanceType<typeof RewardUpdateToOneWithWhereWithoutImagesInput>;
}

@InputType()
export class RewardUpdateToOneWithWhereWithoutImagesInput {
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
    @Field(() => RewardUpdateWithoutImagesInput, {nullable:false})
    @Type(() => RewardUpdateWithoutImagesInput)
    data!: InstanceType<typeof RewardUpdateWithoutImagesInput>;
}

@InputType()
export class RewardUpdateToOneWithWhereWithoutRewardClaimInput {
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
    @Field(() => RewardUpdateWithoutRewardClaimInput, {nullable:false})
    @Type(() => RewardUpdateWithoutRewardClaimInput)
    data!: InstanceType<typeof RewardUpdateWithoutRewardClaimInput>;
}

@InputType()
export class RewardUpdateWithoutImagesInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    pointCost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    RewardClaim?: InstanceType<typeof RewardClaimUpdateManyWithoutRewardNestedInput>;
}

@InputType()
export class RewardUpdateWithoutRewardClaimInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    pointCost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutRewardImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUpdateManyWithoutRewardImageNestedInput>;
}

@InputType()
export class RewardUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    pointCost?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    description?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => ImagesUpdateManyWithoutRewardImageNestedInput, {nullable:true})
    images?: InstanceType<typeof ImagesUpdateManyWithoutRewardImageNestedInput>;
    @HideField()
    RewardClaim?: InstanceType<typeof RewardClaimUpdateManyWithoutRewardNestedInput>;
}

@InputType()
export class RewardUpsertWithoutImagesInput {
    @Field(() => RewardUpdateWithoutImagesInput, {nullable:false})
    @Type(() => RewardUpdateWithoutImagesInput)
    update!: InstanceType<typeof RewardUpdateWithoutImagesInput>;
    @Field(() => RewardCreateWithoutImagesInput, {nullable:false})
    @Type(() => RewardCreateWithoutImagesInput)
    create!: InstanceType<typeof RewardCreateWithoutImagesInput>;
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
}

@InputType()
export class RewardUpsertWithoutRewardClaimInput {
    @Field(() => RewardUpdateWithoutRewardClaimInput, {nullable:false})
    @Type(() => RewardUpdateWithoutRewardClaimInput)
    update!: InstanceType<typeof RewardUpdateWithoutRewardClaimInput>;
    @Field(() => RewardCreateWithoutRewardClaimInput, {nullable:false})
    @Type(() => RewardCreateWithoutRewardClaimInput)
    create!: InstanceType<typeof RewardCreateWithoutRewardClaimInput>;
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
}

@InputType()
export class RewardWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [RewardWhereInput], {nullable:true})
    AND?: Array<RewardWhereInput>;
    @Field(() => [RewardWhereInput], {nullable:true})
    OR?: Array<RewardWhereInput>;
    @Field(() => [RewardWhereInput], {nullable:true})
    NOT?: Array<RewardWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    pointCost?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => ImagesListRelationFilter, {nullable:true})
    images?: InstanceType<typeof ImagesListRelationFilter>;
    @Field(() => RewardClaimListRelationFilter, {nullable:true})
    RewardClaim?: InstanceType<typeof RewardClaimListRelationFilter>;
}

@InputType()
export class RewardWhereInput {
    @Field(() => [RewardWhereInput], {nullable:true})
    AND?: Array<RewardWhereInput>;
    @Field(() => [RewardWhereInput], {nullable:true})
    OR?: Array<RewardWhereInput>;
    @Field(() => [RewardWhereInput], {nullable:true})
    NOT?: Array<RewardWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    pointCost?: InstanceType<typeof FloatFilter>;
    @Field(() => StringFilter, {nullable:true})
    description?: InstanceType<typeof StringFilter>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => ImagesListRelationFilter, {nullable:true})
    images?: InstanceType<typeof ImagesListRelationFilter>;
    @Field(() => RewardClaimListRelationFilter, {nullable:true})
    RewardClaim?: InstanceType<typeof RewardClaimListRelationFilter>;
}

@ObjectType()
export class Reward {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Float, {nullable:false})
    pointCost!: number;
    @Field(() => String, {nullable:false})
    description!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => [Images], {nullable:true})
    images?: Array<Images>;
    @Field(() => [RewardClaim], {nullable:true})
    RewardClaim?: Array<RewardClaim>;
    @Field(() => RewardCount, {nullable:false})
    _count?: InstanceType<typeof RewardCount>;
}

@ArgsType()
export class UpdateManyRewardArgs {
    @Field(() => RewardUpdateManyMutationInput, {nullable:false})
    @Type(() => RewardUpdateManyMutationInput)
    data!: InstanceType<typeof RewardUpdateManyMutationInput>;
    @Field(() => RewardWhereInput, {nullable:true})
    @Type(() => RewardWhereInput)
    where?: InstanceType<typeof RewardWhereInput>;
}

@ArgsType()
export class UpdateOneRewardArgs {
    @Field(() => RewardUpdateInput, {nullable:false})
    @Type(() => RewardUpdateInput)
    data!: InstanceType<typeof RewardUpdateInput>;
    @Field(() => RewardWhereUniqueInput, {nullable:false})
    @Type(() => RewardWhereUniqueInput)
    where!: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneRewardArgs {
    @Field(() => RewardWhereUniqueInput, {nullable:false})
    @Type(() => RewardWhereUniqueInput)
    where!: Prisma.AtLeast<RewardWhereUniqueInput, 'id'>;
    @Field(() => RewardCreateInput, {nullable:false})
    @Type(() => RewardCreateInput)
    create!: InstanceType<typeof RewardCreateInput>;
    @Field(() => RewardUpdateInput, {nullable:false})
    @Type(() => RewardUpdateInput)
    update!: InstanceType<typeof RewardUpdateInput>;
}

@ObjectType()
export class AggregateRewardClaim {
    @Field(() => RewardClaimCountAggregate, {nullable:true})
    _count?: InstanceType<typeof RewardClaimCountAggregate>;
    @Field(() => RewardClaimAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof RewardClaimAvgAggregate>;
    @Field(() => RewardClaimSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof RewardClaimSumAggregate>;
    @Field(() => RewardClaimMinAggregate, {nullable:true})
    _min?: InstanceType<typeof RewardClaimMinAggregate>;
    @Field(() => RewardClaimMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof RewardClaimMaxAggregate>;
}

@ArgsType()
export class CreateManyRewardClaimArgs {
    @Field(() => [RewardClaimCreateManyInput], {nullable:false})
    @Type(() => RewardClaimCreateManyInput)
    data!: Array<RewardClaimCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneRewardClaimArgs {
    @Field(() => RewardClaimCreateInput, {nullable:false})
    @Type(() => RewardClaimCreateInput)
    data!: InstanceType<typeof RewardClaimCreateInput>;
}

@ArgsType()
export class DeleteManyRewardClaimArgs {
    @Field(() => RewardClaimWhereInput, {nullable:true})
    @Type(() => RewardClaimWhereInput)
    where?: InstanceType<typeof RewardClaimWhereInput>;
}

@ArgsType()
export class DeleteOneRewardClaimArgs {
    @Field(() => RewardClaimWhereUniqueInput, {nullable:false})
    @Type(() => RewardClaimWhereUniqueInput)
    where!: Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstRewardClaimOrThrowArgs {
    @Field(() => RewardClaimWhereInput, {nullable:true})
    @Type(() => RewardClaimWhereInput)
    where?: InstanceType<typeof RewardClaimWhereInput>;
    @Field(() => [RewardClaimOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<RewardClaimOrderByWithRelationInput>;
    @Field(() => RewardClaimWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [RewardClaimScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof RewardClaimScalarFieldEnum>;
}

@ArgsType()
export class FindFirstRewardClaimArgs {
    @Field(() => RewardClaimWhereInput, {nullable:true})
    @Type(() => RewardClaimWhereInput)
    where?: InstanceType<typeof RewardClaimWhereInput>;
    @Field(() => [RewardClaimOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<RewardClaimOrderByWithRelationInput>;
    @Field(() => RewardClaimWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [RewardClaimScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof RewardClaimScalarFieldEnum>;
}

@ArgsType()
export class FindManyRewardClaimArgs {
    @Field(() => RewardClaimWhereInput, {nullable:true})
    @Type(() => RewardClaimWhereInput)
    where?: InstanceType<typeof RewardClaimWhereInput>;
    @Field(() => [RewardClaimOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<RewardClaimOrderByWithRelationInput>;
    @Field(() => RewardClaimWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [RewardClaimScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof RewardClaimScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueRewardClaimOrThrowArgs {
    @Field(() => RewardClaimWhereUniqueInput, {nullable:false})
    @Type(() => RewardClaimWhereUniqueInput)
    where!: Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueRewardClaimArgs {
    @Field(() => RewardClaimWhereUniqueInput, {nullable:false})
    @Type(() => RewardClaimWhereUniqueInput)
    where!: Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>;
}

@ArgsType()
export class RewardClaimAggregateArgs {
    @Field(() => RewardClaimWhereInput, {nullable:true})
    @Type(() => RewardClaimWhereInput)
    where?: InstanceType<typeof RewardClaimWhereInput>;
    @Field(() => [RewardClaimOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<RewardClaimOrderByWithRelationInput>;
    @Field(() => RewardClaimWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => RewardClaimCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof RewardClaimCountAggregateInput>;
    @Field(() => RewardClaimAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof RewardClaimAvgAggregateInput>;
    @Field(() => RewardClaimSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof RewardClaimSumAggregateInput>;
    @Field(() => RewardClaimMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof RewardClaimMinAggregateInput>;
    @Field(() => RewardClaimMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof RewardClaimMaxAggregateInput>;
}

@InputType()
export class RewardClaimAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    rewardId?: true;
}

@ObjectType()
export class RewardClaimAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    rewardId?: number;
}

@InputType()
export class RewardClaimAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rewardId?: keyof typeof SortOrder;
}

@InputType()
export class RewardClaimCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    rewardId?: true;
    @Field(() => Boolean, {nullable:true})
    processedAt?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class RewardClaimCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    userId!: number;
    @Field(() => Int, {nullable:false})
    rewardId!: number;
    @Field(() => Int, {nullable:false})
    processedAt!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class RewardClaimCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rewardId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    processedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class RewardClaimCreateManyRewardInputEnvelope {
    @Field(() => [RewardClaimCreateManyRewardInput], {nullable:false})
    @Type(() => RewardClaimCreateManyRewardInput)
    data!: Array<RewardClaimCreateManyRewardInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class RewardClaimCreateManyRewardInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @HideField()
    processedAt!: Date | string;
    @HideField()
    createdAt?: Date | string;
}

@InputType()
export class RewardClaimCreateManyUserInputEnvelope {
    @Field(() => [RewardClaimCreateManyUserInput], {nullable:false})
    @Type(() => RewardClaimCreateManyUserInput)
    data!: Array<RewardClaimCreateManyUserInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class RewardClaimCreateManyUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    rewardId!: number;
    @HideField()
    processedAt!: Date | string;
    @HideField()
    createdAt?: Date | string;
}

@InputType()
export class RewardClaimCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Int, {nullable:false})
    rewardId!: number;
    @HideField()
    processedAt!: Date | string;
    @HideField()
    createdAt?: Date | string;
}

@InputType()
export class RewardClaimCreateNestedManyWithoutRewardInput {
    @Field(() => [RewardClaimCreateWithoutRewardInput], {nullable:true})
    @Type(() => RewardClaimCreateWithoutRewardInput)
    create?: Array<RewardClaimCreateWithoutRewardInput>;
    @Field(() => [RewardClaimCreateOrConnectWithoutRewardInput], {nullable:true})
    @Type(() => RewardClaimCreateOrConnectWithoutRewardInput)
    connectOrCreate?: Array<RewardClaimCreateOrConnectWithoutRewardInput>;
    @Field(() => RewardClaimCreateManyRewardInputEnvelope, {nullable:true})
    @Type(() => RewardClaimCreateManyRewardInputEnvelope)
    createMany?: InstanceType<typeof RewardClaimCreateManyRewardInputEnvelope>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
}

@InputType()
export class RewardClaimCreateNestedManyWithoutUserInput {
    @Field(() => [RewardClaimCreateWithoutUserInput], {nullable:true})
    @Type(() => RewardClaimCreateWithoutUserInput)
    create?: Array<RewardClaimCreateWithoutUserInput>;
    @Field(() => [RewardClaimCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => RewardClaimCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<RewardClaimCreateOrConnectWithoutUserInput>;
    @Field(() => RewardClaimCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => RewardClaimCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof RewardClaimCreateManyUserInputEnvelope>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
}

@InputType()
export class RewardClaimCreateOrConnectWithoutRewardInput {
    @Field(() => RewardClaimWhereUniqueInput, {nullable:false})
    @Type(() => RewardClaimWhereUniqueInput)
    where!: Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>;
    @Field(() => RewardClaimCreateWithoutRewardInput, {nullable:false})
    @Type(() => RewardClaimCreateWithoutRewardInput)
    create!: InstanceType<typeof RewardClaimCreateWithoutRewardInput>;
}

@InputType()
export class RewardClaimCreateOrConnectWithoutUserInput {
    @Field(() => RewardClaimWhereUniqueInput, {nullable:false})
    @Type(() => RewardClaimWhereUniqueInput)
    where!: Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>;
    @Field(() => RewardClaimCreateWithoutUserInput, {nullable:false})
    @Type(() => RewardClaimCreateWithoutUserInput)
    create!: InstanceType<typeof RewardClaimCreateWithoutUserInput>;
}

@InputType()
export class RewardClaimCreateWithoutRewardInput {
    @HideField()
    processedAt!: Date | string;
    @HideField()
    createdAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutClaimedRewardsInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutClaimedRewardsInput>;
}

@InputType()
export class RewardClaimCreateWithoutUserInput {
    @HideField()
    processedAt!: Date | string;
    @HideField()
    createdAt?: Date | string;
    @Field(() => RewardCreateNestedOneWithoutRewardClaimInput, {nullable:false})
    reward!: InstanceType<typeof RewardCreateNestedOneWithoutRewardClaimInput>;
}

@InputType()
export class RewardClaimCreateInput {
    @HideField()
    processedAt!: Date | string;
    @HideField()
    createdAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutClaimedRewardsInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutClaimedRewardsInput>;
    @Field(() => RewardCreateNestedOneWithoutRewardClaimInput, {nullable:false})
    reward!: InstanceType<typeof RewardCreateNestedOneWithoutRewardClaimInput>;
}

@ArgsType()
export class RewardClaimGroupByArgs {
    @Field(() => RewardClaimWhereInput, {nullable:true})
    @Type(() => RewardClaimWhereInput)
    where?: InstanceType<typeof RewardClaimWhereInput>;
    @Field(() => [RewardClaimOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<RewardClaimOrderByWithAggregationInput>;
    @Field(() => [RewardClaimScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof RewardClaimScalarFieldEnum>;
    @Field(() => RewardClaimScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof RewardClaimScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => RewardClaimCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof RewardClaimCountAggregateInput>;
    @Field(() => RewardClaimAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof RewardClaimAvgAggregateInput>;
    @Field(() => RewardClaimSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof RewardClaimSumAggregateInput>;
    @Field(() => RewardClaimMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof RewardClaimMinAggregateInput>;
    @Field(() => RewardClaimMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof RewardClaimMaxAggregateInput>;
}

@ObjectType()
export class RewardClaimGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Int, {nullable:false})
    rewardId!: number;
    @Field(() => Date, {nullable:false})
    processedAt!: Date | string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => RewardClaimCountAggregate, {nullable:true})
    _count?: InstanceType<typeof RewardClaimCountAggregate>;
    @Field(() => RewardClaimAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof RewardClaimAvgAggregate>;
    @Field(() => RewardClaimSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof RewardClaimSumAggregate>;
    @Field(() => RewardClaimMinAggregate, {nullable:true})
    _min?: InstanceType<typeof RewardClaimMinAggregate>;
    @Field(() => RewardClaimMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof RewardClaimMaxAggregate>;
}

@InputType()
export class RewardClaimListRelationFilter {
    @Field(() => RewardClaimWhereInput, {nullable:true})
    every?: InstanceType<typeof RewardClaimWhereInput>;
    @Field(() => RewardClaimWhereInput, {nullable:true})
    some?: InstanceType<typeof RewardClaimWhereInput>;
    @Field(() => RewardClaimWhereInput, {nullable:true})
    none?: InstanceType<typeof RewardClaimWhereInput>;
}

@InputType()
export class RewardClaimMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    rewardId?: true;
    @Field(() => Boolean, {nullable:true})
    processedAt?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
}

@ObjectType()
export class RewardClaimMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => Int, {nullable:true})
    rewardId?: number;
    @Field(() => Date, {nullable:true})
    processedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class RewardClaimMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rewardId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    processedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class RewardClaimMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    rewardId?: true;
    @Field(() => Boolean, {nullable:true})
    processedAt?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
}

@ObjectType()
export class RewardClaimMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => Int, {nullable:true})
    rewardId?: number;
    @Field(() => Date, {nullable:true})
    processedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class RewardClaimMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rewardId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    processedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class RewardClaimOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class RewardClaimOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rewardId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    processedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => RewardClaimCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof RewardClaimCountOrderByAggregateInput>;
    @Field(() => RewardClaimAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof RewardClaimAvgOrderByAggregateInput>;
    @Field(() => RewardClaimMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof RewardClaimMaxOrderByAggregateInput>;
    @Field(() => RewardClaimMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof RewardClaimMinOrderByAggregateInput>;
    @Field(() => RewardClaimSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof RewardClaimSumOrderByAggregateInput>;
}

@InputType()
export class RewardClaimOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rewardId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    processedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    user?: InstanceType<typeof UserOrderByWithRelationInput>;
    @Field(() => RewardOrderByWithRelationInput, {nullable:true})
    reward?: InstanceType<typeof RewardOrderByWithRelationInput>;
}

@InputType()
export class RewardClaimScalarWhereWithAggregatesInput {
    @Field(() => [RewardClaimScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<RewardClaimScalarWhereWithAggregatesInput>;
    @Field(() => [RewardClaimScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<RewardClaimScalarWhereWithAggregatesInput>;
    @Field(() => [RewardClaimScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<RewardClaimScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    userId?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    rewardId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    processedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class RewardClaimScalarWhereInput {
    @Field(() => [RewardClaimScalarWhereInput], {nullable:true})
    AND?: Array<RewardClaimScalarWhereInput>;
    @Field(() => [RewardClaimScalarWhereInput], {nullable:true})
    OR?: Array<RewardClaimScalarWhereInput>;
    @Field(() => [RewardClaimScalarWhereInput], {nullable:true})
    NOT?: Array<RewardClaimScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    rewardId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    processedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class RewardClaimSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    rewardId?: true;
}

@ObjectType()
export class RewardClaimSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    rewardId?: number;
}

@InputType()
export class RewardClaimSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    rewardId?: keyof typeof SortOrder;
}

@InputType()
export class RewardClaimUncheckedCreateNestedManyWithoutRewardInput {
    @Field(() => [RewardClaimCreateWithoutRewardInput], {nullable:true})
    @Type(() => RewardClaimCreateWithoutRewardInput)
    create?: Array<RewardClaimCreateWithoutRewardInput>;
    @Field(() => [RewardClaimCreateOrConnectWithoutRewardInput], {nullable:true})
    @Type(() => RewardClaimCreateOrConnectWithoutRewardInput)
    connectOrCreate?: Array<RewardClaimCreateOrConnectWithoutRewardInput>;
    @Field(() => RewardClaimCreateManyRewardInputEnvelope, {nullable:true})
    @Type(() => RewardClaimCreateManyRewardInputEnvelope)
    createMany?: InstanceType<typeof RewardClaimCreateManyRewardInputEnvelope>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
}

@InputType()
export class RewardClaimUncheckedCreateNestedManyWithoutUserInput {
    @Field(() => [RewardClaimCreateWithoutUserInput], {nullable:true})
    @Type(() => RewardClaimCreateWithoutUserInput)
    create?: Array<RewardClaimCreateWithoutUserInput>;
    @Field(() => [RewardClaimCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => RewardClaimCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<RewardClaimCreateOrConnectWithoutUserInput>;
    @Field(() => RewardClaimCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => RewardClaimCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof RewardClaimCreateManyUserInputEnvelope>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
}

@InputType()
export class RewardClaimUncheckedCreateWithoutRewardInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Date, {nullable:false})
    processedAt!: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class RewardClaimUncheckedCreateWithoutUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:false})
    rewardId!: number;
    @Field(() => Date, {nullable:false})
    processedAt!: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class RewardClaimUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Int, {nullable:false})
    rewardId!: number;
    @Field(() => Date, {nullable:false})
    processedAt!: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class RewardClaimUncheckedUpdateManyWithoutRewardNestedInput {
    @Field(() => [RewardClaimCreateWithoutRewardInput], {nullable:true})
    @Type(() => RewardClaimCreateWithoutRewardInput)
    create?: Array<RewardClaimCreateWithoutRewardInput>;
    @Field(() => [RewardClaimCreateOrConnectWithoutRewardInput], {nullable:true})
    @Type(() => RewardClaimCreateOrConnectWithoutRewardInput)
    connectOrCreate?: Array<RewardClaimCreateOrConnectWithoutRewardInput>;
    @Field(() => [RewardClaimUpsertWithWhereUniqueWithoutRewardInput], {nullable:true})
    @Type(() => RewardClaimUpsertWithWhereUniqueWithoutRewardInput)
    upsert?: Array<RewardClaimUpsertWithWhereUniqueWithoutRewardInput>;
    @Field(() => RewardClaimCreateManyRewardInputEnvelope, {nullable:true})
    @Type(() => RewardClaimCreateManyRewardInputEnvelope)
    createMany?: InstanceType<typeof RewardClaimCreateManyRewardInputEnvelope>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    set?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
    @Field(() => [RewardClaimUpdateWithWhereUniqueWithoutRewardInput], {nullable:true})
    @Type(() => RewardClaimUpdateWithWhereUniqueWithoutRewardInput)
    update?: Array<RewardClaimUpdateWithWhereUniqueWithoutRewardInput>;
    @Field(() => [RewardClaimUpdateManyWithWhereWithoutRewardInput], {nullable:true})
    @Type(() => RewardClaimUpdateManyWithWhereWithoutRewardInput)
    updateMany?: Array<RewardClaimUpdateManyWithWhereWithoutRewardInput>;
    @Field(() => [RewardClaimScalarWhereInput], {nullable:true})
    @Type(() => RewardClaimScalarWhereInput)
    deleteMany?: Array<RewardClaimScalarWhereInput>;
}

@InputType()
export class RewardClaimUncheckedUpdateManyWithoutRewardInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    processedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class RewardClaimUncheckedUpdateManyWithoutUserNestedInput {
    @Field(() => [RewardClaimCreateWithoutUserInput], {nullable:true})
    @Type(() => RewardClaimCreateWithoutUserInput)
    create?: Array<RewardClaimCreateWithoutUserInput>;
    @Field(() => [RewardClaimCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => RewardClaimCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<RewardClaimCreateOrConnectWithoutUserInput>;
    @Field(() => [RewardClaimUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => RewardClaimUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<RewardClaimUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => RewardClaimCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => RewardClaimCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof RewardClaimCreateManyUserInputEnvelope>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    set?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
    @Field(() => [RewardClaimUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => RewardClaimUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<RewardClaimUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [RewardClaimUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => RewardClaimUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<RewardClaimUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [RewardClaimScalarWhereInput], {nullable:true})
    @Type(() => RewardClaimScalarWhereInput)
    deleteMany?: Array<RewardClaimScalarWhereInput>;
}

@InputType()
export class RewardClaimUncheckedUpdateManyWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    rewardId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    processedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class RewardClaimUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    rewardId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    processedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class RewardClaimUncheckedUpdateWithoutRewardInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    processedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class RewardClaimUncheckedUpdateWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    rewardId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    processedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class RewardClaimUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    rewardId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    processedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class RewardClaimUpdateManyMutationInput {
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    processedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class RewardClaimUpdateManyWithWhereWithoutRewardInput {
    @Field(() => RewardClaimScalarWhereInput, {nullable:false})
    @Type(() => RewardClaimScalarWhereInput)
    where!: InstanceType<typeof RewardClaimScalarWhereInput>;
    @Field(() => RewardClaimUpdateManyMutationInput, {nullable:false})
    @Type(() => RewardClaimUpdateManyMutationInput)
    data!: InstanceType<typeof RewardClaimUpdateManyMutationInput>;
}

@InputType()
export class RewardClaimUpdateManyWithWhereWithoutUserInput {
    @Field(() => RewardClaimScalarWhereInput, {nullable:false})
    @Type(() => RewardClaimScalarWhereInput)
    where!: InstanceType<typeof RewardClaimScalarWhereInput>;
    @Field(() => RewardClaimUpdateManyMutationInput, {nullable:false})
    @Type(() => RewardClaimUpdateManyMutationInput)
    data!: InstanceType<typeof RewardClaimUpdateManyMutationInput>;
}

@InputType()
export class RewardClaimUpdateManyWithoutRewardNestedInput {
    @Field(() => [RewardClaimCreateWithoutRewardInput], {nullable:true})
    @Type(() => RewardClaimCreateWithoutRewardInput)
    create?: Array<RewardClaimCreateWithoutRewardInput>;
    @Field(() => [RewardClaimCreateOrConnectWithoutRewardInput], {nullable:true})
    @Type(() => RewardClaimCreateOrConnectWithoutRewardInput)
    connectOrCreate?: Array<RewardClaimCreateOrConnectWithoutRewardInput>;
    @Field(() => [RewardClaimUpsertWithWhereUniqueWithoutRewardInput], {nullable:true})
    @Type(() => RewardClaimUpsertWithWhereUniqueWithoutRewardInput)
    upsert?: Array<RewardClaimUpsertWithWhereUniqueWithoutRewardInput>;
    @Field(() => RewardClaimCreateManyRewardInputEnvelope, {nullable:true})
    @Type(() => RewardClaimCreateManyRewardInputEnvelope)
    createMany?: InstanceType<typeof RewardClaimCreateManyRewardInputEnvelope>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    set?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
    @Field(() => [RewardClaimUpdateWithWhereUniqueWithoutRewardInput], {nullable:true})
    @Type(() => RewardClaimUpdateWithWhereUniqueWithoutRewardInput)
    update?: Array<RewardClaimUpdateWithWhereUniqueWithoutRewardInput>;
    @Field(() => [RewardClaimUpdateManyWithWhereWithoutRewardInput], {nullable:true})
    @Type(() => RewardClaimUpdateManyWithWhereWithoutRewardInput)
    updateMany?: Array<RewardClaimUpdateManyWithWhereWithoutRewardInput>;
    @Field(() => [RewardClaimScalarWhereInput], {nullable:true})
    @Type(() => RewardClaimScalarWhereInput)
    deleteMany?: Array<RewardClaimScalarWhereInput>;
}

@InputType()
export class RewardClaimUpdateManyWithoutUserNestedInput {
    @Field(() => [RewardClaimCreateWithoutUserInput], {nullable:true})
    @Type(() => RewardClaimCreateWithoutUserInput)
    create?: Array<RewardClaimCreateWithoutUserInput>;
    @Field(() => [RewardClaimCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => RewardClaimCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<RewardClaimCreateOrConnectWithoutUserInput>;
    @Field(() => [RewardClaimUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => RewardClaimUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<RewardClaimUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => RewardClaimCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => RewardClaimCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof RewardClaimCreateManyUserInputEnvelope>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    set?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
    @Field(() => [RewardClaimWhereUniqueInput], {nullable:true})
    @Type(() => RewardClaimWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>>;
    @Field(() => [RewardClaimUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => RewardClaimUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<RewardClaimUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [RewardClaimUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => RewardClaimUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<RewardClaimUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [RewardClaimScalarWhereInput], {nullable:true})
    @Type(() => RewardClaimScalarWhereInput)
    deleteMany?: Array<RewardClaimScalarWhereInput>;
}

@InputType()
export class RewardClaimUpdateWithWhereUniqueWithoutRewardInput {
    @Field(() => RewardClaimWhereUniqueInput, {nullable:false})
    @Type(() => RewardClaimWhereUniqueInput)
    where!: Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>;
    @Field(() => RewardClaimUpdateWithoutRewardInput, {nullable:false})
    @Type(() => RewardClaimUpdateWithoutRewardInput)
    data!: InstanceType<typeof RewardClaimUpdateWithoutRewardInput>;
}

@InputType()
export class RewardClaimUpdateWithWhereUniqueWithoutUserInput {
    @Field(() => RewardClaimWhereUniqueInput, {nullable:false})
    @Type(() => RewardClaimWhereUniqueInput)
    where!: Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>;
    @Field(() => RewardClaimUpdateWithoutUserInput, {nullable:false})
    @Type(() => RewardClaimUpdateWithoutUserInput)
    data!: InstanceType<typeof RewardClaimUpdateWithoutUserInput>;
}

@InputType()
export class RewardClaimUpdateWithoutRewardInput {
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    processedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutClaimedRewardsNestedInput>;
}

@InputType()
export class RewardClaimUpdateWithoutUserInput {
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    processedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    reward?: InstanceType<typeof RewardUpdateOneRequiredWithoutRewardClaimNestedInput>;
}

@InputType()
export class RewardClaimUpdateInput {
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    processedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutClaimedRewardsNestedInput>;
    @HideField()
    reward?: InstanceType<typeof RewardUpdateOneRequiredWithoutRewardClaimNestedInput>;
}

@InputType()
export class RewardClaimUpsertWithWhereUniqueWithoutRewardInput {
    @Field(() => RewardClaimWhereUniqueInput, {nullable:false})
    @Type(() => RewardClaimWhereUniqueInput)
    where!: Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>;
    @Field(() => RewardClaimUpdateWithoutRewardInput, {nullable:false})
    @Type(() => RewardClaimUpdateWithoutRewardInput)
    update!: InstanceType<typeof RewardClaimUpdateWithoutRewardInput>;
    @Field(() => RewardClaimCreateWithoutRewardInput, {nullable:false})
    @Type(() => RewardClaimCreateWithoutRewardInput)
    create!: InstanceType<typeof RewardClaimCreateWithoutRewardInput>;
}

@InputType()
export class RewardClaimUpsertWithWhereUniqueWithoutUserInput {
    @Field(() => RewardClaimWhereUniqueInput, {nullable:false})
    @Type(() => RewardClaimWhereUniqueInput)
    where!: Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>;
    @Field(() => RewardClaimUpdateWithoutUserInput, {nullable:false})
    @Type(() => RewardClaimUpdateWithoutUserInput)
    update!: InstanceType<typeof RewardClaimUpdateWithoutUserInput>;
    @Field(() => RewardClaimCreateWithoutUserInput, {nullable:false})
    @Type(() => RewardClaimCreateWithoutUserInput)
    create!: InstanceType<typeof RewardClaimCreateWithoutUserInput>;
}

@InputType()
export class RewardClaimWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [RewardClaimWhereInput], {nullable:true})
    AND?: Array<RewardClaimWhereInput>;
    @Field(() => [RewardClaimWhereInput], {nullable:true})
    OR?: Array<RewardClaimWhereInput>;
    @Field(() => [RewardClaimWhereInput], {nullable:true})
    NOT?: Array<RewardClaimWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    rewardId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    processedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
    @Field(() => RewardRelationFilter, {nullable:true})
    reward?: InstanceType<typeof RewardRelationFilter>;
}

@InputType()
export class RewardClaimWhereInput {
    @Field(() => [RewardClaimWhereInput], {nullable:true})
    AND?: Array<RewardClaimWhereInput>;
    @Field(() => [RewardClaimWhereInput], {nullable:true})
    OR?: Array<RewardClaimWhereInput>;
    @Field(() => [RewardClaimWhereInput], {nullable:true})
    NOT?: Array<RewardClaimWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    rewardId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    processedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
    @Field(() => RewardRelationFilter, {nullable:true})
    reward?: InstanceType<typeof RewardRelationFilter>;
}

@ObjectType()
export class RewardClaim {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Int, {nullable:false})
    rewardId!: number;
    @Field(() => Date, {nullable:false})
    processedAt!: Date;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => User, {nullable:false})
    user?: InstanceType<typeof User>;
    @Field(() => Reward, {nullable:false})
    reward?: InstanceType<typeof Reward>;
}

@ArgsType()
export class UpdateManyRewardClaimArgs {
    @Field(() => RewardClaimUpdateManyMutationInput, {nullable:false})
    @Type(() => RewardClaimUpdateManyMutationInput)
    data!: InstanceType<typeof RewardClaimUpdateManyMutationInput>;
    @Field(() => RewardClaimWhereInput, {nullable:true})
    @Type(() => RewardClaimWhereInput)
    where?: InstanceType<typeof RewardClaimWhereInput>;
}

@ArgsType()
export class UpdateOneRewardClaimArgs {
    @Field(() => RewardClaimUpdateInput, {nullable:false})
    @Type(() => RewardClaimUpdateInput)
    data!: InstanceType<typeof RewardClaimUpdateInput>;
    @Field(() => RewardClaimWhereUniqueInput, {nullable:false})
    @Type(() => RewardClaimWhereUniqueInput)
    where!: Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneRewardClaimArgs {
    @Field(() => RewardClaimWhereUniqueInput, {nullable:false})
    @Type(() => RewardClaimWhereUniqueInput)
    where!: Prisma.AtLeast<RewardClaimWhereUniqueInput, 'id'>;
    @Field(() => RewardClaimCreateInput, {nullable:false})
    @Type(() => RewardClaimCreateInput)
    create!: InstanceType<typeof RewardClaimCreateInput>;
    @Field(() => RewardClaimUpdateInput, {nullable:false})
    @Type(() => RewardClaimUpdateInput)
    update!: InstanceType<typeof RewardClaimUpdateInput>;
}

@ObjectType()
export class AggregateSchool {
    @Field(() => SchoolCountAggregate, {nullable:true})
    _count?: InstanceType<typeof SchoolCountAggregate>;
    @Field(() => SchoolAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof SchoolAvgAggregate>;
    @Field(() => SchoolSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof SchoolSumAggregate>;
    @Field(() => SchoolMinAggregate, {nullable:true})
    _min?: InstanceType<typeof SchoolMinAggregate>;
    @Field(() => SchoolMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof SchoolMaxAggregate>;
}

@ArgsType()
export class CreateManySchoolArgs {
    @Field(() => [SchoolCreateManyInput], {nullable:false})
    @Type(() => SchoolCreateManyInput)
    data!: Array<SchoolCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneSchoolArgs {
    @Field(() => SchoolCreateInput, {nullable:false})
    @Type(() => SchoolCreateInput)
    data!: InstanceType<typeof SchoolCreateInput>;
}

@ArgsType()
export class DeleteManySchoolArgs {
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
}

@ArgsType()
export class DeleteOneSchoolArgs {
    @Field(() => SchoolWhereUniqueInput, {nullable:false})
    @Type(() => SchoolWhereUniqueInput)
    where!: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
}

@ArgsType()
export class FindFirstSchoolOrThrowArgs {
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => [SchoolOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SchoolOrderByWithRelationInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [SchoolScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof SchoolScalarFieldEnum>;
}

@ArgsType()
export class FindFirstSchoolArgs {
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => [SchoolOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SchoolOrderByWithRelationInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [SchoolScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof SchoolScalarFieldEnum>;
}

@ArgsType()
export class FindManySchoolArgs {
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => [SchoolOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SchoolOrderByWithRelationInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [SchoolScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof SchoolScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueSchoolOrThrowArgs {
    @Field(() => SchoolWhereUniqueInput, {nullable:false})
    @Type(() => SchoolWhereUniqueInput)
    where!: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
}

@ArgsType()
export class FindUniqueSchoolArgs {
    @Field(() => SchoolWhereUniqueInput, {nullable:false})
    @Type(() => SchoolWhereUniqueInput)
    where!: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
}

@ArgsType()
export class SchoolAggregateArgs {
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => [SchoolOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SchoolOrderByWithRelationInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => SchoolCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof SchoolCountAggregateInput>;
    @Field(() => SchoolAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof SchoolAvgAggregateInput>;
    @Field(() => SchoolSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof SchoolSumAggregateInput>;
    @Field(() => SchoolMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof SchoolMinAggregateInput>;
    @Field(() => SchoolMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof SchoolMaxAggregateInput>;
}

@InputType()
export class SchoolAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @HideField()
    addressId?: true;
}

@ObjectType()
export class SchoolAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    addressId?: number;
}

@InputType()
export class SchoolAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @HideField()
    addressId?: keyof typeof SortOrder;
}

@InputType()
export class SchoolCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @HideField()
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class SchoolCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class SchoolCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @HideField()
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@ObjectType()
export class SchoolCount {
    @Field(() => Int, {nullable:false})
    students?: number;
}

@InputType()
export class SchoolCreateManyInput {
    @HideField()
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsAlphanumeric()
    name!: string;
    @HideField()
    addressId!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class SchoolCreateNestedOneWithoutAddressInput {
    @Field(() => SchoolCreateWithoutAddressInput, {nullable:true})
    @Type(() => SchoolCreateWithoutAddressInput)
    create?: InstanceType<typeof SchoolCreateWithoutAddressInput>;
    @Field(() => SchoolCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => SchoolCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof SchoolCreateOrConnectWithoutAddressInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    @Type(() => SchoolWhereUniqueInput)
    connect?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
}

@InputType()
export class SchoolCreateNestedOneWithoutStudentsInput {
    @Field(() => SchoolCreateWithoutStudentsInput, {nullable:true})
    @Type(() => SchoolCreateWithoutStudentsInput)
    create?: InstanceType<typeof SchoolCreateWithoutStudentsInput>;
    @Field(() => SchoolCreateOrConnectWithoutStudentsInput, {nullable:true})
    @Type(() => SchoolCreateOrConnectWithoutStudentsInput)
    connectOrCreate?: InstanceType<typeof SchoolCreateOrConnectWithoutStudentsInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    @Type(() => SchoolWhereUniqueInput)
    connect?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
}

@InputType()
export class SchoolCreateOrConnectWithoutAddressInput {
    @Field(() => SchoolWhereUniqueInput, {nullable:false})
    @Type(() => SchoolWhereUniqueInput)
    where!: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => SchoolCreateWithoutAddressInput, {nullable:false})
    @Type(() => SchoolCreateWithoutAddressInput)
    create!: InstanceType<typeof SchoolCreateWithoutAddressInput>;
}

@InputType()
export class SchoolCreateOrConnectWithoutStudentsInput {
    @Field(() => SchoolWhereUniqueInput, {nullable:false})
    @Type(() => SchoolWhereUniqueInput)
    where!: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => SchoolCreateWithoutStudentsInput, {nullable:false})
    @Type(() => SchoolCreateWithoutStudentsInput)
    create!: InstanceType<typeof SchoolCreateWithoutStudentsInput>;
}

@InputType()
export class SchoolCreateWithoutAddressInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsAlphanumeric()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    students?: InstanceType<typeof UserCreateNestedManyWithoutSchoolInput>;
}

@InputType()
export class SchoolCreateWithoutStudentsInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsAlphanumeric()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => AddressCreateNestedOneWithoutSchoolInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutSchoolInput>;
}

@InputType()
export class SchoolCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsAlphanumeric()
    name!: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => AddressCreateNestedOneWithoutSchoolInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutSchoolInput>;
    @HideField()
    students?: InstanceType<typeof UserCreateNestedManyWithoutSchoolInput>;
}

@ArgsType()
export class SchoolGroupByArgs {
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => [SchoolOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<SchoolOrderByWithAggregationInput>;
    @Field(() => [SchoolScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof SchoolScalarFieldEnum>;
    @Field(() => SchoolScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof SchoolScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => SchoolCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof SchoolCountAggregateInput>;
    @Field(() => SchoolAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof SchoolAvgAggregateInput>;
    @Field(() => SchoolSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof SchoolSumAggregateInput>;
    @Field(() => SchoolMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof SchoolMinAggregateInput>;
    @Field(() => SchoolMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof SchoolMaxAggregateInput>;
}

@ObjectType()
export class SchoolGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => SchoolCountAggregate, {nullable:true})
    _count?: InstanceType<typeof SchoolCountAggregate>;
    @Field(() => SchoolAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof SchoolAvgAggregate>;
    @Field(() => SchoolSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof SchoolSumAggregate>;
    @Field(() => SchoolMinAggregate, {nullable:true})
    _min?: InstanceType<typeof SchoolMinAggregate>;
    @Field(() => SchoolMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof SchoolMaxAggregate>;
}

@InputType()
export class SchoolMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @HideField()
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class SchoolMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class SchoolMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @HideField()
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class SchoolMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @HideField()
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class SchoolMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class SchoolMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @HideField()
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class SchoolNullableRelationFilter {
    @Field(() => SchoolWhereInput, {nullable:true})
    is?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    isNot?: InstanceType<typeof SchoolWhereInput>;
}

@InputType()
export class SchoolOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @HideField()
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SchoolCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof SchoolCountOrderByAggregateInput>;
    @Field(() => SchoolAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof SchoolAvgOrderByAggregateInput>;
    @Field(() => SchoolMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof SchoolMaxOrderByAggregateInput>;
    @Field(() => SchoolMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof SchoolMinOrderByAggregateInput>;
    @Field(() => SchoolSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof SchoolSumOrderByAggregateInput>;
}

@InputType()
export class SchoolOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @HideField()
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => AddressOrderByWithRelationInput, {nullable:true})
    address?: InstanceType<typeof AddressOrderByWithRelationInput>;
    @Field(() => UserOrderByRelationAggregateInput, {nullable:true})
    students?: InstanceType<typeof UserOrderByRelationAggregateInput>;
}

@InputType()
export class SchoolScalarWhereWithAggregatesInput {
    @Field(() => [SchoolScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<SchoolScalarWhereWithAggregatesInput>;
    @Field(() => [SchoolScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<SchoolScalarWhereWithAggregatesInput>;
    @Field(() => [SchoolScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<SchoolScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @HideField()
    addressId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class SchoolSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @HideField()
    addressId?: true;
}

@ObjectType()
export class SchoolSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    addressId?: number;
}

@InputType()
export class SchoolSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @HideField()
    addressId?: keyof typeof SortOrder;
}

@InputType()
export class SchoolUncheckedCreateNestedOneWithoutAddressInput {
    @Field(() => SchoolCreateWithoutAddressInput, {nullable:true})
    @Type(() => SchoolCreateWithoutAddressInput)
    create?: InstanceType<typeof SchoolCreateWithoutAddressInput>;
    @Field(() => SchoolCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => SchoolCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof SchoolCreateOrConnectWithoutAddressInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    @Type(() => SchoolWhereUniqueInput)
    connect?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
}

@InputType()
export class SchoolUncheckedCreateWithoutAddressInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsAlphanumeric()
    name!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserUncheckedCreateNestedManyWithoutSchoolInput, {nullable:true})
    students?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutSchoolInput>;
}

@InputType()
export class SchoolUncheckedCreateWithoutStudentsInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsAlphanumeric()
    name!: string;
    @HideField()
    addressId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class SchoolUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(5)
    @Validator.IsAlphanumeric()
    name!: string;
    @HideField()
    addressId!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => UserUncheckedCreateNestedManyWithoutSchoolInput, {nullable:true})
    students?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutSchoolInput>;
}

@InputType()
export class SchoolUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class SchoolUncheckedUpdateOneWithoutAddressNestedInput {
    @Field(() => SchoolCreateWithoutAddressInput, {nullable:true})
    @Type(() => SchoolCreateWithoutAddressInput)
    create?: InstanceType<typeof SchoolCreateWithoutAddressInput>;
    @Field(() => SchoolCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => SchoolCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof SchoolCreateOrConnectWithoutAddressInput>;
    @Field(() => SchoolUpsertWithoutAddressInput, {nullable:true})
    @Type(() => SchoolUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof SchoolUpsertWithoutAddressInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    disconnect?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    delete?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    @Type(() => SchoolWhereUniqueInput)
    connect?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => SchoolUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => SchoolUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof SchoolUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class SchoolUncheckedUpdateWithoutAddressInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutSchoolNestedInput, {nullable:true})
    students?: InstanceType<typeof UserUncheckedUpdateManyWithoutSchoolNestedInput>;
}

@InputType()
export class SchoolUncheckedUpdateWithoutStudentsInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class SchoolUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutSchoolNestedInput, {nullable:true})
    students?: InstanceType<typeof UserUncheckedUpdateManyWithoutSchoolNestedInput>;
}

@InputType()
export class SchoolUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class SchoolUpdateOneWithoutAddressNestedInput {
    @Field(() => SchoolCreateWithoutAddressInput, {nullable:true})
    @Type(() => SchoolCreateWithoutAddressInput)
    create?: InstanceType<typeof SchoolCreateWithoutAddressInput>;
    @Field(() => SchoolCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => SchoolCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof SchoolCreateOrConnectWithoutAddressInput>;
    @Field(() => SchoolUpsertWithoutAddressInput, {nullable:true})
    @Type(() => SchoolUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof SchoolUpsertWithoutAddressInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    disconnect?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    delete?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    @Type(() => SchoolWhereUniqueInput)
    connect?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => SchoolUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => SchoolUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof SchoolUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class SchoolUpdateOneWithoutStudentsNestedInput {
    @Field(() => SchoolCreateWithoutStudentsInput, {nullable:true})
    @Type(() => SchoolCreateWithoutStudentsInput)
    create?: InstanceType<typeof SchoolCreateWithoutStudentsInput>;
    @Field(() => SchoolCreateOrConnectWithoutStudentsInput, {nullable:true})
    @Type(() => SchoolCreateOrConnectWithoutStudentsInput)
    connectOrCreate?: InstanceType<typeof SchoolCreateOrConnectWithoutStudentsInput>;
    @Field(() => SchoolUpsertWithoutStudentsInput, {nullable:true})
    @Type(() => SchoolUpsertWithoutStudentsInput)
    upsert?: InstanceType<typeof SchoolUpsertWithoutStudentsInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    disconnect?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    delete?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:true})
    @Type(() => SchoolWhereUniqueInput)
    connect?: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => SchoolUpdateToOneWithWhereWithoutStudentsInput, {nullable:true})
    @Type(() => SchoolUpdateToOneWithWhereWithoutStudentsInput)
    update?: InstanceType<typeof SchoolUpdateToOneWithWhereWithoutStudentsInput>;
}

@InputType()
export class SchoolUpdateToOneWithWhereWithoutAddressInput {
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => SchoolUpdateWithoutAddressInput, {nullable:false})
    @Type(() => SchoolUpdateWithoutAddressInput)
    data!: InstanceType<typeof SchoolUpdateWithoutAddressInput>;
}

@InputType()
export class SchoolUpdateToOneWithWhereWithoutStudentsInput {
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
    @Field(() => SchoolUpdateWithoutStudentsInput, {nullable:false})
    @Type(() => SchoolUpdateWithoutStudentsInput)
    data!: InstanceType<typeof SchoolUpdateWithoutStudentsInput>;
}

@InputType()
export class SchoolUpdateWithoutAddressInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    students?: InstanceType<typeof UserUpdateManyWithoutSchoolNestedInput>;
}

@InputType()
export class SchoolUpdateWithoutStudentsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutSchoolNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutSchoolNestedInput>;
}

@InputType()
export class SchoolUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutSchoolNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutSchoolNestedInput>;
    @HideField()
    students?: InstanceType<typeof UserUpdateManyWithoutSchoolNestedInput>;
}

@InputType()
export class SchoolUpsertWithoutAddressInput {
    @Field(() => SchoolUpdateWithoutAddressInput, {nullable:false})
    @Type(() => SchoolUpdateWithoutAddressInput)
    update!: InstanceType<typeof SchoolUpdateWithoutAddressInput>;
    @Field(() => SchoolCreateWithoutAddressInput, {nullable:false})
    @Type(() => SchoolCreateWithoutAddressInput)
    create!: InstanceType<typeof SchoolCreateWithoutAddressInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
}

@InputType()
export class SchoolUpsertWithoutStudentsInput {
    @Field(() => SchoolUpdateWithoutStudentsInput, {nullable:false})
    @Type(() => SchoolUpdateWithoutStudentsInput)
    update!: InstanceType<typeof SchoolUpdateWithoutStudentsInput>;
    @Field(() => SchoolCreateWithoutStudentsInput, {nullable:false})
    @Type(() => SchoolCreateWithoutStudentsInput)
    create!: InstanceType<typeof SchoolCreateWithoutStudentsInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
}

@InputType()
export class SchoolWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @HideField()
    addressId?: number;
    @Field(() => [SchoolWhereInput], {nullable:true})
    AND?: Array<SchoolWhereInput>;
    @Field(() => [SchoolWhereInput], {nullable:true})
    OR?: Array<SchoolWhereInput>;
    @Field(() => [SchoolWhereInput], {nullable:true})
    NOT?: Array<SchoolWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => AddressRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressRelationFilter>;
    @Field(() => UserListRelationFilter, {nullable:true})
    students?: InstanceType<typeof UserListRelationFilter>;
}

@InputType()
export class SchoolWhereInput {
    @Field(() => [SchoolWhereInput], {nullable:true})
    AND?: Array<SchoolWhereInput>;
    @Field(() => [SchoolWhereInput], {nullable:true})
    OR?: Array<SchoolWhereInput>;
    @Field(() => [SchoolWhereInput], {nullable:true})
    NOT?: Array<SchoolWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @HideField()
    addressId?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => AddressRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressRelationFilter>;
    @Field(() => UserListRelationFilter, {nullable:true})
    students?: InstanceType<typeof UserListRelationFilter>;
}

@ObjectType()
export class School {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => Address, {nullable:false})
    address?: InstanceType<typeof Address>;
    @Field(() => [User], {nullable:true})
    students?: Array<User>;
    @Field(() => SchoolCount, {nullable:false})
    _count?: InstanceType<typeof SchoolCount>;
}

@ArgsType()
export class UpdateManySchoolArgs {
    @Field(() => SchoolUpdateManyMutationInput, {nullable:false})
    @Type(() => SchoolUpdateManyMutationInput)
    data!: InstanceType<typeof SchoolUpdateManyMutationInput>;
    @Field(() => SchoolWhereInput, {nullable:true})
    @Type(() => SchoolWhereInput)
    where?: InstanceType<typeof SchoolWhereInput>;
}

@ArgsType()
export class UpdateOneSchoolArgs {
    @Field(() => SchoolUpdateInput, {nullable:false})
    @Type(() => SchoolUpdateInput)
    data!: InstanceType<typeof SchoolUpdateInput>;
    @Field(() => SchoolWhereUniqueInput, {nullable:false})
    @Type(() => SchoolWhereUniqueInput)
    where!: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
}

@ArgsType()
export class UpsertOneSchoolArgs {
    @Field(() => SchoolWhereUniqueInput, {nullable:false})
    @Type(() => SchoolWhereUniqueInput)
    where!: Prisma.AtLeast<SchoolWhereUniqueInput, 'id' | 'addressId'>;
    @Field(() => SchoolCreateInput, {nullable:false})
    @Type(() => SchoolCreateInput)
    create!: InstanceType<typeof SchoolCreateInput>;
    @Field(() => SchoolUpdateInput, {nullable:false})
    @Type(() => SchoolUpdateInput)
    update!: InstanceType<typeof SchoolUpdateInput>;
}

@ObjectType()
export class AggregateSession {
    @Field(() => SessionCountAggregate, {nullable:true})
    _count?: InstanceType<typeof SessionCountAggregate>;
    @Field(() => SessionAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof SessionAvgAggregate>;
    @Field(() => SessionSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof SessionSumAggregate>;
    @Field(() => SessionMinAggregate, {nullable:true})
    _min?: InstanceType<typeof SessionMinAggregate>;
    @Field(() => SessionMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof SessionMaxAggregate>;
}

@ArgsType()
export class CreateManySessionArgs {
    @Field(() => [SessionCreateManyInput], {nullable:false})
    @Type(() => SessionCreateManyInput)
    data!: Array<SessionCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneSessionArgs {
    @Field(() => SessionCreateInput, {nullable:false})
    @Type(() => SessionCreateInput)
    data!: InstanceType<typeof SessionCreateInput>;
}

@ArgsType()
export class DeleteManySessionArgs {
    @Field(() => SessionWhereInput, {nullable:true})
    @Type(() => SessionWhereInput)
    where?: InstanceType<typeof SessionWhereInput>;
}

@ArgsType()
export class DeleteOneSessionArgs {
    @Field(() => SessionWhereUniqueInput, {nullable:false})
    @Type(() => SessionWhereUniqueInput)
    where!: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
}

@ArgsType()
export class FindFirstSessionOrThrowArgs {
    @Field(() => SessionWhereInput, {nullable:true})
    @Type(() => SessionWhereInput)
    where?: InstanceType<typeof SessionWhereInput>;
    @Field(() => [SessionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SessionOrderByWithRelationInput>;
    @Field(() => SessionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [SessionScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof SessionScalarFieldEnum>;
}

@ArgsType()
export class FindFirstSessionArgs {
    @Field(() => SessionWhereInput, {nullable:true})
    @Type(() => SessionWhereInput)
    where?: InstanceType<typeof SessionWhereInput>;
    @Field(() => [SessionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SessionOrderByWithRelationInput>;
    @Field(() => SessionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [SessionScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof SessionScalarFieldEnum>;
}

@ArgsType()
export class FindManySessionArgs {
    @Field(() => SessionWhereInput, {nullable:true})
    @Type(() => SessionWhereInput)
    where?: InstanceType<typeof SessionWhereInput>;
    @Field(() => [SessionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SessionOrderByWithRelationInput>;
    @Field(() => SessionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [SessionScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof SessionScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueSessionOrThrowArgs {
    @Field(() => SessionWhereUniqueInput, {nullable:false})
    @Type(() => SessionWhereUniqueInput)
    where!: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
}

@ArgsType()
export class FindUniqueSessionArgs {
    @Field(() => SessionWhereUniqueInput, {nullable:false})
    @Type(() => SessionWhereUniqueInput)
    where!: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
}

@ArgsType()
export class SessionAggregateArgs {
    @Field(() => SessionWhereInput, {nullable:true})
    @Type(() => SessionWhereInput)
    where?: InstanceType<typeof SessionWhereInput>;
    @Field(() => [SessionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SessionOrderByWithRelationInput>;
    @Field(() => SessionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => SessionCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof SessionCountAggregateInput>;
    @Field(() => SessionAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof SessionAvgAggregateInput>;
    @Field(() => SessionSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof SessionSumAggregateInput>;
    @Field(() => SessionMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof SessionMinAggregateInput>;
    @Field(() => SessionMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof SessionMaxAggregateInput>;
}

@InputType()
export class SessionAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    ipAddress?: true;
}

@ObjectType()
export class SessionAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    ipAddress?: number;
}

@InputType()
export class SessionAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    ipAddress?: keyof typeof SortOrder;
}

@InputType()
export class SessionCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    token?: true;
    @Field(() => Boolean, {nullable:true})
    expiresAt?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    device?: true;
    @Field(() => Boolean, {nullable:true})
    ipAddress?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class SessionCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    token!: number;
    @Field(() => Int, {nullable:false})
    expiresAt!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    userId!: number;
    @Field(() => Int, {nullable:false})
    device!: number;
    @Field(() => Int, {nullable:false})
    ipAddress!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class SessionCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    token?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    expiresAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    device?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    ipAddress?: keyof typeof SortOrder;
}

@InputType()
export class SessionCreateManyUserInputEnvelope {
    @Field(() => [SessionCreateManyUserInput], {nullable:false})
    @Type(() => SessionCreateManyUserInput)
    data!: Array<SessionCreateManyUserInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class SessionCreateManyUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    token!: string;
    @Field(() => Date, {nullable:false})
    expiresAt!: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => String, {nullable:false})
    device!: string;
    @Field(() => Float, {nullable:false})
    ipAddress!: number;
}

@InputType()
export class SessionCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    token!: string;
    @Field(() => Date, {nullable:false})
    expiresAt!: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => String, {nullable:false})
    device!: string;
    @Field(() => Float, {nullable:false})
    ipAddress!: number;
}

@InputType()
export class SessionCreateNestedManyWithoutUserInput {
    @Field(() => [SessionCreateWithoutUserInput], {nullable:true})
    @Type(() => SessionCreateWithoutUserInput)
    create?: Array<SessionCreateWithoutUserInput>;
    @Field(() => [SessionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => SessionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<SessionCreateOrConnectWithoutUserInput>;
    @Field(() => SessionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => SessionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof SessionCreateManyUserInputEnvelope>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
}

@InputType()
export class SessionCreateOrConnectWithoutUserInput {
    @Field(() => SessionWhereUniqueInput, {nullable:false})
    @Type(() => SessionWhereUniqueInput)
    where!: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
    @Field(() => SessionCreateWithoutUserInput, {nullable:false})
    @Type(() => SessionCreateWithoutUserInput)
    create!: InstanceType<typeof SessionCreateWithoutUserInput>;
}

@InputType()
export class SessionCreateWithoutUserInput {
    @Field(() => String, {nullable:false})
    token!: string;
    @Field(() => Date, {nullable:false})
    expiresAt!: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => String, {nullable:false})
    device!: string;
    @Field(() => Float, {nullable:false})
    ipAddress!: number;
}

@InputType()
export class SessionCreateInput {
    @Field(() => String, {nullable:false})
    token!: string;
    @Field(() => Date, {nullable:false})
    expiresAt!: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => String, {nullable:false})
    device!: string;
    @Field(() => Float, {nullable:false})
    ipAddress!: number;
    @Field(() => UserCreateNestedOneWithoutSessionsInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutSessionsInput>;
}

@ArgsType()
export class SessionGroupByArgs {
    @Field(() => SessionWhereInput, {nullable:true})
    @Type(() => SessionWhereInput)
    where?: InstanceType<typeof SessionWhereInput>;
    @Field(() => [SessionOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<SessionOrderByWithAggregationInput>;
    @Field(() => [SessionScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof SessionScalarFieldEnum>;
    @Field(() => SessionScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof SessionScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => SessionCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof SessionCountAggregateInput>;
    @Field(() => SessionAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof SessionAvgAggregateInput>;
    @Field(() => SessionSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof SessionSumAggregateInput>;
    @Field(() => SessionMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof SessionMinAggregateInput>;
    @Field(() => SessionMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof SessionMaxAggregateInput>;
}

@ObjectType()
export class SessionGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    token!: string;
    @Field(() => Date, {nullable:false})
    expiresAt!: Date | string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => String, {nullable:false})
    device!: string;
    @Field(() => Float, {nullable:false})
    ipAddress!: number;
    @Field(() => SessionCountAggregate, {nullable:true})
    _count?: InstanceType<typeof SessionCountAggregate>;
    @Field(() => SessionAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof SessionAvgAggregate>;
    @Field(() => SessionSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof SessionSumAggregate>;
    @Field(() => SessionMinAggregate, {nullable:true})
    _min?: InstanceType<typeof SessionMinAggregate>;
    @Field(() => SessionMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof SessionMaxAggregate>;
}

@InputType()
export class SessionListRelationFilter {
    @Field(() => SessionWhereInput, {nullable:true})
    every?: InstanceType<typeof SessionWhereInput>;
    @Field(() => SessionWhereInput, {nullable:true})
    some?: InstanceType<typeof SessionWhereInput>;
    @Field(() => SessionWhereInput, {nullable:true})
    none?: InstanceType<typeof SessionWhereInput>;
}

@InputType()
export class SessionMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    token?: true;
    @Field(() => Boolean, {nullable:true})
    expiresAt?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    device?: true;
    @Field(() => Boolean, {nullable:true})
    ipAddress?: true;
}

@ObjectType()
export class SessionMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    token?: string;
    @Field(() => Date, {nullable:true})
    expiresAt?: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => String, {nullable:true})
    device?: string;
    @Field(() => Float, {nullable:true})
    ipAddress?: number;
}

@InputType()
export class SessionMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    token?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    expiresAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    device?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    ipAddress?: keyof typeof SortOrder;
}

@InputType()
export class SessionMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    token?: true;
    @Field(() => Boolean, {nullable:true})
    expiresAt?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    device?: true;
    @Field(() => Boolean, {nullable:true})
    ipAddress?: true;
}

@ObjectType()
export class SessionMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    token?: string;
    @Field(() => Date, {nullable:true})
    expiresAt?: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => String, {nullable:true})
    device?: string;
    @Field(() => Float, {nullable:true})
    ipAddress?: number;
}

@InputType()
export class SessionMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    token?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    expiresAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    device?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    ipAddress?: keyof typeof SortOrder;
}

@InputType()
export class SessionOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class SessionOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    token?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    expiresAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    device?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    ipAddress?: keyof typeof SortOrder;
    @Field(() => SessionCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof SessionCountOrderByAggregateInput>;
    @Field(() => SessionAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof SessionAvgOrderByAggregateInput>;
    @Field(() => SessionMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof SessionMaxOrderByAggregateInput>;
    @Field(() => SessionMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof SessionMinOrderByAggregateInput>;
    @Field(() => SessionSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof SessionSumOrderByAggregateInput>;
}

@InputType()
export class SessionOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    token?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    expiresAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    device?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    ipAddress?: keyof typeof SortOrder;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    user?: InstanceType<typeof UserOrderByWithRelationInput>;
}

@InputType()
export class SessionScalarWhereWithAggregatesInput {
    @Field(() => [SessionScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<SessionScalarWhereWithAggregatesInput>;
    @Field(() => [SessionScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<SessionScalarWhereWithAggregatesInput>;
    @Field(() => [SessionScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<SessionScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    token?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    userId?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    device?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    ipAddress?: InstanceType<typeof FloatWithAggregatesFilter>;
}

@InputType()
export class SessionScalarWhereInput {
    @Field(() => [SessionScalarWhereInput], {nullable:true})
    AND?: Array<SessionScalarWhereInput>;
    @Field(() => [SessionScalarWhereInput], {nullable:true})
    OR?: Array<SessionScalarWhereInput>;
    @Field(() => [SessionScalarWhereInput], {nullable:true})
    NOT?: Array<SessionScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    token?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    device?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFilter>;
}

@InputType()
export class SessionSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    ipAddress?: true;
}

@ObjectType()
export class SessionSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    ipAddress?: number;
}

@InputType()
export class SessionSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    ipAddress?: keyof typeof SortOrder;
}

@InputType()
export class SessionUncheckedCreateNestedManyWithoutUserInput {
    @Field(() => [SessionCreateWithoutUserInput], {nullable:true})
    @Type(() => SessionCreateWithoutUserInput)
    create?: Array<SessionCreateWithoutUserInput>;
    @Field(() => [SessionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => SessionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<SessionCreateOrConnectWithoutUserInput>;
    @Field(() => SessionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => SessionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof SessionCreateManyUserInputEnvelope>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
}

@InputType()
export class SessionUncheckedCreateWithoutUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    token!: string;
    @Field(() => Date, {nullable:false})
    expiresAt!: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => String, {nullable:false})
    device!: string;
    @Field(() => Float, {nullable:false})
    ipAddress!: number;
}

@InputType()
export class SessionUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    token!: string;
    @Field(() => Date, {nullable:false})
    expiresAt!: Date | string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => String, {nullable:false})
    device!: string;
    @Field(() => Float, {nullable:false})
    ipAddress!: number;
}

@InputType()
export class SessionUncheckedUpdateManyWithoutUserNestedInput {
    @Field(() => [SessionCreateWithoutUserInput], {nullable:true})
    @Type(() => SessionCreateWithoutUserInput)
    create?: Array<SessionCreateWithoutUserInput>;
    @Field(() => [SessionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => SessionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<SessionCreateOrConnectWithoutUserInput>;
    @Field(() => [SessionUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => SessionUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<SessionUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => SessionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => SessionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof SessionCreateManyUserInputEnvelope>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    set?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
    @Field(() => [SessionUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => SessionUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<SessionUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [SessionUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => SessionUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<SessionUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [SessionScalarWhereInput], {nullable:true})
    @Type(() => SessionScalarWhereInput)
    deleteMany?: Array<SessionScalarWhereInput>;
}

@InputType()
export class SessionUncheckedUpdateManyWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    token?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    device?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
}

@InputType()
export class SessionUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    token?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    device?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
}

@InputType()
export class SessionUncheckedUpdateWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    token?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    device?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
}

@InputType()
export class SessionUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    token?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    device?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
}

@InputType()
export class SessionUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    token?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    device?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
}

@InputType()
export class SessionUpdateManyWithWhereWithoutUserInput {
    @Field(() => SessionScalarWhereInput, {nullable:false})
    @Type(() => SessionScalarWhereInput)
    where!: InstanceType<typeof SessionScalarWhereInput>;
    @Field(() => SessionUpdateManyMutationInput, {nullable:false})
    @Type(() => SessionUpdateManyMutationInput)
    data!: InstanceType<typeof SessionUpdateManyMutationInput>;
}

@InputType()
export class SessionUpdateManyWithoutUserNestedInput {
    @Field(() => [SessionCreateWithoutUserInput], {nullable:true})
    @Type(() => SessionCreateWithoutUserInput)
    create?: Array<SessionCreateWithoutUserInput>;
    @Field(() => [SessionCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => SessionCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<SessionCreateOrConnectWithoutUserInput>;
    @Field(() => [SessionUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => SessionUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<SessionUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => SessionCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => SessionCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof SessionCreateManyUserInputEnvelope>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    set?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
    @Field(() => [SessionWhereUniqueInput], {nullable:true})
    @Type(() => SessionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>>;
    @Field(() => [SessionUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => SessionUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<SessionUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [SessionUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => SessionUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<SessionUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [SessionScalarWhereInput], {nullable:true})
    @Type(() => SessionScalarWhereInput)
    deleteMany?: Array<SessionScalarWhereInput>;
}

@InputType()
export class SessionUpdateWithWhereUniqueWithoutUserInput {
    @Field(() => SessionWhereUniqueInput, {nullable:false})
    @Type(() => SessionWhereUniqueInput)
    where!: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
    @Field(() => SessionUpdateWithoutUserInput, {nullable:false})
    @Type(() => SessionUpdateWithoutUserInput)
    data!: InstanceType<typeof SessionUpdateWithoutUserInput>;
}

@InputType()
export class SessionUpdateWithoutUserInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    token?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    device?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
}

@InputType()
export class SessionUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    token?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    device?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutSessionsNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutSessionsNestedInput>;
}

@InputType()
export class SessionUpsertWithWhereUniqueWithoutUserInput {
    @Field(() => SessionWhereUniqueInput, {nullable:false})
    @Type(() => SessionWhereUniqueInput)
    where!: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
    @Field(() => SessionUpdateWithoutUserInput, {nullable:false})
    @Type(() => SessionUpdateWithoutUserInput)
    update!: InstanceType<typeof SessionUpdateWithoutUserInput>;
    @Field(() => SessionCreateWithoutUserInput, {nullable:false})
    @Type(() => SessionCreateWithoutUserInput)
    create!: InstanceType<typeof SessionCreateWithoutUserInput>;
}

@InputType()
export class SessionWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    token?: string;
    @Field(() => [SessionWhereInput], {nullable:true})
    AND?: Array<SessionWhereInput>;
    @Field(() => [SessionWhereInput], {nullable:true})
    OR?: Array<SessionWhereInput>;
    @Field(() => [SessionWhereInput], {nullable:true})
    NOT?: Array<SessionWhereInput>;
    @Field(() => DateTimeFilter, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    device?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
}

@InputType()
export class SessionWhereInput {
    @Field(() => [SessionWhereInput], {nullable:true})
    AND?: Array<SessionWhereInput>;
    @Field(() => [SessionWhereInput], {nullable:true})
    OR?: Array<SessionWhereInput>;
    @Field(() => [SessionWhereInput], {nullable:true})
    NOT?: Array<SessionWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    token?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    expiresAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    device?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    ipAddress?: InstanceType<typeof FloatFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
}

@ObjectType()
export class Session {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    token!: string;
    @Field(() => Date, {nullable:false})
    expiresAt!: Date;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => String, {nullable:false})
    device!: string;
    @Field(() => Float, {nullable:false})
    ipAddress!: number;
    @Field(() => User, {nullable:false})
    user?: InstanceType<typeof User>;
}

@ArgsType()
export class UpdateManySessionArgs {
    @Field(() => SessionUpdateManyMutationInput, {nullable:false})
    @Type(() => SessionUpdateManyMutationInput)
    data!: InstanceType<typeof SessionUpdateManyMutationInput>;
    @Field(() => SessionWhereInput, {nullable:true})
    @Type(() => SessionWhereInput)
    where?: InstanceType<typeof SessionWhereInput>;
}

@ArgsType()
export class UpdateOneSessionArgs {
    @Field(() => SessionUpdateInput, {nullable:false})
    @Type(() => SessionUpdateInput)
    data!: InstanceType<typeof SessionUpdateInput>;
    @Field(() => SessionWhereUniqueInput, {nullable:false})
    @Type(() => SessionWhereUniqueInput)
    where!: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
}

@ArgsType()
export class UpsertOneSessionArgs {
    @Field(() => SessionWhereUniqueInput, {nullable:false})
    @Type(() => SessionWhereUniqueInput)
    where!: Prisma.AtLeast<SessionWhereUniqueInput, 'id' | 'token'>;
    @Field(() => SessionCreateInput, {nullable:false})
    @Type(() => SessionCreateInput)
    create!: InstanceType<typeof SessionCreateInput>;
    @Field(() => SessionUpdateInput, {nullable:false})
    @Type(() => SessionUpdateInput)
    update!: InstanceType<typeof SessionUpdateInput>;
}

@ObjectType()
export class AggregateShipping {
    @Field(() => ShippingCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ShippingCountAggregate>;
    @Field(() => ShippingAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ShippingAvgAggregate>;
    @Field(() => ShippingSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ShippingSumAggregate>;
    @Field(() => ShippingMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ShippingMinAggregate>;
    @Field(() => ShippingMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ShippingMaxAggregate>;
}

@ArgsType()
export class CreateManyShippingArgs {
    @Field(() => [ShippingCreateManyInput], {nullable:false})
    @Type(() => ShippingCreateManyInput)
    data!: Array<ShippingCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneShippingArgs {
    @Field(() => ShippingCreateInput, {nullable:false})
    @Type(() => ShippingCreateInput)
    data!: InstanceType<typeof ShippingCreateInput>;
}

@ArgsType()
export class DeleteManyShippingArgs {
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
}

@ArgsType()
export class DeleteOneShippingArgs {
    @Field(() => ShippingWhereUniqueInput, {nullable:false})
    @Type(() => ShippingWhereUniqueInput)
    where!: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
}

@ArgsType()
export class FindFirstShippingOrThrowArgs {
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => [ShippingOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ShippingOrderByWithRelationInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ShippingScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ShippingScalarFieldEnum>;
}

@ArgsType()
export class FindFirstShippingArgs {
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => [ShippingOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ShippingOrderByWithRelationInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ShippingScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ShippingScalarFieldEnum>;
}

@ArgsType()
export class FindManyShippingArgs {
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => [ShippingOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ShippingOrderByWithRelationInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [ShippingScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof ShippingScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueShippingOrThrowArgs {
    @Field(() => ShippingWhereUniqueInput, {nullable:false})
    @Type(() => ShippingWhereUniqueInput)
    where!: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
}

@ArgsType()
export class FindUniqueShippingArgs {
    @Field(() => ShippingWhereUniqueInput, {nullable:false})
    @Type(() => ShippingWhereUniqueInput)
    where!: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
}

@ArgsType()
export class ShippingAggregateArgs {
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => [ShippingOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<ShippingOrderByWithRelationInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ShippingCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ShippingCountAggregateInput>;
    @Field(() => ShippingAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ShippingAvgAggregateInput>;
    @Field(() => ShippingSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ShippingSumAggregateInput>;
    @Field(() => ShippingMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ShippingMinAggregateInput>;
    @Field(() => ShippingMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ShippingMaxAggregateInput>;
}

@InputType()
export class ShippingAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @HideField()
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
}

@ObjectType()
export class ShippingAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    addressId?: number;
    @Field(() => Float, {nullable:true})
    orderId?: number;
}

@InputType()
export class ShippingAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @HideField()
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
}

@InputType()
export class ShippingCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    logisticName?: true;
    @Field(() => Boolean, {nullable:true})
    deliveryDate?: true;
    @HideField()
    shippingStatus?: true;
    @HideField()
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    courier?: true;
    @Field(() => Boolean, {nullable:true})
    estimatedTime?: true;
    @Field(() => Boolean, {nullable:true})
    trackingNo?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
    @HideField()
    createdAt?: true;
    @HideField()
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class ShippingCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    logisticName!: number;
    @Field(() => Int, {nullable:false})
    deliveryDate!: number;
    @Field(() => Int, {nullable:false})
    shippingStatus!: number;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => Int, {nullable:false})
    courier!: number;
    @Field(() => Int, {nullable:false})
    estimatedTime!: number;
    @Field(() => Int, {nullable:false})
    trackingNo!: number;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class ShippingCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logisticName?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    deliveryDate?: keyof typeof SortOrder;
    @HideField()
    shippingStatus?: keyof typeof SortOrder;
    @HideField()
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    courier?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    estimatedTime?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    trackingNo?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ShippingCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    logisticName!: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @HideField()
    shippingStatus!: keyof typeof ShippingStatus;
    @HideField()
    addressId!: number;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class ShippingCreateNestedOneWithoutAddressInput {
    @Field(() => ShippingCreateWithoutAddressInput, {nullable:true})
    @Type(() => ShippingCreateWithoutAddressInput)
    create?: InstanceType<typeof ShippingCreateWithoutAddressInput>;
    @Field(() => ShippingCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => ShippingCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof ShippingCreateOrConnectWithoutAddressInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    @Type(() => ShippingWhereUniqueInput)
    connect?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
}

@InputType()
export class ShippingCreateNestedOneWithoutOrderInput {
    @Field(() => ShippingCreateWithoutOrderInput, {nullable:true})
    @Type(() => ShippingCreateWithoutOrderInput)
    create?: InstanceType<typeof ShippingCreateWithoutOrderInput>;
    @Field(() => ShippingCreateOrConnectWithoutOrderInput, {nullable:true})
    @Type(() => ShippingCreateOrConnectWithoutOrderInput)
    connectOrCreate?: InstanceType<typeof ShippingCreateOrConnectWithoutOrderInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    @Type(() => ShippingWhereUniqueInput)
    connect?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
}

@InputType()
export class ShippingCreateOrConnectWithoutAddressInput {
    @Field(() => ShippingWhereUniqueInput, {nullable:false})
    @Type(() => ShippingWhereUniqueInput)
    where!: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => ShippingCreateWithoutAddressInput, {nullable:false})
    @Type(() => ShippingCreateWithoutAddressInput)
    create!: InstanceType<typeof ShippingCreateWithoutAddressInput>;
}

@InputType()
export class ShippingCreateOrConnectWithoutOrderInput {
    @Field(() => ShippingWhereUniqueInput, {nullable:false})
    @Type(() => ShippingWhereUniqueInput)
    where!: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => ShippingCreateWithoutOrderInput, {nullable:false})
    @Type(() => ShippingCreateWithoutOrderInput)
    create!: InstanceType<typeof ShippingCreateWithoutOrderInput>;
}

@InputType()
export class ShippingCreateWithoutAddressInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    logisticName!: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @HideField()
    shippingStatus!: keyof typeof ShippingStatus;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => OrderCreateNestedOneWithoutShippingInput, {nullable:false})
    order!: InstanceType<typeof OrderCreateNestedOneWithoutShippingInput>;
}

@InputType()
export class ShippingCreateWithoutOrderInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    logisticName!: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @HideField()
    shippingStatus!: keyof typeof ShippingStatus;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    address!: InstanceType<typeof AddressCreateNestedOneWithoutShippingInput>;
}

@InputType()
export class ShippingCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    logisticName!: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @HideField()
    shippingStatus!: keyof typeof ShippingStatus;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    address!: InstanceType<typeof AddressCreateNestedOneWithoutShippingInput>;
    @Field(() => OrderCreateNestedOneWithoutShippingInput, {nullable:false})
    order!: InstanceType<typeof OrderCreateNestedOneWithoutShippingInput>;
}

@ArgsType()
export class ShippingGroupByArgs {
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => [ShippingOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<ShippingOrderByWithAggregationInput>;
    @Field(() => [ShippingScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof ShippingScalarFieldEnum>;
    @Field(() => ShippingScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof ShippingScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => ShippingCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ShippingCountAggregateInput>;
    @Field(() => ShippingAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ShippingAvgAggregateInput>;
    @Field(() => ShippingSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ShippingSumAggregateInput>;
    @Field(() => ShippingMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ShippingMinAggregateInput>;
    @Field(() => ShippingMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ShippingMaxAggregateInput>;
}

@ObjectType()
export class ShippingGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    logisticName!: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @Field(() => ShippingStatus, {nullable:false})
    shippingStatus!: keyof typeof ShippingStatus;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => ShippingCountAggregate, {nullable:true})
    _count?: InstanceType<typeof ShippingCountAggregate>;
    @Field(() => ShippingAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof ShippingAvgAggregate>;
    @Field(() => ShippingSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof ShippingSumAggregate>;
    @Field(() => ShippingMinAggregate, {nullable:true})
    _min?: InstanceType<typeof ShippingMinAggregate>;
    @Field(() => ShippingMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof ShippingMaxAggregate>;
}

@InputType()
export class ShippingMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    logisticName?: true;
    @Field(() => Boolean, {nullable:true})
    deliveryDate?: true;
    @HideField()
    shippingStatus?: true;
    @HideField()
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    courier?: true;
    @Field(() => Boolean, {nullable:true})
    estimatedTime?: true;
    @Field(() => Boolean, {nullable:true})
    trackingNo?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
    @HideField()
    createdAt?: true;
    @HideField()
    updatedAt?: true;
}

@ObjectType()
export class ShippingMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    logisticName?: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @Field(() => ShippingStatus, {nullable:true})
    shippingStatus?: keyof typeof ShippingStatus;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @Field(() => Int, {nullable:true})
    orderId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ShippingMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logisticName?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    deliveryDate?: keyof typeof SortOrder;
    @HideField()
    shippingStatus?: keyof typeof SortOrder;
    @HideField()
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    courier?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    estimatedTime?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    trackingNo?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ShippingMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    logisticName?: true;
    @Field(() => Boolean, {nullable:true})
    deliveryDate?: true;
    @HideField()
    shippingStatus?: true;
    @HideField()
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    courier?: true;
    @Field(() => Boolean, {nullable:true})
    estimatedTime?: true;
    @Field(() => Boolean, {nullable:true})
    trackingNo?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
    @HideField()
    createdAt?: true;
    @HideField()
    updatedAt?: true;
}

@ObjectType()
export class ShippingMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    logisticName?: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @Field(() => ShippingStatus, {nullable:true})
    shippingStatus?: keyof typeof ShippingStatus;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @Field(() => Int, {nullable:true})
    orderId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class ShippingMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logisticName?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    deliveryDate?: keyof typeof SortOrder;
    @HideField()
    shippingStatus?: keyof typeof SortOrder;
    @HideField()
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    courier?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    estimatedTime?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    trackingNo?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class ShippingNullableRelationFilter {
    @Field(() => ShippingWhereInput, {nullable:true})
    is?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    isNot?: InstanceType<typeof ShippingWhereInput>;
}

@InputType()
export class ShippingOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logisticName?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    deliveryDate?: InstanceType<typeof SortOrderInput>;
    @HideField()
    shippingStatus?: keyof typeof SortOrder;
    @HideField()
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    courier?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    estimatedTime?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    trackingNo?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
    @Field(() => ShippingCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof ShippingCountOrderByAggregateInput>;
    @Field(() => ShippingAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof ShippingAvgOrderByAggregateInput>;
    @Field(() => ShippingMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof ShippingMaxOrderByAggregateInput>;
    @Field(() => ShippingMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof ShippingMinOrderByAggregateInput>;
    @Field(() => ShippingSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof ShippingSumOrderByAggregateInput>;
}

@InputType()
export class ShippingOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    logisticName?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    deliveryDate?: InstanceType<typeof SortOrderInput>;
    @HideField()
    shippingStatus?: keyof typeof SortOrder;
    @HideField()
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    courier?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    estimatedTime?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    trackingNo?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
    @HideField()
    createdAt?: keyof typeof SortOrder;
    @HideField()
    updatedAt?: keyof typeof SortOrder;
    @Field(() => AddressOrderByWithRelationInput, {nullable:true})
    address?: InstanceType<typeof AddressOrderByWithRelationInput>;
    @Field(() => OrderOrderByWithRelationInput, {nullable:true})
    order?: InstanceType<typeof OrderOrderByWithRelationInput>;
}

@InputType()
export class ShippingScalarWhereWithAggregatesInput {
    @Field(() => [ShippingScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<ShippingScalarWhereWithAggregatesInput>;
    @Field(() => [ShippingScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<ShippingScalarWhereWithAggregatesInput>;
    @Field(() => [ShippingScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<ShippingScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    logisticName?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeNullableWithAggregatesFilter, {nullable:true})
    deliveryDate?: InstanceType<typeof DateTimeNullableWithAggregatesFilter>;
    @HideField()
    shippingStatus?: InstanceType<typeof EnumShippingStatusWithAggregatesFilter>;
    @HideField()
    addressId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringNullableWithAggregatesFilter, {nullable:true})
    courier?: InstanceType<typeof StringNullableWithAggregatesFilter>;
    @Field(() => StringNullableWithAggregatesFilter, {nullable:true})
    estimatedTime?: InstanceType<typeof StringNullableWithAggregatesFilter>;
    @Field(() => StringNullableWithAggregatesFilter, {nullable:true})
    trackingNo?: InstanceType<typeof StringNullableWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    orderId?: InstanceType<typeof IntWithAggregatesFilter>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class ShippingSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @HideField()
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    orderId?: true;
}

@ObjectType()
export class ShippingSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => Int, {nullable:true})
    orderId?: number;
}

@InputType()
export class ShippingSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @HideField()
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    orderId?: keyof typeof SortOrder;
}

@InputType()
export class ShippingUncheckedCreateNestedOneWithoutAddressInput {
    @Field(() => ShippingCreateWithoutAddressInput, {nullable:true})
    @Type(() => ShippingCreateWithoutAddressInput)
    create?: InstanceType<typeof ShippingCreateWithoutAddressInput>;
    @Field(() => ShippingCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => ShippingCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof ShippingCreateOrConnectWithoutAddressInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    @Type(() => ShippingWhereUniqueInput)
    connect?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
}

@InputType()
export class ShippingUncheckedCreateNestedOneWithoutOrderInput {
    @Field(() => ShippingCreateWithoutOrderInput, {nullable:true})
    @Type(() => ShippingCreateWithoutOrderInput)
    create?: InstanceType<typeof ShippingCreateWithoutOrderInput>;
    @Field(() => ShippingCreateOrConnectWithoutOrderInput, {nullable:true})
    @Type(() => ShippingCreateOrConnectWithoutOrderInput)
    connectOrCreate?: InstanceType<typeof ShippingCreateOrConnectWithoutOrderInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    @Type(() => ShippingWhereUniqueInput)
    connect?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
}

@InputType()
export class ShippingUncheckedCreateWithoutAddressInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    logisticName!: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @HideField()
    shippingStatus!: keyof typeof ShippingStatus;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class ShippingUncheckedCreateWithoutOrderInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    logisticName!: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @HideField()
    shippingStatus!: keyof typeof ShippingStatus;
    @HideField()
    addressId!: number;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class ShippingUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlphanumeric()
    logisticName!: string;
    @Field(() => Date, {nullable:true})
    deliveryDate?: Date | string;
    @HideField()
    shippingStatus!: keyof typeof ShippingStatus;
    @HideField()
    addressId!: number;
    @Field(() => String, {nullable:true})
    courier?: string;
    @Field(() => String, {nullable:true})
    estimatedTime?: string;
    @Field(() => String, {nullable:true})
    trackingNo?: string;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class ShippingUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logisticName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deliveryDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @HideField()
    shippingStatus?: InstanceType<typeof EnumShippingStatusFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    courier?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    estimatedTime?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    trackingNo?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    orderId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ShippingUncheckedUpdateOneWithoutAddressNestedInput {
    @Field(() => ShippingCreateWithoutAddressInput, {nullable:true})
    @Type(() => ShippingCreateWithoutAddressInput)
    create?: InstanceType<typeof ShippingCreateWithoutAddressInput>;
    @Field(() => ShippingCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => ShippingCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof ShippingCreateOrConnectWithoutAddressInput>;
    @Field(() => ShippingUpsertWithoutAddressInput, {nullable:true})
    @Type(() => ShippingUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof ShippingUpsertWithoutAddressInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    disconnect?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    delete?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    @Type(() => ShippingWhereUniqueInput)
    connect?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => ShippingUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => ShippingUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof ShippingUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class ShippingUncheckedUpdateOneWithoutOrderNestedInput {
    @Field(() => ShippingCreateWithoutOrderInput, {nullable:true})
    @Type(() => ShippingCreateWithoutOrderInput)
    create?: InstanceType<typeof ShippingCreateWithoutOrderInput>;
    @Field(() => ShippingCreateOrConnectWithoutOrderInput, {nullable:true})
    @Type(() => ShippingCreateOrConnectWithoutOrderInput)
    connectOrCreate?: InstanceType<typeof ShippingCreateOrConnectWithoutOrderInput>;
    @Field(() => ShippingUpsertWithoutOrderInput, {nullable:true})
    @Type(() => ShippingUpsertWithoutOrderInput)
    upsert?: InstanceType<typeof ShippingUpsertWithoutOrderInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    disconnect?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    delete?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    @Type(() => ShippingWhereUniqueInput)
    connect?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => ShippingUpdateToOneWithWhereWithoutOrderInput, {nullable:true})
    @Type(() => ShippingUpdateToOneWithWhereWithoutOrderInput)
    update?: InstanceType<typeof ShippingUpdateToOneWithWhereWithoutOrderInput>;
}

@InputType()
export class ShippingUncheckedUpdateWithoutAddressInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logisticName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deliveryDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @HideField()
    shippingStatus?: InstanceType<typeof EnumShippingStatusFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    courier?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    estimatedTime?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    trackingNo?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    orderId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ShippingUncheckedUpdateWithoutOrderInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logisticName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deliveryDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @HideField()
    shippingStatus?: InstanceType<typeof EnumShippingStatusFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    courier?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    estimatedTime?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    trackingNo?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ShippingUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logisticName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deliveryDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @HideField()
    shippingStatus?: InstanceType<typeof EnumShippingStatusFieldUpdateOperationsInput>;
    @HideField()
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    courier?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    estimatedTime?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    trackingNo?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    orderId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ShippingUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logisticName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deliveryDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @HideField()
    shippingStatus?: InstanceType<typeof EnumShippingStatusFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    courier?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    estimatedTime?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    trackingNo?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class ShippingUpdateOneWithoutAddressNestedInput {
    @Field(() => ShippingCreateWithoutAddressInput, {nullable:true})
    @Type(() => ShippingCreateWithoutAddressInput)
    create?: InstanceType<typeof ShippingCreateWithoutAddressInput>;
    @Field(() => ShippingCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => ShippingCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof ShippingCreateOrConnectWithoutAddressInput>;
    @Field(() => ShippingUpsertWithoutAddressInput, {nullable:true})
    @Type(() => ShippingUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof ShippingUpsertWithoutAddressInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    disconnect?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    delete?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    @Type(() => ShippingWhereUniqueInput)
    connect?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => ShippingUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => ShippingUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof ShippingUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class ShippingUpdateOneWithoutOrderNestedInput {
    @Field(() => ShippingCreateWithoutOrderInput, {nullable:true})
    @Type(() => ShippingCreateWithoutOrderInput)
    create?: InstanceType<typeof ShippingCreateWithoutOrderInput>;
    @Field(() => ShippingCreateOrConnectWithoutOrderInput, {nullable:true})
    @Type(() => ShippingCreateOrConnectWithoutOrderInput)
    connectOrCreate?: InstanceType<typeof ShippingCreateOrConnectWithoutOrderInput>;
    @Field(() => ShippingUpsertWithoutOrderInput, {nullable:true})
    @Type(() => ShippingUpsertWithoutOrderInput)
    upsert?: InstanceType<typeof ShippingUpsertWithoutOrderInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    disconnect?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    delete?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:true})
    @Type(() => ShippingWhereUniqueInput)
    connect?: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => ShippingUpdateToOneWithWhereWithoutOrderInput, {nullable:true})
    @Type(() => ShippingUpdateToOneWithWhereWithoutOrderInput)
    update?: InstanceType<typeof ShippingUpdateToOneWithWhereWithoutOrderInput>;
}

@InputType()
export class ShippingUpdateToOneWithWhereWithoutAddressInput {
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingUpdateWithoutAddressInput, {nullable:false})
    @Type(() => ShippingUpdateWithoutAddressInput)
    data!: InstanceType<typeof ShippingUpdateWithoutAddressInput>;
}

@InputType()
export class ShippingUpdateToOneWithWhereWithoutOrderInput {
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
    @Field(() => ShippingUpdateWithoutOrderInput, {nullable:false})
    @Type(() => ShippingUpdateWithoutOrderInput)
    data!: InstanceType<typeof ShippingUpdateWithoutOrderInput>;
}

@InputType()
export class ShippingUpdateWithoutAddressInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logisticName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deliveryDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @HideField()
    shippingStatus?: InstanceType<typeof EnumShippingStatusFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    courier?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    estimatedTime?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    trackingNo?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => OrderUpdateOneRequiredWithoutShippingNestedInput, {nullable:true})
    order?: InstanceType<typeof OrderUpdateOneRequiredWithoutShippingNestedInput>;
}

@InputType()
export class ShippingUpdateWithoutOrderInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logisticName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deliveryDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @HideField()
    shippingStatus?: InstanceType<typeof EnumShippingStatusFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    courier?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    estimatedTime?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    trackingNo?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutShippingNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutShippingNestedInput>;
}

@InputType()
export class ShippingUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    logisticName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deliveryDate?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @HideField()
    shippingStatus?: InstanceType<typeof EnumShippingStatusFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    courier?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    estimatedTime?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    trackingNo?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutShippingNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutShippingNestedInput>;
    @Field(() => OrderUpdateOneRequiredWithoutShippingNestedInput, {nullable:true})
    order?: InstanceType<typeof OrderUpdateOneRequiredWithoutShippingNestedInput>;
}

@InputType()
export class ShippingUpsertWithoutAddressInput {
    @Field(() => ShippingUpdateWithoutAddressInput, {nullable:false})
    @Type(() => ShippingUpdateWithoutAddressInput)
    update!: InstanceType<typeof ShippingUpdateWithoutAddressInput>;
    @Field(() => ShippingCreateWithoutAddressInput, {nullable:false})
    @Type(() => ShippingCreateWithoutAddressInput)
    create!: InstanceType<typeof ShippingCreateWithoutAddressInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
}

@InputType()
export class ShippingUpsertWithoutOrderInput {
    @Field(() => ShippingUpdateWithoutOrderInput, {nullable:false})
    @Type(() => ShippingUpdateWithoutOrderInput)
    update!: InstanceType<typeof ShippingUpdateWithoutOrderInput>;
    @Field(() => ShippingCreateWithoutOrderInput, {nullable:false})
    @Type(() => ShippingCreateWithoutOrderInput)
    create!: InstanceType<typeof ShippingCreateWithoutOrderInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
}

@InputType()
export class ShippingWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @HideField()
    addressId?: number;
    @Field(() => Int, {nullable:true})
    orderId?: number;
    @Field(() => [ShippingWhereInput], {nullable:true})
    AND?: Array<ShippingWhereInput>;
    @Field(() => [ShippingWhereInput], {nullable:true})
    OR?: Array<ShippingWhereInput>;
    @Field(() => [ShippingWhereInput], {nullable:true})
    NOT?: Array<ShippingWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    logisticName?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeNullableFilter, {nullable:true})
    deliveryDate?: InstanceType<typeof DateTimeNullableFilter>;
    @HideField()
    shippingStatus?: InstanceType<typeof EnumShippingStatusFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    courier?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    estimatedTime?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    trackingNo?: InstanceType<typeof StringNullableFilter>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => AddressRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressRelationFilter>;
    @Field(() => OrderRelationFilter, {nullable:true})
    order?: InstanceType<typeof OrderRelationFilter>;
}

@InputType()
export class ShippingWhereInput {
    @Field(() => [ShippingWhereInput], {nullable:true})
    AND?: Array<ShippingWhereInput>;
    @Field(() => [ShippingWhereInput], {nullable:true})
    OR?: Array<ShippingWhereInput>;
    @Field(() => [ShippingWhereInput], {nullable:true})
    NOT?: Array<ShippingWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    logisticName?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeNullableFilter, {nullable:true})
    deliveryDate?: InstanceType<typeof DateTimeNullableFilter>;
    @HideField()
    shippingStatus?: InstanceType<typeof EnumShippingStatusFilter>;
    @HideField()
    addressId?: InstanceType<typeof IntFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    courier?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    estimatedTime?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    trackingNo?: InstanceType<typeof StringNullableFilter>;
    @Field(() => IntFilter, {nullable:true})
    orderId?: InstanceType<typeof IntFilter>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => AddressRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressRelationFilter>;
    @Field(() => OrderRelationFilter, {nullable:true})
    order?: InstanceType<typeof OrderRelationFilter>;
}

@ObjectType()
export class Shipping {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    logisticName!: string;
    @Field(() => Date, {nullable:true})
    deliveryDate!: Date | null;
    @Field(() => ShippingStatus, {nullable:false})
    shippingStatus!: keyof typeof ShippingStatus;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => String, {nullable:true})
    courier!: string | null;
    @Field(() => String, {nullable:true})
    estimatedTime!: string | null;
    @Field(() => String, {nullable:true})
    trackingNo!: string | null;
    @Field(() => Int, {nullable:false})
    orderId!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => Address, {nullable:false})
    address?: InstanceType<typeof Address>;
    @Field(() => Order, {nullable:false})
    order?: InstanceType<typeof Order>;
}

@ArgsType()
export class UpdateManyShippingArgs {
    @Field(() => ShippingUpdateManyMutationInput, {nullable:false})
    @Type(() => ShippingUpdateManyMutationInput)
    data!: InstanceType<typeof ShippingUpdateManyMutationInput>;
    @Field(() => ShippingWhereInput, {nullable:true})
    @Type(() => ShippingWhereInput)
    where?: InstanceType<typeof ShippingWhereInput>;
}

@ArgsType()
export class UpdateOneShippingArgs {
    @Field(() => ShippingUpdateInput, {nullable:false})
    @Type(() => ShippingUpdateInput)
    data!: InstanceType<typeof ShippingUpdateInput>;
    @Field(() => ShippingWhereUniqueInput, {nullable:false})
    @Type(() => ShippingWhereUniqueInput)
    where!: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
}

@ArgsType()
export class UpsertOneShippingArgs {
    @Field(() => ShippingWhereUniqueInput, {nullable:false})
    @Type(() => ShippingWhereUniqueInput)
    where!: Prisma.AtLeast<ShippingWhereUniqueInput, 'id' | 'addressId' | 'orderId'>;
    @Field(() => ShippingCreateInput, {nullable:false})
    @Type(() => ShippingCreateInput)
    create!: InstanceType<typeof ShippingCreateInput>;
    @Field(() => ShippingUpdateInput, {nullable:false})
    @Type(() => ShippingUpdateInput)
    update!: InstanceType<typeof ShippingUpdateInput>;
}

@ObjectType()
export class AggregateSubdistrict {
    @Field(() => SubdistrictCountAggregate, {nullable:true})
    _count?: InstanceType<typeof SubdistrictCountAggregate>;
    @Field(() => SubdistrictAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof SubdistrictAvgAggregate>;
    @Field(() => SubdistrictSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof SubdistrictSumAggregate>;
    @Field(() => SubdistrictMinAggregate, {nullable:true})
    _min?: InstanceType<typeof SubdistrictMinAggregate>;
    @Field(() => SubdistrictMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof SubdistrictMaxAggregate>;
}

@ArgsType()
export class CreateManySubdistrictArgs {
    @Field(() => [SubdistrictCreateManyInput], {nullable:false})
    @Type(() => SubdistrictCreateManyInput)
    data!: Array<SubdistrictCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneSubdistrictArgs {
    @Field(() => SubdistrictCreateInput, {nullable:false})
    @Type(() => SubdistrictCreateInput)
    data!: InstanceType<typeof SubdistrictCreateInput>;
}

@ArgsType()
export class DeleteManySubdistrictArgs {
    @Field(() => SubdistrictWhereInput, {nullable:true})
    @Type(() => SubdistrictWhereInput)
    where?: InstanceType<typeof SubdistrictWhereInput>;
}

@ArgsType()
export class DeleteOneSubdistrictArgs {
    @Field(() => SubdistrictWhereUniqueInput, {nullable:false})
    @Type(() => SubdistrictWhereUniqueInput)
    where!: Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstSubdistrictOrThrowArgs {
    @Field(() => SubdistrictWhereInput, {nullable:true})
    @Type(() => SubdistrictWhereInput)
    where?: InstanceType<typeof SubdistrictWhereInput>;
    @Field(() => [SubdistrictOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SubdistrictOrderByWithRelationInput>;
    @Field(() => SubdistrictWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [SubdistrictScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof SubdistrictScalarFieldEnum>;
}

@ArgsType()
export class FindFirstSubdistrictArgs {
    @Field(() => SubdistrictWhereInput, {nullable:true})
    @Type(() => SubdistrictWhereInput)
    where?: InstanceType<typeof SubdistrictWhereInput>;
    @Field(() => [SubdistrictOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SubdistrictOrderByWithRelationInput>;
    @Field(() => SubdistrictWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [SubdistrictScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof SubdistrictScalarFieldEnum>;
}

@ArgsType()
export class FindManySubdistrictArgs {
    @Field(() => SubdistrictWhereInput, {nullable:true})
    @Type(() => SubdistrictWhereInput)
    where?: InstanceType<typeof SubdistrictWhereInput>;
    @Field(() => [SubdistrictOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SubdistrictOrderByWithRelationInput>;
    @Field(() => SubdistrictWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [SubdistrictScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof SubdistrictScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueSubdistrictOrThrowArgs {
    @Field(() => SubdistrictWhereUniqueInput, {nullable:false})
    @Type(() => SubdistrictWhereUniqueInput)
    where!: Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueSubdistrictArgs {
    @Field(() => SubdistrictWhereUniqueInput, {nullable:false})
    @Type(() => SubdistrictWhereUniqueInput)
    where!: Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>;
}

@ArgsType()
export class SubdistrictAggregateArgs {
    @Field(() => SubdistrictWhereInput, {nullable:true})
    @Type(() => SubdistrictWhereInput)
    where?: InstanceType<typeof SubdistrictWhereInput>;
    @Field(() => [SubdistrictOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<SubdistrictOrderByWithRelationInput>;
    @Field(() => SubdistrictWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => SubdistrictCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof SubdistrictCountAggregateInput>;
    @Field(() => SubdistrictAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof SubdistrictAvgAggregateInput>;
    @Field(() => SubdistrictSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof SubdistrictSumAggregateInput>;
    @Field(() => SubdistrictMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof SubdistrictMinAggregateInput>;
    @Field(() => SubdistrictMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof SubdistrictMaxAggregateInput>;
}

@InputType()
export class SubdistrictAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    districtId?: true;
}

@ObjectType()
export class SubdistrictAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    districtId?: number;
}

@InputType()
export class SubdistrictAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    districtId?: keyof typeof SortOrder;
}

@InputType()
export class SubdistrictCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    districtId?: true;
    @Field(() => Boolean, {nullable:true})
    postalCode?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class SubdistrictCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    name!: number;
    @Field(() => Int, {nullable:false})
    districtId!: number;
    @Field(() => Int, {nullable:false})
    postalCode!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class SubdistrictCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    districtId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    postalCode?: keyof typeof SortOrder;
}

@ObjectType()
export class SubdistrictCount {
    @Field(() => Int, {nullable:false})
    address?: number;
}

@InputType()
export class SubdistrictCreateManyDistrictInputEnvelope {
    @Field(() => [SubdistrictCreateManyDistrictInput], {nullable:false})
    @Type(() => SubdistrictCreateManyDistrictInput)
    data!: Array<SubdistrictCreateManyDistrictInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class SubdistrictCreateManyDistrictInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(3)
    @Validator.IsPostalCode('ID')
    postalCode!: string;
}

@InputType()
export class SubdistrictCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    districtId!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(3)
    @Validator.IsPostalCode('ID')
    postalCode!: string;
}

@InputType()
export class SubdistrictCreateNestedManyWithoutDistrictInput {
    @Field(() => [SubdistrictCreateWithoutDistrictInput], {nullable:true})
    @Type(() => SubdistrictCreateWithoutDistrictInput)
    create?: Array<SubdistrictCreateWithoutDistrictInput>;
    @Field(() => [SubdistrictCreateOrConnectWithoutDistrictInput], {nullable:true})
    @Type(() => SubdistrictCreateOrConnectWithoutDistrictInput)
    connectOrCreate?: Array<SubdistrictCreateOrConnectWithoutDistrictInput>;
    @Field(() => SubdistrictCreateManyDistrictInputEnvelope, {nullable:true})
    @Type(() => SubdistrictCreateManyDistrictInputEnvelope)
    createMany?: InstanceType<typeof SubdistrictCreateManyDistrictInputEnvelope>;
    @Field(() => [SubdistrictWhereUniqueInput], {nullable:true})
    @Type(() => SubdistrictWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>>;
}

@InputType()
export class SubdistrictCreateNestedOneWithoutAddressInput {
    @Field(() => SubdistrictCreateWithoutAddressInput, {nullable:true})
    @Type(() => SubdistrictCreateWithoutAddressInput)
    create?: InstanceType<typeof SubdistrictCreateWithoutAddressInput>;
    @Field(() => SubdistrictCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => SubdistrictCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof SubdistrictCreateOrConnectWithoutAddressInput>;
    @Field(() => SubdistrictWhereUniqueInput, {nullable:true})
    @Type(() => SubdistrictWhereUniqueInput)
    connect?: Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>;
}

@InputType()
export class SubdistrictCreateOrConnectWithoutAddressInput {
    @Field(() => SubdistrictWhereUniqueInput, {nullable:false})
    @Type(() => SubdistrictWhereUniqueInput)
    where!: Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>;
    @Field(() => SubdistrictCreateWithoutAddressInput, {nullable:false})
    @Type(() => SubdistrictCreateWithoutAddressInput)
    create!: InstanceType<typeof SubdistrictCreateWithoutAddressInput>;
}

@InputType()
export class SubdistrictCreateOrConnectWithoutDistrictInput {
    @Field(() => SubdistrictWhereUniqueInput, {nullable:false})
    @Type(() => SubdistrictWhereUniqueInput)
    where!: Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>;
    @Field(() => SubdistrictCreateWithoutDistrictInput, {nullable:false})
    @Type(() => SubdistrictCreateWithoutDistrictInput)
    create!: InstanceType<typeof SubdistrictCreateWithoutDistrictInput>;
}

@InputType()
export class SubdistrictCreateWithoutAddressInput {
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(3)
    @Validator.IsPostalCode('ID')
    postalCode!: string;
    @Field(() => DistrictCreateNestedOneWithoutSubdistrictsInput, {nullable:false})
    district!: InstanceType<typeof DistrictCreateNestedOneWithoutSubdistrictsInput>;
}

@InputType()
export class SubdistrictCreateWithoutDistrictInput {
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(3)
    @Validator.IsPostalCode('ID')
    postalCode!: string;
    @Field(() => AddressCreateNestedManyWithoutSubdistrictInput, {nullable:true})
    address?: InstanceType<typeof AddressCreateNestedManyWithoutSubdistrictInput>;
}

@InputType()
export class SubdistrictCreateInput {
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(3)
    @Validator.IsPostalCode('ID')
    postalCode!: string;
    @Field(() => DistrictCreateNestedOneWithoutSubdistrictsInput, {nullable:false})
    district!: InstanceType<typeof DistrictCreateNestedOneWithoutSubdistrictsInput>;
    @Field(() => AddressCreateNestedManyWithoutSubdistrictInput, {nullable:true})
    address?: InstanceType<typeof AddressCreateNestedManyWithoutSubdistrictInput>;
}

@ArgsType()
export class SubdistrictGroupByArgs {
    @Field(() => SubdistrictWhereInput, {nullable:true})
    @Type(() => SubdistrictWhereInput)
    where?: InstanceType<typeof SubdistrictWhereInput>;
    @Field(() => [SubdistrictOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<SubdistrictOrderByWithAggregationInput>;
    @Field(() => [SubdistrictScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof SubdistrictScalarFieldEnum>;
    @Field(() => SubdistrictScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof SubdistrictScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => SubdistrictCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof SubdistrictCountAggregateInput>;
    @Field(() => SubdistrictAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof SubdistrictAvgAggregateInput>;
    @Field(() => SubdistrictSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof SubdistrictSumAggregateInput>;
    @Field(() => SubdistrictMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof SubdistrictMinAggregateInput>;
    @Field(() => SubdistrictMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof SubdistrictMaxAggregateInput>;
}

@ObjectType()
export class SubdistrictGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    districtId!: number;
    @Field(() => String, {nullable:false})
    postalCode!: string;
    @Field(() => SubdistrictCountAggregate, {nullable:true})
    _count?: InstanceType<typeof SubdistrictCountAggregate>;
    @Field(() => SubdistrictAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof SubdistrictAvgAggregate>;
    @Field(() => SubdistrictSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof SubdistrictSumAggregate>;
    @Field(() => SubdistrictMinAggregate, {nullable:true})
    _min?: InstanceType<typeof SubdistrictMinAggregate>;
    @Field(() => SubdistrictMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof SubdistrictMaxAggregate>;
}

@InputType()
export class SubdistrictListRelationFilter {
    @Field(() => SubdistrictWhereInput, {nullable:true})
    every?: InstanceType<typeof SubdistrictWhereInput>;
    @Field(() => SubdistrictWhereInput, {nullable:true})
    some?: InstanceType<typeof SubdistrictWhereInput>;
    @Field(() => SubdistrictWhereInput, {nullable:true})
    none?: InstanceType<typeof SubdistrictWhereInput>;
}

@InputType()
export class SubdistrictMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    districtId?: true;
    @Field(() => Boolean, {nullable:true})
    postalCode?: true;
}

@ObjectType()
export class SubdistrictMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Int, {nullable:true})
    districtId?: number;
    @Field(() => String, {nullable:true})
    postalCode?: string;
}

@InputType()
export class SubdistrictMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    districtId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    postalCode?: keyof typeof SortOrder;
}

@InputType()
export class SubdistrictMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    name?: true;
    @Field(() => Boolean, {nullable:true})
    districtId?: true;
    @Field(() => Boolean, {nullable:true})
    postalCode?: true;
}

@ObjectType()
export class SubdistrictMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    name?: string;
    @Field(() => Int, {nullable:true})
    districtId?: number;
    @Field(() => String, {nullable:true})
    postalCode?: string;
}

@InputType()
export class SubdistrictMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    districtId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    postalCode?: keyof typeof SortOrder;
}

@InputType()
export class SubdistrictOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class SubdistrictOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    districtId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    postalCode?: keyof typeof SortOrder;
    @Field(() => SubdistrictCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof SubdistrictCountOrderByAggregateInput>;
    @Field(() => SubdistrictAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof SubdistrictAvgOrderByAggregateInput>;
    @Field(() => SubdistrictMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof SubdistrictMaxOrderByAggregateInput>;
    @Field(() => SubdistrictMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof SubdistrictMinOrderByAggregateInput>;
    @Field(() => SubdistrictSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof SubdistrictSumOrderByAggregateInput>;
}

@InputType()
export class SubdistrictOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    name?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    districtId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    postalCode?: keyof typeof SortOrder;
    @Field(() => DistrictOrderByWithRelationInput, {nullable:true})
    district?: InstanceType<typeof DistrictOrderByWithRelationInput>;
    @Field(() => AddressOrderByRelationAggregateInput, {nullable:true})
    address?: InstanceType<typeof AddressOrderByRelationAggregateInput>;
}

@InputType()
export class SubdistrictRelationFilter {
    @Field(() => SubdistrictWhereInput, {nullable:true})
    is?: InstanceType<typeof SubdistrictWhereInput>;
    @Field(() => SubdistrictWhereInput, {nullable:true})
    isNot?: InstanceType<typeof SubdistrictWhereInput>;
}

@InputType()
export class SubdistrictScalarWhereWithAggregatesInput {
    @Field(() => [SubdistrictScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<SubdistrictScalarWhereWithAggregatesInput>;
    @Field(() => [SubdistrictScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<SubdistrictScalarWhereWithAggregatesInput>;
    @Field(() => [SubdistrictScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<SubdistrictScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    name?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    districtId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    postalCode?: InstanceType<typeof StringWithAggregatesFilter>;
}

@InputType()
export class SubdistrictScalarWhereInput {
    @Field(() => [SubdistrictScalarWhereInput], {nullable:true})
    AND?: Array<SubdistrictScalarWhereInput>;
    @Field(() => [SubdistrictScalarWhereInput], {nullable:true})
    OR?: Array<SubdistrictScalarWhereInput>;
    @Field(() => [SubdistrictScalarWhereInput], {nullable:true})
    NOT?: Array<SubdistrictScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    districtId?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    postalCode?: InstanceType<typeof StringFilter>;
}

@InputType()
export class SubdistrictSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    districtId?: true;
}

@ObjectType()
export class SubdistrictSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    districtId?: number;
}

@InputType()
export class SubdistrictSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    districtId?: keyof typeof SortOrder;
}

@InputType()
export class SubdistrictUncheckedCreateNestedManyWithoutDistrictInput {
    @Field(() => [SubdistrictCreateWithoutDistrictInput], {nullable:true})
    @Type(() => SubdistrictCreateWithoutDistrictInput)
    create?: Array<SubdistrictCreateWithoutDistrictInput>;
    @Field(() => [SubdistrictCreateOrConnectWithoutDistrictInput], {nullable:true})
    @Type(() => SubdistrictCreateOrConnectWithoutDistrictInput)
    connectOrCreate?: Array<SubdistrictCreateOrConnectWithoutDistrictInput>;
    @Field(() => SubdistrictCreateManyDistrictInputEnvelope, {nullable:true})
    @Type(() => SubdistrictCreateManyDistrictInputEnvelope)
    createMany?: InstanceType<typeof SubdistrictCreateManyDistrictInputEnvelope>;
    @Field(() => [SubdistrictWhereUniqueInput], {nullable:true})
    @Type(() => SubdistrictWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>>;
}

@InputType()
export class SubdistrictUncheckedCreateWithoutAddressInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    districtId!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(3)
    @Validator.IsPostalCode('ID')
    postalCode!: string;
}

@InputType()
export class SubdistrictUncheckedCreateWithoutDistrictInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(3)
    @Validator.IsPostalCode('ID')
    postalCode!: string;
    @Field(() => AddressUncheckedCreateNestedManyWithoutSubdistrictInput, {nullable:true})
    address?: InstanceType<typeof AddressUncheckedCreateNestedManyWithoutSubdistrictInput>;
}

@InputType()
export class SubdistrictUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    districtId!: number;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(3)
    @Validator.IsPostalCode('ID')
    postalCode!: string;
    @Field(() => AddressUncheckedCreateNestedManyWithoutSubdistrictInput, {nullable:true})
    address?: InstanceType<typeof AddressUncheckedCreateNestedManyWithoutSubdistrictInput>;
}

@InputType()
export class SubdistrictUncheckedUpdateManyWithoutDistrictNestedInput {
    @Field(() => [SubdistrictCreateWithoutDistrictInput], {nullable:true})
    @Type(() => SubdistrictCreateWithoutDistrictInput)
    create?: Array<SubdistrictCreateWithoutDistrictInput>;
    @Field(() => [SubdistrictCreateOrConnectWithoutDistrictInput], {nullable:true})
    @Type(() => SubdistrictCreateOrConnectWithoutDistrictInput)
    connectOrCreate?: Array<SubdistrictCreateOrConnectWithoutDistrictInput>;
    @Field(() => [SubdistrictUpsertWithWhereUniqueWithoutDistrictInput], {nullable:true})
    @Type(() => SubdistrictUpsertWithWhereUniqueWithoutDistrictInput)
    upsert?: Array<SubdistrictUpsertWithWhereUniqueWithoutDistrictInput>;
    @Field(() => SubdistrictCreateManyDistrictInputEnvelope, {nullable:true})
    @Type(() => SubdistrictCreateManyDistrictInputEnvelope)
    createMany?: InstanceType<typeof SubdistrictCreateManyDistrictInputEnvelope>;
    @Field(() => [SubdistrictWhereUniqueInput], {nullable:true})
    @Type(() => SubdistrictWhereUniqueInput)
    set?: Array<Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>>;
    @Field(() => [SubdistrictWhereUniqueInput], {nullable:true})
    @Type(() => SubdistrictWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>>;
    @Field(() => [SubdistrictWhereUniqueInput], {nullable:true})
    @Type(() => SubdistrictWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>>;
    @Field(() => [SubdistrictWhereUniqueInput], {nullable:true})
    @Type(() => SubdistrictWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>>;
    @Field(() => [SubdistrictUpdateWithWhereUniqueWithoutDistrictInput], {nullable:true})
    @Type(() => SubdistrictUpdateWithWhereUniqueWithoutDistrictInput)
    update?: Array<SubdistrictUpdateWithWhereUniqueWithoutDistrictInput>;
    @Field(() => [SubdistrictUpdateManyWithWhereWithoutDistrictInput], {nullable:true})
    @Type(() => SubdistrictUpdateManyWithWhereWithoutDistrictInput)
    updateMany?: Array<SubdistrictUpdateManyWithWhereWithoutDistrictInput>;
    @Field(() => [SubdistrictScalarWhereInput], {nullable:true})
    @Type(() => SubdistrictScalarWhereInput)
    deleteMany?: Array<SubdistrictScalarWhereInput>;
}

@InputType()
export class SubdistrictUncheckedUpdateManyWithoutDistrictInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    postalCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class SubdistrictUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    districtId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    postalCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class SubdistrictUncheckedUpdateWithoutAddressInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    districtId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    postalCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class SubdistrictUncheckedUpdateWithoutDistrictInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    postalCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => AddressUncheckedUpdateManyWithoutSubdistrictNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUncheckedUpdateManyWithoutSubdistrictNestedInput>;
}

@InputType()
export class SubdistrictUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    districtId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    postalCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => AddressUncheckedUpdateManyWithoutSubdistrictNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUncheckedUpdateManyWithoutSubdistrictNestedInput>;
}

@InputType()
export class SubdistrictUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    postalCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class SubdistrictUpdateManyWithWhereWithoutDistrictInput {
    @Field(() => SubdistrictScalarWhereInput, {nullable:false})
    @Type(() => SubdistrictScalarWhereInput)
    where!: InstanceType<typeof SubdistrictScalarWhereInput>;
    @Field(() => SubdistrictUpdateManyMutationInput, {nullable:false})
    @Type(() => SubdistrictUpdateManyMutationInput)
    data!: InstanceType<typeof SubdistrictUpdateManyMutationInput>;
}

@InputType()
export class SubdistrictUpdateManyWithoutDistrictNestedInput {
    @Field(() => [SubdistrictCreateWithoutDistrictInput], {nullable:true})
    @Type(() => SubdistrictCreateWithoutDistrictInput)
    create?: Array<SubdistrictCreateWithoutDistrictInput>;
    @Field(() => [SubdistrictCreateOrConnectWithoutDistrictInput], {nullable:true})
    @Type(() => SubdistrictCreateOrConnectWithoutDistrictInput)
    connectOrCreate?: Array<SubdistrictCreateOrConnectWithoutDistrictInput>;
    @Field(() => [SubdistrictUpsertWithWhereUniqueWithoutDistrictInput], {nullable:true})
    @Type(() => SubdistrictUpsertWithWhereUniqueWithoutDistrictInput)
    upsert?: Array<SubdistrictUpsertWithWhereUniqueWithoutDistrictInput>;
    @Field(() => SubdistrictCreateManyDistrictInputEnvelope, {nullable:true})
    @Type(() => SubdistrictCreateManyDistrictInputEnvelope)
    createMany?: InstanceType<typeof SubdistrictCreateManyDistrictInputEnvelope>;
    @Field(() => [SubdistrictWhereUniqueInput], {nullable:true})
    @Type(() => SubdistrictWhereUniqueInput)
    set?: Array<Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>>;
    @Field(() => [SubdistrictWhereUniqueInput], {nullable:true})
    @Type(() => SubdistrictWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>>;
    @Field(() => [SubdistrictWhereUniqueInput], {nullable:true})
    @Type(() => SubdistrictWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>>;
    @Field(() => [SubdistrictWhereUniqueInput], {nullable:true})
    @Type(() => SubdistrictWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>>;
    @Field(() => [SubdistrictUpdateWithWhereUniqueWithoutDistrictInput], {nullable:true})
    @Type(() => SubdistrictUpdateWithWhereUniqueWithoutDistrictInput)
    update?: Array<SubdistrictUpdateWithWhereUniqueWithoutDistrictInput>;
    @Field(() => [SubdistrictUpdateManyWithWhereWithoutDistrictInput], {nullable:true})
    @Type(() => SubdistrictUpdateManyWithWhereWithoutDistrictInput)
    updateMany?: Array<SubdistrictUpdateManyWithWhereWithoutDistrictInput>;
    @Field(() => [SubdistrictScalarWhereInput], {nullable:true})
    @Type(() => SubdistrictScalarWhereInput)
    deleteMany?: Array<SubdistrictScalarWhereInput>;
}

@InputType()
export class SubdistrictUpdateOneRequiredWithoutAddressNestedInput {
    @Field(() => SubdistrictCreateWithoutAddressInput, {nullable:true})
    @Type(() => SubdistrictCreateWithoutAddressInput)
    create?: InstanceType<typeof SubdistrictCreateWithoutAddressInput>;
    @Field(() => SubdistrictCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => SubdistrictCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof SubdistrictCreateOrConnectWithoutAddressInput>;
    @Field(() => SubdistrictUpsertWithoutAddressInput, {nullable:true})
    @Type(() => SubdistrictUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof SubdistrictUpsertWithoutAddressInput>;
    @Field(() => SubdistrictWhereUniqueInput, {nullable:true})
    @Type(() => SubdistrictWhereUniqueInput)
    connect?: Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>;
    @Field(() => SubdistrictUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => SubdistrictUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof SubdistrictUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class SubdistrictUpdateToOneWithWhereWithoutAddressInput {
    @Field(() => SubdistrictWhereInput, {nullable:true})
    @Type(() => SubdistrictWhereInput)
    where?: InstanceType<typeof SubdistrictWhereInput>;
    @Field(() => SubdistrictUpdateWithoutAddressInput, {nullable:false})
    @Type(() => SubdistrictUpdateWithoutAddressInput)
    data!: InstanceType<typeof SubdistrictUpdateWithoutAddressInput>;
}

@InputType()
export class SubdistrictUpdateWithWhereUniqueWithoutDistrictInput {
    @Field(() => SubdistrictWhereUniqueInput, {nullable:false})
    @Type(() => SubdistrictWhereUniqueInput)
    where!: Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>;
    @Field(() => SubdistrictUpdateWithoutDistrictInput, {nullable:false})
    @Type(() => SubdistrictUpdateWithoutDistrictInput)
    data!: InstanceType<typeof SubdistrictUpdateWithoutDistrictInput>;
}

@InputType()
export class SubdistrictUpdateWithoutAddressInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    postalCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DistrictUpdateOneRequiredWithoutSubdistrictsNestedInput, {nullable:true})
    district?: InstanceType<typeof DistrictUpdateOneRequiredWithoutSubdistrictsNestedInput>;
}

@InputType()
export class SubdistrictUpdateWithoutDistrictInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    postalCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateManyWithoutSubdistrictNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateManyWithoutSubdistrictNestedInput>;
}

@InputType()
export class SubdistrictUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    postalCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DistrictUpdateOneRequiredWithoutSubdistrictsNestedInput, {nullable:true})
    district?: InstanceType<typeof DistrictUpdateOneRequiredWithoutSubdistrictsNestedInput>;
    @Field(() => AddressUpdateManyWithoutSubdistrictNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateManyWithoutSubdistrictNestedInput>;
}

@InputType()
export class SubdistrictUpsertWithWhereUniqueWithoutDistrictInput {
    @Field(() => SubdistrictWhereUniqueInput, {nullable:false})
    @Type(() => SubdistrictWhereUniqueInput)
    where!: Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>;
    @Field(() => SubdistrictUpdateWithoutDistrictInput, {nullable:false})
    @Type(() => SubdistrictUpdateWithoutDistrictInput)
    update!: InstanceType<typeof SubdistrictUpdateWithoutDistrictInput>;
    @Field(() => SubdistrictCreateWithoutDistrictInput, {nullable:false})
    @Type(() => SubdistrictCreateWithoutDistrictInput)
    create!: InstanceType<typeof SubdistrictCreateWithoutDistrictInput>;
}

@InputType()
export class SubdistrictUpsertWithoutAddressInput {
    @Field(() => SubdistrictUpdateWithoutAddressInput, {nullable:false})
    @Type(() => SubdistrictUpdateWithoutAddressInput)
    update!: InstanceType<typeof SubdistrictUpdateWithoutAddressInput>;
    @Field(() => SubdistrictCreateWithoutAddressInput, {nullable:false})
    @Type(() => SubdistrictCreateWithoutAddressInput)
    create!: InstanceType<typeof SubdistrictCreateWithoutAddressInput>;
    @Field(() => SubdistrictWhereInput, {nullable:true})
    @Type(() => SubdistrictWhereInput)
    where?: InstanceType<typeof SubdistrictWhereInput>;
}

@InputType()
export class SubdistrictWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [SubdistrictWhereInput], {nullable:true})
    AND?: Array<SubdistrictWhereInput>;
    @Field(() => [SubdistrictWhereInput], {nullable:true})
    OR?: Array<SubdistrictWhereInput>;
    @Field(() => [SubdistrictWhereInput], {nullable:true})
    NOT?: Array<SubdistrictWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    districtId?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    postalCode?: InstanceType<typeof StringFilter>;
    @Field(() => DistrictRelationFilter, {nullable:true})
    district?: InstanceType<typeof DistrictRelationFilter>;
    @Field(() => AddressListRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressListRelationFilter>;
}

@InputType()
export class SubdistrictWhereInput {
    @Field(() => [SubdistrictWhereInput], {nullable:true})
    AND?: Array<SubdistrictWhereInput>;
    @Field(() => [SubdistrictWhereInput], {nullable:true})
    OR?: Array<SubdistrictWhereInput>;
    @Field(() => [SubdistrictWhereInput], {nullable:true})
    NOT?: Array<SubdistrictWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    name?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    districtId?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    postalCode?: InstanceType<typeof StringFilter>;
    @Field(() => DistrictRelationFilter, {nullable:true})
    district?: InstanceType<typeof DistrictRelationFilter>;
    @Field(() => AddressListRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressListRelationFilter>;
}

@ObjectType()
export class Subdistrict {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    name!: string;
    @Field(() => Int, {nullable:false})
    districtId!: number;
    @Field(() => String, {nullable:false})
    postalCode!: string;
    @Field(() => District, {nullable:false})
    district?: InstanceType<typeof District>;
    @HideField()
    address?: Array<Address>;
    @Field(() => SubdistrictCount, {nullable:false})
    _count?: InstanceType<typeof SubdistrictCount>;
}

@ArgsType()
export class UpdateManySubdistrictArgs {
    @Field(() => SubdistrictUpdateManyMutationInput, {nullable:false})
    @Type(() => SubdistrictUpdateManyMutationInput)
    data!: InstanceType<typeof SubdistrictUpdateManyMutationInput>;
    @Field(() => SubdistrictWhereInput, {nullable:true})
    @Type(() => SubdistrictWhereInput)
    where?: InstanceType<typeof SubdistrictWhereInput>;
}

@ArgsType()
export class UpdateOneSubdistrictArgs {
    @Field(() => SubdistrictUpdateInput, {nullable:false})
    @Type(() => SubdistrictUpdateInput)
    data!: InstanceType<typeof SubdistrictUpdateInput>;
    @Field(() => SubdistrictWhereUniqueInput, {nullable:false})
    @Type(() => SubdistrictWhereUniqueInput)
    where!: Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneSubdistrictArgs {
    @Field(() => SubdistrictWhereUniqueInput, {nullable:false})
    @Type(() => SubdistrictWhereUniqueInput)
    where!: Prisma.AtLeast<SubdistrictWhereUniqueInput, 'id'>;
    @Field(() => SubdistrictCreateInput, {nullable:false})
    @Type(() => SubdistrictCreateInput)
    create!: InstanceType<typeof SubdistrictCreateInput>;
    @Field(() => SubdistrictUpdateInput, {nullable:false})
    @Type(() => SubdistrictUpdateInput)
    update!: InstanceType<typeof SubdistrictUpdateInput>;
}

@ObjectType()
export class AggregateTransaction {
    @Field(() => TransactionCountAggregate, {nullable:true})
    _count?: InstanceType<typeof TransactionCountAggregate>;
    @Field(() => TransactionAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof TransactionAvgAggregate>;
    @Field(() => TransactionSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof TransactionSumAggregate>;
    @Field(() => TransactionMinAggregate, {nullable:true})
    _min?: InstanceType<typeof TransactionMinAggregate>;
    @Field(() => TransactionMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof TransactionMaxAggregate>;
}

@ArgsType()
export class CreateManyTransactionArgs {
    @Field(() => [TransactionCreateManyInput], {nullable:false})
    @Type(() => TransactionCreateManyInput)
    data!: Array<TransactionCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneTransactionArgs {
    @Field(() => TransactionCreateInput, {nullable:false})
    @Type(() => TransactionCreateInput)
    data!: InstanceType<typeof TransactionCreateInput>;
}

@ArgsType()
export class DeleteManyTransactionArgs {
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
}

@ArgsType()
export class DeleteOneTransactionArgs {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
}

@ArgsType()
export class FindFirstTransactionOrThrowArgs {
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => [TransactionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<TransactionOrderByWithRelationInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [TransactionScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof TransactionScalarFieldEnum>;
}

@ArgsType()
export class FindFirstTransactionArgs {
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => [TransactionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<TransactionOrderByWithRelationInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [TransactionScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof TransactionScalarFieldEnum>;
}

@ArgsType()
export class FindManyTransactionArgs {
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => [TransactionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<TransactionOrderByWithRelationInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [TransactionScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof TransactionScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueTransactionOrThrowArgs {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
}

@ArgsType()
export class FindUniqueTransactionArgs {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
}

@ArgsType()
export class TransactionAggregateArgs {
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => [TransactionOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<TransactionOrderByWithRelationInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => TransactionCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof TransactionCountAggregateInput>;
    @Field(() => TransactionAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof TransactionAvgAggregateInput>;
    @Field(() => TransactionSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof TransactionSumAggregateInput>;
    @Field(() => TransactionMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof TransactionMinAggregateInput>;
    @Field(() => TransactionMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof TransactionMaxAggregateInput>;
}

@InputType()
export class TransactionAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    fromAccountId?: true;
    @Field(() => Boolean, {nullable:true})
    toAccountId?: true;
    @Field(() => Boolean, {nullable:true})
    invoiceId?: true;
    @Field(() => Boolean, {nullable:true})
    installmentId?: true;
    @Field(() => Boolean, {nullable:true})
    withdrawalRequestId?: true;
    @Field(() => Boolean, {nullable:true})
    uniqueCode?: true;
}

@ObjectType()
export class TransactionAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => Float, {nullable:true})
    fromAccountId?: number;
    @Field(() => Float, {nullable:true})
    toAccountId?: number;
    @Field(() => Float, {nullable:true})
    invoiceId?: number;
    @Field(() => Float, {nullable:true})
    installmentId?: number;
    @Field(() => Float, {nullable:true})
    withdrawalRequestId?: number;
    @Field(() => Float, {nullable:true})
    uniqueCode?: number;
}

@InputType()
export class TransactionAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fromAccountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    toAccountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    invoiceId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    installmentId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    withdrawalRequestId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    uniqueCode?: keyof typeof SortOrder;
}

@InputType()
export class TransactionCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    proofUrl?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    transactionCategory?: true;
    @Field(() => Boolean, {nullable:true})
    fromAccountId?: true;
    @Field(() => Boolean, {nullable:true})
    toAccountId?: true;
    @Field(() => Boolean, {nullable:true})
    invoiceId?: true;
    @Field(() => Boolean, {nullable:true})
    installmentId?: true;
    @Field(() => Boolean, {nullable:true})
    withdrawalRequestId?: true;
    @Field(() => Boolean, {nullable:true})
    uniqueCode?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class TransactionCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    amount!: number;
    @Field(() => Int, {nullable:false})
    proofUrl!: number;
    @Field(() => Int, {nullable:false})
    status!: number;
    @Field(() => Int, {nullable:false})
    transactionCategory!: number;
    @Field(() => Int, {nullable:false})
    fromAccountId!: number;
    @Field(() => Int, {nullable:false})
    toAccountId!: number;
    @Field(() => Int, {nullable:false})
    invoiceId!: number;
    @Field(() => Int, {nullable:false})
    installmentId!: number;
    @Field(() => Int, {nullable:false})
    withdrawalRequestId!: number;
    @Field(() => Int, {nullable:false})
    uniqueCode!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class TransactionCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    proofUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fromAccountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    toAccountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    invoiceId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    installmentId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    withdrawalRequestId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    uniqueCode?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class TransactionCreateManyFromAccountInputEnvelope {
    @Field(() => [TransactionCreateManyFromAccountInput], {nullable:false})
    @Type(() => TransactionCreateManyFromAccountInput)
    data!: Array<TransactionCreateManyFromAccountInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class TransactionCreateManyFromAccountInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @HideField()
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @HideField()
    toAccountId!: number;
    @Field(() => Int, {nullable:true})
    invoiceId?: number;
    @Field(() => Int, {nullable:true})
    installmentId?: number;
    @Field(() => Int, {nullable:true})
    withdrawalRequestId?: number;
    @HideField()
    uniqueCode!: number;
    @HideField()
    createdAt?: Date | string;
}

@InputType()
export class TransactionCreateManyInvoiceInputEnvelope {
    @Field(() => [TransactionCreateManyInvoiceInput], {nullable:false})
    @Type(() => TransactionCreateManyInvoiceInput)
    data!: Array<TransactionCreateManyInvoiceInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class TransactionCreateManyInvoiceInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @HideField()
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @HideField()
    fromAccountId!: number;
    @HideField()
    toAccountId!: number;
    @Field(() => Int, {nullable:true})
    installmentId?: number;
    @Field(() => Int, {nullable:true})
    withdrawalRequestId?: number;
    @HideField()
    uniqueCode!: number;
    @HideField()
    createdAt?: Date | string;
}

@InputType()
export class TransactionCreateManyToAccountInputEnvelope {
    @Field(() => [TransactionCreateManyToAccountInput], {nullable:false})
    @Type(() => TransactionCreateManyToAccountInput)
    data!: Array<TransactionCreateManyToAccountInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class TransactionCreateManyToAccountInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @HideField()
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @HideField()
    fromAccountId!: number;
    @Field(() => Int, {nullable:true})
    invoiceId?: number;
    @Field(() => Int, {nullable:true})
    installmentId?: number;
    @Field(() => Int, {nullable:true})
    withdrawalRequestId?: number;
    @HideField()
    uniqueCode!: number;
    @HideField()
    createdAt?: Date | string;
}

@InputType()
export class TransactionCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @HideField()
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @HideField()
    fromAccountId!: number;
    @HideField()
    toAccountId!: number;
    @Field(() => Int, {nullable:true})
    invoiceId?: number;
    @Field(() => Int, {nullable:true})
    installmentId?: number;
    @Field(() => Int, {nullable:true})
    withdrawalRequestId?: number;
    @HideField()
    uniqueCode!: number;
    @HideField()
    createdAt?: Date | string;
}

@InputType()
export class TransactionCreateNestedManyWithoutFromAccountInput {
    @Field(() => [TransactionCreateWithoutFromAccountInput], {nullable:true})
    @Type(() => TransactionCreateWithoutFromAccountInput)
    create?: Array<TransactionCreateWithoutFromAccountInput>;
    @Field(() => [TransactionCreateOrConnectWithoutFromAccountInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutFromAccountInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutFromAccountInput>;
    @Field(() => TransactionCreateManyFromAccountInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyFromAccountInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyFromAccountInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
}

@InputType()
export class TransactionCreateNestedManyWithoutInvoiceInput {
    @Field(() => [TransactionCreateWithoutInvoiceInput], {nullable:true})
    @Type(() => TransactionCreateWithoutInvoiceInput)
    create?: Array<TransactionCreateWithoutInvoiceInput>;
    @Field(() => [TransactionCreateOrConnectWithoutInvoiceInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutInvoiceInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutInvoiceInput>;
    @Field(() => TransactionCreateManyInvoiceInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyInvoiceInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyInvoiceInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
}

@InputType()
export class TransactionCreateNestedManyWithoutToAccountInput {
    @Field(() => [TransactionCreateWithoutToAccountInput], {nullable:true})
    @Type(() => TransactionCreateWithoutToAccountInput)
    create?: Array<TransactionCreateWithoutToAccountInput>;
    @Field(() => [TransactionCreateOrConnectWithoutToAccountInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutToAccountInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutToAccountInput>;
    @Field(() => TransactionCreateManyToAccountInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyToAccountInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyToAccountInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
}

@InputType()
export class TransactionCreateNestedOneWithoutInstallmentInput {
    @Field(() => TransactionCreateWithoutInstallmentInput, {nullable:true})
    @Type(() => TransactionCreateWithoutInstallmentInput)
    create?: InstanceType<typeof TransactionCreateWithoutInstallmentInput>;
    @Field(() => TransactionCreateOrConnectWithoutInstallmentInput, {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutInstallmentInput)
    connectOrCreate?: InstanceType<typeof TransactionCreateOrConnectWithoutInstallmentInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
}

@InputType()
export class TransactionCreateNestedOneWithoutWithdrawalRequestInput {
    @Field(() => TransactionCreateWithoutWithdrawalRequestInput, {nullable:true})
    @Type(() => TransactionCreateWithoutWithdrawalRequestInput)
    create?: InstanceType<typeof TransactionCreateWithoutWithdrawalRequestInput>;
    @Field(() => TransactionCreateOrConnectWithoutWithdrawalRequestInput, {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutWithdrawalRequestInput)
    connectOrCreate?: InstanceType<typeof TransactionCreateOrConnectWithoutWithdrawalRequestInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
}

@InputType()
export class TransactionCreateOrConnectWithoutFromAccountInput {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => TransactionCreateWithoutFromAccountInput, {nullable:false})
    @Type(() => TransactionCreateWithoutFromAccountInput)
    create!: InstanceType<typeof TransactionCreateWithoutFromAccountInput>;
}

@InputType()
export class TransactionCreateOrConnectWithoutInstallmentInput {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => TransactionCreateWithoutInstallmentInput, {nullable:false})
    @Type(() => TransactionCreateWithoutInstallmentInput)
    create!: InstanceType<typeof TransactionCreateWithoutInstallmentInput>;
}

@InputType()
export class TransactionCreateOrConnectWithoutInvoiceInput {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => TransactionCreateWithoutInvoiceInput, {nullable:false})
    @Type(() => TransactionCreateWithoutInvoiceInput)
    create!: InstanceType<typeof TransactionCreateWithoutInvoiceInput>;
}

@InputType()
export class TransactionCreateOrConnectWithoutToAccountInput {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => TransactionCreateWithoutToAccountInput, {nullable:false})
    @Type(() => TransactionCreateWithoutToAccountInput)
    create!: InstanceType<typeof TransactionCreateWithoutToAccountInput>;
}

@InputType()
export class TransactionCreateOrConnectWithoutWithdrawalRequestInput {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => TransactionCreateWithoutWithdrawalRequestInput, {nullable:false})
    @Type(() => TransactionCreateWithoutWithdrawalRequestInput)
    create!: InstanceType<typeof TransactionCreateWithoutWithdrawalRequestInput>;
}

@InputType()
export class TransactionCreateWithoutFromAccountInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @HideField()
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @HideField()
    uniqueCode!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    toAccount!: InstanceType<typeof AccountCreateNestedOneWithoutTransactionDestinationInput>;
    @Field(() => InvoiceCreateNestedOneWithoutTransactionsInput, {nullable:true})
    invoice?: InstanceType<typeof InvoiceCreateNestedOneWithoutTransactionsInput>;
    @HideField()
    Installment?: InstanceType<typeof InstallmentCreateNestedOneWithoutTransactionInput>;
    @Field(() => WithdrawalRequestCreateNestedOneWithoutTransactionInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedOneWithoutTransactionInput>;
}

@InputType()
export class TransactionCreateWithoutInstallmentInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @HideField()
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @HideField()
    uniqueCode!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    fromAccount!: InstanceType<typeof AccountCreateNestedOneWithoutTransactionOriginsInput>;
    @HideField()
    toAccount!: InstanceType<typeof AccountCreateNestedOneWithoutTransactionDestinationInput>;
    @Field(() => InvoiceCreateNestedOneWithoutTransactionsInput, {nullable:true})
    invoice?: InstanceType<typeof InvoiceCreateNestedOneWithoutTransactionsInput>;
    @Field(() => WithdrawalRequestCreateNestedOneWithoutTransactionInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedOneWithoutTransactionInput>;
}

@InputType()
export class TransactionCreateWithoutInvoiceInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @HideField()
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @HideField()
    uniqueCode!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    fromAccount!: InstanceType<typeof AccountCreateNestedOneWithoutTransactionOriginsInput>;
    @HideField()
    toAccount!: InstanceType<typeof AccountCreateNestedOneWithoutTransactionDestinationInput>;
    @HideField()
    Installment?: InstanceType<typeof InstallmentCreateNestedOneWithoutTransactionInput>;
    @Field(() => WithdrawalRequestCreateNestedOneWithoutTransactionInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedOneWithoutTransactionInput>;
}

@InputType()
export class TransactionCreateWithoutToAccountInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @HideField()
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @HideField()
    uniqueCode!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    fromAccount!: InstanceType<typeof AccountCreateNestedOneWithoutTransactionOriginsInput>;
    @Field(() => InvoiceCreateNestedOneWithoutTransactionsInput, {nullable:true})
    invoice?: InstanceType<typeof InvoiceCreateNestedOneWithoutTransactionsInput>;
    @HideField()
    Installment?: InstanceType<typeof InstallmentCreateNestedOneWithoutTransactionInput>;
    @Field(() => WithdrawalRequestCreateNestedOneWithoutTransactionInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedOneWithoutTransactionInput>;
}

@InputType()
export class TransactionCreateWithoutWithdrawalRequestInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @HideField()
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @HideField()
    uniqueCode!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    fromAccount!: InstanceType<typeof AccountCreateNestedOneWithoutTransactionOriginsInput>;
    @HideField()
    toAccount!: InstanceType<typeof AccountCreateNestedOneWithoutTransactionDestinationInput>;
    @Field(() => InvoiceCreateNestedOneWithoutTransactionsInput, {nullable:true})
    invoice?: InstanceType<typeof InvoiceCreateNestedOneWithoutTransactionsInput>;
    @HideField()
    Installment?: InstanceType<typeof InstallmentCreateNestedOneWithoutTransactionInput>;
}

@InputType()
export class TransactionCreateInput {
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @HideField()
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @HideField()
    uniqueCode!: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    fromAccount!: InstanceType<typeof AccountCreateNestedOneWithoutTransactionOriginsInput>;
    @HideField()
    toAccount!: InstanceType<typeof AccountCreateNestedOneWithoutTransactionDestinationInput>;
    @Field(() => InvoiceCreateNestedOneWithoutTransactionsInput, {nullable:true})
    invoice?: InstanceType<typeof InvoiceCreateNestedOneWithoutTransactionsInput>;
    @HideField()
    Installment?: InstanceType<typeof InstallmentCreateNestedOneWithoutTransactionInput>;
    @Field(() => WithdrawalRequestCreateNestedOneWithoutTransactionInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedOneWithoutTransactionInput>;
}

@ArgsType()
export class TransactionGroupByArgs {
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => [TransactionOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<TransactionOrderByWithAggregationInput>;
    @Field(() => [TransactionScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof TransactionScalarFieldEnum>;
    @Field(() => TransactionScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof TransactionScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => TransactionCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof TransactionCountAggregateInput>;
    @Field(() => TransactionAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof TransactionAvgAggregateInput>;
    @Field(() => TransactionSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof TransactionSumAggregateInput>;
    @Field(() => TransactionMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof TransactionMinAggregateInput>;
    @Field(() => TransactionMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof TransactionMaxAggregateInput>;
}

@ObjectType()
export class TransactionGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Int, {nullable:false})
    fromAccountId!: number;
    @Field(() => Int, {nullable:false})
    toAccountId!: number;
    @Field(() => Int, {nullable:true})
    invoiceId?: number;
    @Field(() => Int, {nullable:true})
    installmentId?: number;
    @Field(() => Int, {nullable:true})
    withdrawalRequestId?: number;
    @Field(() => Int, {nullable:false})
    uniqueCode!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => TransactionCountAggregate, {nullable:true})
    _count?: InstanceType<typeof TransactionCountAggregate>;
    @Field(() => TransactionAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof TransactionAvgAggregate>;
    @Field(() => TransactionSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof TransactionSumAggregate>;
    @Field(() => TransactionMinAggregate, {nullable:true})
    _min?: InstanceType<typeof TransactionMinAggregate>;
    @Field(() => TransactionMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof TransactionMaxAggregate>;
}

@InputType()
export class TransactionListRelationFilter {
    @Field(() => TransactionWhereInput, {nullable:true})
    every?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => TransactionWhereInput, {nullable:true})
    some?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => TransactionWhereInput, {nullable:true})
    none?: InstanceType<typeof TransactionWhereInput>;
}

@InputType()
export class TransactionMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    proofUrl?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    transactionCategory?: true;
    @Field(() => Boolean, {nullable:true})
    fromAccountId?: true;
    @Field(() => Boolean, {nullable:true})
    toAccountId?: true;
    @Field(() => Boolean, {nullable:true})
    invoiceId?: true;
    @Field(() => Boolean, {nullable:true})
    installmentId?: true;
    @Field(() => Boolean, {nullable:true})
    withdrawalRequestId?: true;
    @Field(() => Boolean, {nullable:true})
    uniqueCode?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
}

@ObjectType()
export class TransactionMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @Field(() => TransactionStatus, {nullable:true})
    status?: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:true})
    transactionCategory?: keyof typeof TransactionCategory;
    @Field(() => Int, {nullable:true})
    fromAccountId?: number;
    @Field(() => Int, {nullable:true})
    toAccountId?: number;
    @Field(() => Int, {nullable:true})
    invoiceId?: number;
    @Field(() => Int, {nullable:true})
    installmentId?: number;
    @Field(() => Int, {nullable:true})
    withdrawalRequestId?: number;
    @Field(() => Int, {nullable:true})
    uniqueCode?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class TransactionMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    proofUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fromAccountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    toAccountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    invoiceId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    installmentId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    withdrawalRequestId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    uniqueCode?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class TransactionMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    proofUrl?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    transactionCategory?: true;
    @Field(() => Boolean, {nullable:true})
    fromAccountId?: true;
    @Field(() => Boolean, {nullable:true})
    toAccountId?: true;
    @Field(() => Boolean, {nullable:true})
    invoiceId?: true;
    @Field(() => Boolean, {nullable:true})
    installmentId?: true;
    @Field(() => Boolean, {nullable:true})
    withdrawalRequestId?: true;
    @Field(() => Boolean, {nullable:true})
    uniqueCode?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
}

@ObjectType()
export class TransactionMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @Field(() => TransactionStatus, {nullable:true})
    status?: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:true})
    transactionCategory?: keyof typeof TransactionCategory;
    @Field(() => Int, {nullable:true})
    fromAccountId?: number;
    @Field(() => Int, {nullable:true})
    toAccountId?: number;
    @Field(() => Int, {nullable:true})
    invoiceId?: number;
    @Field(() => Int, {nullable:true})
    installmentId?: number;
    @Field(() => Int, {nullable:true})
    withdrawalRequestId?: number;
    @Field(() => Int, {nullable:true})
    uniqueCode?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class TransactionMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    proofUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fromAccountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    toAccountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    invoiceId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    installmentId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    withdrawalRequestId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    uniqueCode?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
}

@InputType()
export class TransactionNullableRelationFilter {
    @Field(() => TransactionWhereInput, {nullable:true})
    is?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => TransactionWhereInput, {nullable:true})
    isNot?: InstanceType<typeof TransactionWhereInput>;
}

@InputType()
export class TransactionOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class TransactionOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    proofUrl?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fromAccountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    toAccountId?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    invoiceId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    installmentId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    withdrawalRequestId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    uniqueCode?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => TransactionCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof TransactionCountOrderByAggregateInput>;
    @Field(() => TransactionAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof TransactionAvgOrderByAggregateInput>;
    @Field(() => TransactionMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof TransactionMaxOrderByAggregateInput>;
    @Field(() => TransactionMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof TransactionMinOrderByAggregateInput>;
    @Field(() => TransactionSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof TransactionSumOrderByAggregateInput>;
}

@InputType()
export class TransactionOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    proofUrl?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionCategory?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fromAccountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    toAccountId?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    invoiceId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    installmentId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    withdrawalRequestId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    uniqueCode?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => AccountOrderByWithRelationInput, {nullable:true})
    fromAccount?: InstanceType<typeof AccountOrderByWithRelationInput>;
    @Field(() => AccountOrderByWithRelationInput, {nullable:true})
    toAccount?: InstanceType<typeof AccountOrderByWithRelationInput>;
    @Field(() => InvoiceOrderByWithRelationInput, {nullable:true})
    invoice?: InstanceType<typeof InvoiceOrderByWithRelationInput>;
    @HideField()
    Installment?: InstanceType<typeof InstallmentOrderByWithRelationInput>;
    @Field(() => WithdrawalRequestOrderByWithRelationInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestOrderByWithRelationInput>;
}

@InputType()
export class TransactionScalarWhereWithAggregatesInput {
    @Field(() => [TransactionScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<TransactionScalarWhereWithAggregatesInput>;
    @Field(() => [TransactionScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<TransactionScalarWhereWithAggregatesInput>;
    @Field(() => [TransactionScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<TransactionScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    amount?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => StringNullableWithAggregatesFilter, {nullable:true})
    proofUrl?: InstanceType<typeof StringNullableWithAggregatesFilter>;
    @Field(() => EnumTransactionStatusWithAggregatesFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusWithAggregatesFilter>;
    @Field(() => EnumTransactionCategoryWithAggregatesFilter, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    fromAccountId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    toAccountId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => IntNullableWithAggregatesFilter, {nullable:true})
    invoiceId?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => IntNullableWithAggregatesFilter, {nullable:true})
    installmentId?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => IntNullableWithAggregatesFilter, {nullable:true})
    withdrawalRequestId?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    uniqueCode?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class TransactionScalarWhereInput {
    @Field(() => [TransactionScalarWhereInput], {nullable:true})
    AND?: Array<TransactionScalarWhereInput>;
    @Field(() => [TransactionScalarWhereInput], {nullable:true})
    OR?: Array<TransactionScalarWhereInput>;
    @Field(() => [TransactionScalarWhereInput], {nullable:true})
    NOT?: Array<TransactionScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    proofUrl?: InstanceType<typeof StringNullableFilter>;
    @Field(() => EnumTransactionStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFilter>;
    @Field(() => EnumTransactionCategoryFilter, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFilter>;
    @Field(() => IntFilter, {nullable:true})
    fromAccountId?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    toAccountId?: InstanceType<typeof IntFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    invoiceId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    installmentId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    withdrawalRequestId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntFilter, {nullable:true})
    uniqueCode?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class TransactionSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    fromAccountId?: true;
    @Field(() => Boolean, {nullable:true})
    toAccountId?: true;
    @Field(() => Boolean, {nullable:true})
    invoiceId?: true;
    @Field(() => Boolean, {nullable:true})
    installmentId?: true;
    @Field(() => Boolean, {nullable:true})
    withdrawalRequestId?: true;
    @Field(() => Boolean, {nullable:true})
    uniqueCode?: true;
}

@ObjectType()
export class TransactionSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => Int, {nullable:true})
    fromAccountId?: number;
    @Field(() => Int, {nullable:true})
    toAccountId?: number;
    @Field(() => Int, {nullable:true})
    invoiceId?: number;
    @Field(() => Int, {nullable:true})
    installmentId?: number;
    @Field(() => Int, {nullable:true})
    withdrawalRequestId?: number;
    @Field(() => Int, {nullable:true})
    uniqueCode?: number;
}

@InputType()
export class TransactionSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fromAccountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    toAccountId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    invoiceId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    installmentId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    withdrawalRequestId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    uniqueCode?: keyof typeof SortOrder;
}

@InputType()
export class TransactionUncheckedCreateNestedManyWithoutFromAccountInput {
    @Field(() => [TransactionCreateWithoutFromAccountInput], {nullable:true})
    @Type(() => TransactionCreateWithoutFromAccountInput)
    create?: Array<TransactionCreateWithoutFromAccountInput>;
    @Field(() => [TransactionCreateOrConnectWithoutFromAccountInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutFromAccountInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutFromAccountInput>;
    @Field(() => TransactionCreateManyFromAccountInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyFromAccountInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyFromAccountInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
}

@InputType()
export class TransactionUncheckedCreateNestedManyWithoutInvoiceInput {
    @Field(() => [TransactionCreateWithoutInvoiceInput], {nullable:true})
    @Type(() => TransactionCreateWithoutInvoiceInput)
    create?: Array<TransactionCreateWithoutInvoiceInput>;
    @Field(() => [TransactionCreateOrConnectWithoutInvoiceInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutInvoiceInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutInvoiceInput>;
    @Field(() => TransactionCreateManyInvoiceInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyInvoiceInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyInvoiceInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
}

@InputType()
export class TransactionUncheckedCreateNestedManyWithoutToAccountInput {
    @Field(() => [TransactionCreateWithoutToAccountInput], {nullable:true})
    @Type(() => TransactionCreateWithoutToAccountInput)
    create?: Array<TransactionCreateWithoutToAccountInput>;
    @Field(() => [TransactionCreateOrConnectWithoutToAccountInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutToAccountInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutToAccountInput>;
    @Field(() => TransactionCreateManyToAccountInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyToAccountInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyToAccountInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
}

@InputType()
export class TransactionUncheckedCreateNestedOneWithoutInstallmentInput {
    @Field(() => TransactionCreateWithoutInstallmentInput, {nullable:true})
    @Type(() => TransactionCreateWithoutInstallmentInput)
    create?: InstanceType<typeof TransactionCreateWithoutInstallmentInput>;
    @Field(() => TransactionCreateOrConnectWithoutInstallmentInput, {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutInstallmentInput)
    connectOrCreate?: InstanceType<typeof TransactionCreateOrConnectWithoutInstallmentInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
}

@InputType()
export class TransactionUncheckedCreateNestedOneWithoutWithdrawalRequestInput {
    @Field(() => TransactionCreateWithoutWithdrawalRequestInput, {nullable:true})
    @Type(() => TransactionCreateWithoutWithdrawalRequestInput)
    create?: InstanceType<typeof TransactionCreateWithoutWithdrawalRequestInput>;
    @Field(() => TransactionCreateOrConnectWithoutWithdrawalRequestInput, {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutWithdrawalRequestInput)
    connectOrCreate?: InstanceType<typeof TransactionCreateOrConnectWithoutWithdrawalRequestInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
}

@InputType()
export class TransactionUncheckedCreateWithoutFromAccountInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Int, {nullable:false})
    toAccountId!: number;
    @Field(() => Int, {nullable:true})
    invoiceId?: number;
    @Field(() => Int, {nullable:true})
    installmentId?: number;
    @Field(() => Int, {nullable:true})
    withdrawalRequestId?: number;
    @Field(() => Int, {nullable:false})
    uniqueCode!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class TransactionUncheckedCreateWithoutInstallmentInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Int, {nullable:false})
    fromAccountId!: number;
    @Field(() => Int, {nullable:false})
    toAccountId!: number;
    @Field(() => Int, {nullable:true})
    invoiceId?: number;
    @Field(() => Int, {nullable:true})
    withdrawalRequestId?: number;
    @Field(() => Int, {nullable:false})
    uniqueCode!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class TransactionUncheckedCreateWithoutInvoiceInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Int, {nullable:false})
    fromAccountId!: number;
    @Field(() => Int, {nullable:false})
    toAccountId!: number;
    @Field(() => Int, {nullable:true})
    installmentId?: number;
    @Field(() => Int, {nullable:true})
    withdrawalRequestId?: number;
    @Field(() => Int, {nullable:false})
    uniqueCode!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class TransactionUncheckedCreateWithoutToAccountInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Int, {nullable:false})
    fromAccountId!: number;
    @Field(() => Int, {nullable:true})
    invoiceId?: number;
    @Field(() => Int, {nullable:true})
    installmentId?: number;
    @Field(() => Int, {nullable:true})
    withdrawalRequestId?: number;
    @Field(() => Int, {nullable:false})
    uniqueCode!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class TransactionUncheckedCreateWithoutWithdrawalRequestInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Int, {nullable:false})
    fromAccountId!: number;
    @Field(() => Int, {nullable:false})
    toAccountId!: number;
    @Field(() => Int, {nullable:true})
    invoiceId?: number;
    @Field(() => Int, {nullable:true})
    installmentId?: number;
    @Field(() => Int, {nullable:false})
    uniqueCode!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class TransactionUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    @Validator.IsNumber()
    @Validator.IsNotEmpty()
    amount!: number;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Int, {nullable:false})
    fromAccountId!: number;
    @Field(() => Int, {nullable:false})
    toAccountId!: number;
    @Field(() => Int, {nullable:true})
    invoiceId?: number;
    @Field(() => Int, {nullable:true})
    installmentId?: number;
    @Field(() => Int, {nullable:true})
    withdrawalRequestId?: number;
    @Field(() => Int, {nullable:false})
    uniqueCode!: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
}

@InputType()
export class TransactionUncheckedUpdateManyWithoutFromAccountNestedInput {
    @Field(() => [TransactionCreateWithoutFromAccountInput], {nullable:true})
    @Type(() => TransactionCreateWithoutFromAccountInput)
    create?: Array<TransactionCreateWithoutFromAccountInput>;
    @Field(() => [TransactionCreateOrConnectWithoutFromAccountInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutFromAccountInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutFromAccountInput>;
    @Field(() => [TransactionUpsertWithWhereUniqueWithoutFromAccountInput], {nullable:true})
    @Type(() => TransactionUpsertWithWhereUniqueWithoutFromAccountInput)
    upsert?: Array<TransactionUpsertWithWhereUniqueWithoutFromAccountInput>;
    @Field(() => TransactionCreateManyFromAccountInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyFromAccountInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyFromAccountInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    set?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionUpdateWithWhereUniqueWithoutFromAccountInput], {nullable:true})
    @Type(() => TransactionUpdateWithWhereUniqueWithoutFromAccountInput)
    update?: Array<TransactionUpdateWithWhereUniqueWithoutFromAccountInput>;
    @Field(() => [TransactionUpdateManyWithWhereWithoutFromAccountInput], {nullable:true})
    @Type(() => TransactionUpdateManyWithWhereWithoutFromAccountInput)
    updateMany?: Array<TransactionUpdateManyWithWhereWithoutFromAccountInput>;
    @Field(() => [TransactionScalarWhereInput], {nullable:true})
    @Type(() => TransactionScalarWhereInput)
    deleteMany?: Array<TransactionScalarWhereInput>;
}

@InputType()
export class TransactionUncheckedUpdateManyWithoutFromAccountInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    toAccountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    invoiceId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    installmentId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    withdrawalRequestId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class TransactionUncheckedUpdateManyWithoutInvoiceNestedInput {
    @Field(() => [TransactionCreateWithoutInvoiceInput], {nullable:true})
    @Type(() => TransactionCreateWithoutInvoiceInput)
    create?: Array<TransactionCreateWithoutInvoiceInput>;
    @Field(() => [TransactionCreateOrConnectWithoutInvoiceInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutInvoiceInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutInvoiceInput>;
    @Field(() => [TransactionUpsertWithWhereUniqueWithoutInvoiceInput], {nullable:true})
    @Type(() => TransactionUpsertWithWhereUniqueWithoutInvoiceInput)
    upsert?: Array<TransactionUpsertWithWhereUniqueWithoutInvoiceInput>;
    @Field(() => TransactionCreateManyInvoiceInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyInvoiceInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyInvoiceInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    set?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionUpdateWithWhereUniqueWithoutInvoiceInput], {nullable:true})
    @Type(() => TransactionUpdateWithWhereUniqueWithoutInvoiceInput)
    update?: Array<TransactionUpdateWithWhereUniqueWithoutInvoiceInput>;
    @Field(() => [TransactionUpdateManyWithWhereWithoutInvoiceInput], {nullable:true})
    @Type(() => TransactionUpdateManyWithWhereWithoutInvoiceInput)
    updateMany?: Array<TransactionUpdateManyWithWhereWithoutInvoiceInput>;
    @Field(() => [TransactionScalarWhereInput], {nullable:true})
    @Type(() => TransactionScalarWhereInput)
    deleteMany?: Array<TransactionScalarWhereInput>;
}

@InputType()
export class TransactionUncheckedUpdateManyWithoutInvoiceInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    fromAccountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    toAccountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    installmentId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    withdrawalRequestId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class TransactionUncheckedUpdateManyWithoutToAccountNestedInput {
    @Field(() => [TransactionCreateWithoutToAccountInput], {nullable:true})
    @Type(() => TransactionCreateWithoutToAccountInput)
    create?: Array<TransactionCreateWithoutToAccountInput>;
    @Field(() => [TransactionCreateOrConnectWithoutToAccountInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutToAccountInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutToAccountInput>;
    @Field(() => [TransactionUpsertWithWhereUniqueWithoutToAccountInput], {nullable:true})
    @Type(() => TransactionUpsertWithWhereUniqueWithoutToAccountInput)
    upsert?: Array<TransactionUpsertWithWhereUniqueWithoutToAccountInput>;
    @Field(() => TransactionCreateManyToAccountInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyToAccountInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyToAccountInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    set?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionUpdateWithWhereUniqueWithoutToAccountInput], {nullable:true})
    @Type(() => TransactionUpdateWithWhereUniqueWithoutToAccountInput)
    update?: Array<TransactionUpdateWithWhereUniqueWithoutToAccountInput>;
    @Field(() => [TransactionUpdateManyWithWhereWithoutToAccountInput], {nullable:true})
    @Type(() => TransactionUpdateManyWithWhereWithoutToAccountInput)
    updateMany?: Array<TransactionUpdateManyWithWhereWithoutToAccountInput>;
    @Field(() => [TransactionScalarWhereInput], {nullable:true})
    @Type(() => TransactionScalarWhereInput)
    deleteMany?: Array<TransactionScalarWhereInput>;
}

@InputType()
export class TransactionUncheckedUpdateManyWithoutToAccountInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    fromAccountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    invoiceId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    installmentId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    withdrawalRequestId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class TransactionUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    fromAccountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    toAccountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    invoiceId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    installmentId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    withdrawalRequestId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class TransactionUncheckedUpdateOneWithoutInstallmentNestedInput {
    @Field(() => TransactionCreateWithoutInstallmentInput, {nullable:true})
    @Type(() => TransactionCreateWithoutInstallmentInput)
    create?: InstanceType<typeof TransactionCreateWithoutInstallmentInput>;
    @Field(() => TransactionCreateOrConnectWithoutInstallmentInput, {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutInstallmentInput)
    connectOrCreate?: InstanceType<typeof TransactionCreateOrConnectWithoutInstallmentInput>;
    @Field(() => TransactionUpsertWithoutInstallmentInput, {nullable:true})
    @Type(() => TransactionUpsertWithoutInstallmentInput)
    upsert?: InstanceType<typeof TransactionUpsertWithoutInstallmentInput>;
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    disconnect?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    delete?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => TransactionUpdateToOneWithWhereWithoutInstallmentInput, {nullable:true})
    @Type(() => TransactionUpdateToOneWithWhereWithoutInstallmentInput)
    update?: InstanceType<typeof TransactionUpdateToOneWithWhereWithoutInstallmentInput>;
}

@InputType()
export class TransactionUncheckedUpdateOneWithoutWithdrawalRequestNestedInput {
    @Field(() => TransactionCreateWithoutWithdrawalRequestInput, {nullable:true})
    @Type(() => TransactionCreateWithoutWithdrawalRequestInput)
    create?: InstanceType<typeof TransactionCreateWithoutWithdrawalRequestInput>;
    @Field(() => TransactionCreateOrConnectWithoutWithdrawalRequestInput, {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutWithdrawalRequestInput)
    connectOrCreate?: InstanceType<typeof TransactionCreateOrConnectWithoutWithdrawalRequestInput>;
    @Field(() => TransactionUpsertWithoutWithdrawalRequestInput, {nullable:true})
    @Type(() => TransactionUpsertWithoutWithdrawalRequestInput)
    upsert?: InstanceType<typeof TransactionUpsertWithoutWithdrawalRequestInput>;
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    disconnect?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    delete?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => TransactionUpdateToOneWithWhereWithoutWithdrawalRequestInput, {nullable:true})
    @Type(() => TransactionUpdateToOneWithWhereWithoutWithdrawalRequestInput)
    update?: InstanceType<typeof TransactionUpdateToOneWithWhereWithoutWithdrawalRequestInput>;
}

@InputType()
export class TransactionUncheckedUpdateWithoutFromAccountInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    toAccountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    invoiceId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    installmentId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    withdrawalRequestId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class TransactionUncheckedUpdateWithoutInstallmentInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    fromAccountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    toAccountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    invoiceId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    withdrawalRequestId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class TransactionUncheckedUpdateWithoutInvoiceInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    fromAccountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    toAccountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    installmentId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    withdrawalRequestId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class TransactionUncheckedUpdateWithoutToAccountInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    fromAccountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    invoiceId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    installmentId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    withdrawalRequestId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class TransactionUncheckedUpdateWithoutWithdrawalRequestInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    fromAccountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    toAccountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    invoiceId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    installmentId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class TransactionUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    fromAccountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    toAccountId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    invoiceId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    installmentId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    withdrawalRequestId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class TransactionUpdateManyMutationInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class TransactionUpdateManyWithWhereWithoutFromAccountInput {
    @Field(() => TransactionScalarWhereInput, {nullable:false})
    @Type(() => TransactionScalarWhereInput)
    where!: InstanceType<typeof TransactionScalarWhereInput>;
    @Field(() => TransactionUpdateManyMutationInput, {nullable:false})
    @Type(() => TransactionUpdateManyMutationInput)
    data!: InstanceType<typeof TransactionUpdateManyMutationInput>;
}

@InputType()
export class TransactionUpdateManyWithWhereWithoutInvoiceInput {
    @Field(() => TransactionScalarWhereInput, {nullable:false})
    @Type(() => TransactionScalarWhereInput)
    where!: InstanceType<typeof TransactionScalarWhereInput>;
    @Field(() => TransactionUpdateManyMutationInput, {nullable:false})
    @Type(() => TransactionUpdateManyMutationInput)
    data!: InstanceType<typeof TransactionUpdateManyMutationInput>;
}

@InputType()
export class TransactionUpdateManyWithWhereWithoutToAccountInput {
    @Field(() => TransactionScalarWhereInput, {nullable:false})
    @Type(() => TransactionScalarWhereInput)
    where!: InstanceType<typeof TransactionScalarWhereInput>;
    @Field(() => TransactionUpdateManyMutationInput, {nullable:false})
    @Type(() => TransactionUpdateManyMutationInput)
    data!: InstanceType<typeof TransactionUpdateManyMutationInput>;
}

@InputType()
export class TransactionUpdateManyWithoutFromAccountNestedInput {
    @Field(() => [TransactionCreateWithoutFromAccountInput], {nullable:true})
    @Type(() => TransactionCreateWithoutFromAccountInput)
    create?: Array<TransactionCreateWithoutFromAccountInput>;
    @Field(() => [TransactionCreateOrConnectWithoutFromAccountInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutFromAccountInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutFromAccountInput>;
    @Field(() => [TransactionUpsertWithWhereUniqueWithoutFromAccountInput], {nullable:true})
    @Type(() => TransactionUpsertWithWhereUniqueWithoutFromAccountInput)
    upsert?: Array<TransactionUpsertWithWhereUniqueWithoutFromAccountInput>;
    @Field(() => TransactionCreateManyFromAccountInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyFromAccountInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyFromAccountInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    set?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionUpdateWithWhereUniqueWithoutFromAccountInput], {nullable:true})
    @Type(() => TransactionUpdateWithWhereUniqueWithoutFromAccountInput)
    update?: Array<TransactionUpdateWithWhereUniqueWithoutFromAccountInput>;
    @Field(() => [TransactionUpdateManyWithWhereWithoutFromAccountInput], {nullable:true})
    @Type(() => TransactionUpdateManyWithWhereWithoutFromAccountInput)
    updateMany?: Array<TransactionUpdateManyWithWhereWithoutFromAccountInput>;
    @Field(() => [TransactionScalarWhereInput], {nullable:true})
    @Type(() => TransactionScalarWhereInput)
    deleteMany?: Array<TransactionScalarWhereInput>;
}

@InputType()
export class TransactionUpdateManyWithoutInvoiceNestedInput {
    @Field(() => [TransactionCreateWithoutInvoiceInput], {nullable:true})
    @Type(() => TransactionCreateWithoutInvoiceInput)
    create?: Array<TransactionCreateWithoutInvoiceInput>;
    @Field(() => [TransactionCreateOrConnectWithoutInvoiceInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutInvoiceInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutInvoiceInput>;
    @Field(() => [TransactionUpsertWithWhereUniqueWithoutInvoiceInput], {nullable:true})
    @Type(() => TransactionUpsertWithWhereUniqueWithoutInvoiceInput)
    upsert?: Array<TransactionUpsertWithWhereUniqueWithoutInvoiceInput>;
    @Field(() => TransactionCreateManyInvoiceInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyInvoiceInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyInvoiceInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    set?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionUpdateWithWhereUniqueWithoutInvoiceInput], {nullable:true})
    @Type(() => TransactionUpdateWithWhereUniqueWithoutInvoiceInput)
    update?: Array<TransactionUpdateWithWhereUniqueWithoutInvoiceInput>;
    @Field(() => [TransactionUpdateManyWithWhereWithoutInvoiceInput], {nullable:true})
    @Type(() => TransactionUpdateManyWithWhereWithoutInvoiceInput)
    updateMany?: Array<TransactionUpdateManyWithWhereWithoutInvoiceInput>;
    @Field(() => [TransactionScalarWhereInput], {nullable:true})
    @Type(() => TransactionScalarWhereInput)
    deleteMany?: Array<TransactionScalarWhereInput>;
}

@InputType()
export class TransactionUpdateManyWithoutToAccountNestedInput {
    @Field(() => [TransactionCreateWithoutToAccountInput], {nullable:true})
    @Type(() => TransactionCreateWithoutToAccountInput)
    create?: Array<TransactionCreateWithoutToAccountInput>;
    @Field(() => [TransactionCreateOrConnectWithoutToAccountInput], {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutToAccountInput)
    connectOrCreate?: Array<TransactionCreateOrConnectWithoutToAccountInput>;
    @Field(() => [TransactionUpsertWithWhereUniqueWithoutToAccountInput], {nullable:true})
    @Type(() => TransactionUpsertWithWhereUniqueWithoutToAccountInput)
    upsert?: Array<TransactionUpsertWithWhereUniqueWithoutToAccountInput>;
    @Field(() => TransactionCreateManyToAccountInputEnvelope, {nullable:true})
    @Type(() => TransactionCreateManyToAccountInputEnvelope)
    createMany?: InstanceType<typeof TransactionCreateManyToAccountInputEnvelope>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    set?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionWhereUniqueInput], {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>>;
    @Field(() => [TransactionUpdateWithWhereUniqueWithoutToAccountInput], {nullable:true})
    @Type(() => TransactionUpdateWithWhereUniqueWithoutToAccountInput)
    update?: Array<TransactionUpdateWithWhereUniqueWithoutToAccountInput>;
    @Field(() => [TransactionUpdateManyWithWhereWithoutToAccountInput], {nullable:true})
    @Type(() => TransactionUpdateManyWithWhereWithoutToAccountInput)
    updateMany?: Array<TransactionUpdateManyWithWhereWithoutToAccountInput>;
    @Field(() => [TransactionScalarWhereInput], {nullable:true})
    @Type(() => TransactionScalarWhereInput)
    deleteMany?: Array<TransactionScalarWhereInput>;
}

@InputType()
export class TransactionUpdateOneWithoutInstallmentNestedInput {
    @Field(() => TransactionCreateWithoutInstallmentInput, {nullable:true})
    @Type(() => TransactionCreateWithoutInstallmentInput)
    create?: InstanceType<typeof TransactionCreateWithoutInstallmentInput>;
    @Field(() => TransactionCreateOrConnectWithoutInstallmentInput, {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutInstallmentInput)
    connectOrCreate?: InstanceType<typeof TransactionCreateOrConnectWithoutInstallmentInput>;
    @Field(() => TransactionUpsertWithoutInstallmentInput, {nullable:true})
    @Type(() => TransactionUpsertWithoutInstallmentInput)
    upsert?: InstanceType<typeof TransactionUpsertWithoutInstallmentInput>;
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    disconnect?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    delete?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => TransactionUpdateToOneWithWhereWithoutInstallmentInput, {nullable:true})
    @Type(() => TransactionUpdateToOneWithWhereWithoutInstallmentInput)
    update?: InstanceType<typeof TransactionUpdateToOneWithWhereWithoutInstallmentInput>;
}

@InputType()
export class TransactionUpdateOneWithoutWithdrawalRequestNestedInput {
    @Field(() => TransactionCreateWithoutWithdrawalRequestInput, {nullable:true})
    @Type(() => TransactionCreateWithoutWithdrawalRequestInput)
    create?: InstanceType<typeof TransactionCreateWithoutWithdrawalRequestInput>;
    @Field(() => TransactionCreateOrConnectWithoutWithdrawalRequestInput, {nullable:true})
    @Type(() => TransactionCreateOrConnectWithoutWithdrawalRequestInput)
    connectOrCreate?: InstanceType<typeof TransactionCreateOrConnectWithoutWithdrawalRequestInput>;
    @Field(() => TransactionUpsertWithoutWithdrawalRequestInput, {nullable:true})
    @Type(() => TransactionUpsertWithoutWithdrawalRequestInput)
    upsert?: InstanceType<typeof TransactionUpsertWithoutWithdrawalRequestInput>;
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    disconnect?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    delete?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:true})
    @Type(() => TransactionWhereUniqueInput)
    connect?: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => TransactionUpdateToOneWithWhereWithoutWithdrawalRequestInput, {nullable:true})
    @Type(() => TransactionUpdateToOneWithWhereWithoutWithdrawalRequestInput)
    update?: InstanceType<typeof TransactionUpdateToOneWithWhereWithoutWithdrawalRequestInput>;
}

@InputType()
export class TransactionUpdateToOneWithWhereWithoutInstallmentInput {
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => TransactionUpdateWithoutInstallmentInput, {nullable:false})
    @Type(() => TransactionUpdateWithoutInstallmentInput)
    data!: InstanceType<typeof TransactionUpdateWithoutInstallmentInput>;
}

@InputType()
export class TransactionUpdateToOneWithWhereWithoutWithdrawalRequestInput {
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
    @Field(() => TransactionUpdateWithoutWithdrawalRequestInput, {nullable:false})
    @Type(() => TransactionUpdateWithoutWithdrawalRequestInput)
    data!: InstanceType<typeof TransactionUpdateWithoutWithdrawalRequestInput>;
}

@InputType()
export class TransactionUpdateWithWhereUniqueWithoutFromAccountInput {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => TransactionUpdateWithoutFromAccountInput, {nullable:false})
    @Type(() => TransactionUpdateWithoutFromAccountInput)
    data!: InstanceType<typeof TransactionUpdateWithoutFromAccountInput>;
}

@InputType()
export class TransactionUpdateWithWhereUniqueWithoutInvoiceInput {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => TransactionUpdateWithoutInvoiceInput, {nullable:false})
    @Type(() => TransactionUpdateWithoutInvoiceInput)
    data!: InstanceType<typeof TransactionUpdateWithoutInvoiceInput>;
}

@InputType()
export class TransactionUpdateWithWhereUniqueWithoutToAccountInput {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => TransactionUpdateWithoutToAccountInput, {nullable:false})
    @Type(() => TransactionUpdateWithoutToAccountInput)
    data!: InstanceType<typeof TransactionUpdateWithoutToAccountInput>;
}

@InputType()
export class TransactionUpdateWithoutFromAccountInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    toAccount?: InstanceType<typeof AccountUpdateOneRequiredWithoutTransactionDestinationNestedInput>;
    @Field(() => InvoiceUpdateOneWithoutTransactionsNestedInput, {nullable:true})
    invoice?: InstanceType<typeof InvoiceUpdateOneWithoutTransactionsNestedInput>;
    @HideField()
    Installment?: InstanceType<typeof InstallmentUpdateOneWithoutTransactionNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateOneWithoutTransactionNestedInput>;
}

@InputType()
export class TransactionUpdateWithoutInstallmentInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    fromAccount?: InstanceType<typeof AccountUpdateOneRequiredWithoutTransactionOriginsNestedInput>;
    @HideField()
    toAccount?: InstanceType<typeof AccountUpdateOneRequiredWithoutTransactionDestinationNestedInput>;
    @Field(() => InvoiceUpdateOneWithoutTransactionsNestedInput, {nullable:true})
    invoice?: InstanceType<typeof InvoiceUpdateOneWithoutTransactionsNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateOneWithoutTransactionNestedInput>;
}

@InputType()
export class TransactionUpdateWithoutInvoiceInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    fromAccount?: InstanceType<typeof AccountUpdateOneRequiredWithoutTransactionOriginsNestedInput>;
    @HideField()
    toAccount?: InstanceType<typeof AccountUpdateOneRequiredWithoutTransactionDestinationNestedInput>;
    @HideField()
    Installment?: InstanceType<typeof InstallmentUpdateOneWithoutTransactionNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateOneWithoutTransactionNestedInput>;
}

@InputType()
export class TransactionUpdateWithoutToAccountInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    fromAccount?: InstanceType<typeof AccountUpdateOneRequiredWithoutTransactionOriginsNestedInput>;
    @Field(() => InvoiceUpdateOneWithoutTransactionsNestedInput, {nullable:true})
    invoice?: InstanceType<typeof InvoiceUpdateOneWithoutTransactionsNestedInput>;
    @HideField()
    Installment?: InstanceType<typeof InstallmentUpdateOneWithoutTransactionNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateOneWithoutTransactionNestedInput>;
}

@InputType()
export class TransactionUpdateWithoutWithdrawalRequestInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    fromAccount?: InstanceType<typeof AccountUpdateOneRequiredWithoutTransactionOriginsNestedInput>;
    @HideField()
    toAccount?: InstanceType<typeof AccountUpdateOneRequiredWithoutTransactionDestinationNestedInput>;
    @Field(() => InvoiceUpdateOneWithoutTransactionsNestedInput, {nullable:true})
    invoice?: InstanceType<typeof InvoiceUpdateOneWithoutTransactionsNestedInput>;
    @HideField()
    Installment?: InstanceType<typeof InstallmentUpdateOneWithoutTransactionNestedInput>;
}

@InputType()
export class TransactionUpdateInput {
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionCategoryFieldUpdateOperationsInput, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFieldUpdateOperationsInput>;
    @HideField()
    uniqueCode?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    fromAccount?: InstanceType<typeof AccountUpdateOneRequiredWithoutTransactionOriginsNestedInput>;
    @HideField()
    toAccount?: InstanceType<typeof AccountUpdateOneRequiredWithoutTransactionDestinationNestedInput>;
    @Field(() => InvoiceUpdateOneWithoutTransactionsNestedInput, {nullable:true})
    invoice?: InstanceType<typeof InvoiceUpdateOneWithoutTransactionsNestedInput>;
    @HideField()
    Installment?: InstanceType<typeof InstallmentUpdateOneWithoutTransactionNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateOneWithoutTransactionNestedInput>;
}

@InputType()
export class TransactionUpsertWithWhereUniqueWithoutFromAccountInput {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => TransactionUpdateWithoutFromAccountInput, {nullable:false})
    @Type(() => TransactionUpdateWithoutFromAccountInput)
    update!: InstanceType<typeof TransactionUpdateWithoutFromAccountInput>;
    @Field(() => TransactionCreateWithoutFromAccountInput, {nullable:false})
    @Type(() => TransactionCreateWithoutFromAccountInput)
    create!: InstanceType<typeof TransactionCreateWithoutFromAccountInput>;
}

@InputType()
export class TransactionUpsertWithWhereUniqueWithoutInvoiceInput {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => TransactionUpdateWithoutInvoiceInput, {nullable:false})
    @Type(() => TransactionUpdateWithoutInvoiceInput)
    update!: InstanceType<typeof TransactionUpdateWithoutInvoiceInput>;
    @Field(() => TransactionCreateWithoutInvoiceInput, {nullable:false})
    @Type(() => TransactionCreateWithoutInvoiceInput)
    create!: InstanceType<typeof TransactionCreateWithoutInvoiceInput>;
}

@InputType()
export class TransactionUpsertWithWhereUniqueWithoutToAccountInput {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => TransactionUpdateWithoutToAccountInput, {nullable:false})
    @Type(() => TransactionUpdateWithoutToAccountInput)
    update!: InstanceType<typeof TransactionUpdateWithoutToAccountInput>;
    @Field(() => TransactionCreateWithoutToAccountInput, {nullable:false})
    @Type(() => TransactionCreateWithoutToAccountInput)
    create!: InstanceType<typeof TransactionCreateWithoutToAccountInput>;
}

@InputType()
export class TransactionUpsertWithoutInstallmentInput {
    @Field(() => TransactionUpdateWithoutInstallmentInput, {nullable:false})
    @Type(() => TransactionUpdateWithoutInstallmentInput)
    update!: InstanceType<typeof TransactionUpdateWithoutInstallmentInput>;
    @Field(() => TransactionCreateWithoutInstallmentInput, {nullable:false})
    @Type(() => TransactionCreateWithoutInstallmentInput)
    create!: InstanceType<typeof TransactionCreateWithoutInstallmentInput>;
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
}

@InputType()
export class TransactionUpsertWithoutWithdrawalRequestInput {
    @Field(() => TransactionUpdateWithoutWithdrawalRequestInput, {nullable:false})
    @Type(() => TransactionUpdateWithoutWithdrawalRequestInput)
    update!: InstanceType<typeof TransactionUpdateWithoutWithdrawalRequestInput>;
    @Field(() => TransactionCreateWithoutWithdrawalRequestInput, {nullable:false})
    @Type(() => TransactionCreateWithoutWithdrawalRequestInput)
    create!: InstanceType<typeof TransactionCreateWithoutWithdrawalRequestInput>;
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
}

@InputType()
export class TransactionWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Int, {nullable:true})
    installmentId?: number;
    @Field(() => Int, {nullable:true})
    withdrawalRequestId?: number;
    @Field(() => [TransactionWhereInput], {nullable:true})
    AND?: Array<TransactionWhereInput>;
    @Field(() => [TransactionWhereInput], {nullable:true})
    OR?: Array<TransactionWhereInput>;
    @Field(() => [TransactionWhereInput], {nullable:true})
    NOT?: Array<TransactionWhereInput>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    proofUrl?: InstanceType<typeof StringNullableFilter>;
    @Field(() => EnumTransactionStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFilter>;
    @Field(() => EnumTransactionCategoryFilter, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFilter>;
    @Field(() => IntFilter, {nullable:true})
    fromAccountId?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    toAccountId?: InstanceType<typeof IntFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    invoiceId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntFilter, {nullable:true})
    uniqueCode?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => AccountRelationFilter, {nullable:true})
    fromAccount?: InstanceType<typeof AccountRelationFilter>;
    @Field(() => AccountRelationFilter, {nullable:true})
    toAccount?: InstanceType<typeof AccountRelationFilter>;
    @Field(() => InvoiceNullableRelationFilter, {nullable:true})
    invoice?: InstanceType<typeof InvoiceNullableRelationFilter>;
    @HideField()
    Installment?: InstanceType<typeof InstallmentNullableRelationFilter>;
    @Field(() => WithdrawalRequestNullableRelationFilter, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestNullableRelationFilter>;
}

@InputType()
export class TransactionWhereInput {
    @Field(() => [TransactionWhereInput], {nullable:true})
    AND?: Array<TransactionWhereInput>;
    @Field(() => [TransactionWhereInput], {nullable:true})
    OR?: Array<TransactionWhereInput>;
    @Field(() => [TransactionWhereInput], {nullable:true})
    NOT?: Array<TransactionWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    proofUrl?: InstanceType<typeof StringNullableFilter>;
    @Field(() => EnumTransactionStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFilter>;
    @Field(() => EnumTransactionCategoryFilter, {nullable:true})
    transactionCategory?: InstanceType<typeof EnumTransactionCategoryFilter>;
    @Field(() => IntFilter, {nullable:true})
    fromAccountId?: InstanceType<typeof IntFilter>;
    @Field(() => IntFilter, {nullable:true})
    toAccountId?: InstanceType<typeof IntFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    invoiceId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    installmentId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    withdrawalRequestId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => IntFilter, {nullable:true})
    uniqueCode?: InstanceType<typeof IntFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => AccountRelationFilter, {nullable:true})
    fromAccount?: InstanceType<typeof AccountRelationFilter>;
    @Field(() => AccountRelationFilter, {nullable:true})
    toAccount?: InstanceType<typeof AccountRelationFilter>;
    @Field(() => InvoiceNullableRelationFilter, {nullable:true})
    invoice?: InstanceType<typeof InvoiceNullableRelationFilter>;
    @HideField()
    Installment?: InstanceType<typeof InstallmentNullableRelationFilter>;
    @Field(() => WithdrawalRequestNullableRelationFilter, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestNullableRelationFilter>;
}

@ObjectType()
export class Transaction {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => String, {nullable:true})
    proofUrl!: string | null;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => TransactionCategory, {nullable:false})
    transactionCategory!: keyof typeof TransactionCategory;
    @Field(() => Int, {nullable:false})
    fromAccountId!: number;
    @Field(() => Int, {nullable:false})
    toAccountId!: number;
    @Field(() => Int, {nullable:true})
    invoiceId!: number | null;
    @Field(() => Int, {nullable:true})
    installmentId!: number | null;
    @Field(() => Int, {nullable:true})
    withdrawalRequestId!: number | null;
    @Field(() => Int, {nullable:false})
    uniqueCode!: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Account, {nullable:false})
    fromAccount?: InstanceType<typeof Account>;
    @Field(() => Account, {nullable:false})
    toAccount?: InstanceType<typeof Account>;
    @Field(() => Invoice, {nullable:true})
    invoice?: InstanceType<typeof Invoice> | null;
    @Field(() => Installment, {nullable:true})
    Installment?: InstanceType<typeof Installment> | null;
    @Field(() => WithdrawalRequest, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequest> | null;
}

@ArgsType()
export class UpdateManyTransactionArgs {
    @Field(() => TransactionUpdateManyMutationInput, {nullable:false})
    @Type(() => TransactionUpdateManyMutationInput)
    data!: InstanceType<typeof TransactionUpdateManyMutationInput>;
    @Field(() => TransactionWhereInput, {nullable:true})
    @Type(() => TransactionWhereInput)
    where?: InstanceType<typeof TransactionWhereInput>;
}

@ArgsType()
export class UpdateOneTransactionArgs {
    @Field(() => TransactionUpdateInput, {nullable:false})
    @Type(() => TransactionUpdateInput)
    data!: InstanceType<typeof TransactionUpdateInput>;
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
}

@ArgsType()
export class UpsertOneTransactionArgs {
    @Field(() => TransactionWhereUniqueInput, {nullable:false})
    @Type(() => TransactionWhereUniqueInput)
    where!: Prisma.AtLeast<TransactionWhereUniqueInput, 'id' | 'installmentId' | 'withdrawalRequestId'>;
    @Field(() => TransactionCreateInput, {nullable:false})
    @Type(() => TransactionCreateInput)
    create!: InstanceType<typeof TransactionCreateInput>;
    @Field(() => TransactionUpdateInput, {nullable:false})
    @Type(() => TransactionUpdateInput)
    update!: InstanceType<typeof TransactionUpdateInput>;
}

@ObjectType()
export class AggregateUser {
    @Field(() => UserCountAggregate, {nullable:true})
    _count?: InstanceType<typeof UserCountAggregate>;
    @Field(() => UserAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof UserAvgAggregate>;
    @Field(() => UserSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof UserSumAggregate>;
    @Field(() => UserMinAggregate, {nullable:true})
    _min?: InstanceType<typeof UserMinAggregate>;
    @Field(() => UserMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof UserMaxAggregate>;
}

@ArgsType()
export class CreateManyUserArgs {
    @Field(() => [UserCreateManyInput], {nullable:false})
    @Type(() => UserCreateManyInput)
    data!: Array<UserCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneUserArgs {
    @Field(() => UserCreateInput, {nullable:false})
    @Type(() => UserCreateInput)
    data!: InstanceType<typeof UserCreateInput>;
}

@ArgsType()
export class DeleteManyUserArgs {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@ArgsType()
export class DeleteOneUserArgs {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
}

@ArgsType()
export class FindFirstUserOrThrowArgs {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => [UserOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<UserOrderByWithRelationInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [UserScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof UserScalarFieldEnum>;
}

@ArgsType()
export class FindFirstUserArgs {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => [UserOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<UserOrderByWithRelationInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [UserScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof UserScalarFieldEnum>;
}

@ArgsType()
export class FindManyUserArgs {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => [UserOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<UserOrderByWithRelationInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [UserScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof UserScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueUserOrThrowArgs {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
}

@ArgsType()
export class FindUniqueUserArgs {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
}

@ArgsType()
export class UpdateManyUserArgs {
    @Field(() => UserUpdateManyMutationInput, {nullable:false})
    @Type(() => UserUpdateManyMutationInput)
    data!: InstanceType<typeof UserUpdateManyMutationInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@ArgsType()
export class UpdateOneUserArgs {
    @Field(() => UserUpdateInput, {nullable:false})
    @Type(() => UserUpdateInput)
    data!: InstanceType<typeof UserUpdateInput>;
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
}

@ArgsType()
export class UpsertOneUserArgs {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserCreateInput, {nullable:false})
    @Type(() => UserCreateInput)
    create!: InstanceType<typeof UserCreateInput>;
    @Field(() => UserUpdateInput, {nullable:false})
    @Type(() => UserUpdateInput)
    update!: InstanceType<typeof UserUpdateInput>;
}

@ArgsType()
export class UserAggregateArgs {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => [UserOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<UserOrderByWithRelationInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => UserCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof UserCountAggregateInput>;
    @Field(() => UserAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof UserAvgAggregateInput>;
    @Field(() => UserSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof UserSumAggregateInput>;
    @Field(() => UserMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof UserMinAggregateInput>;
    @Field(() => UserMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof UserMaxAggregateInput>;
}

@InputType()
export class UserAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    schoolId?: true;
}

@ObjectType()
export class UserAvgAggregate {
    @Field(() => Float, {nullable:true})
    addressId?: number;
    @Field(() => Float, {nullable:true})
    schoolId?: number;
}

@InputType()
export class UserAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    schoolId?: keyof typeof SortOrder;
}

@InputType()
export class UserCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    firstName?: true;
    @Field(() => Boolean, {nullable:true})
    lastName?: true;
    @Field(() => Boolean, {nullable:true})
    email?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    userRole?: true;
    @Field(() => Boolean, {nullable:true})
    userType?: true;
    @Field(() => Boolean, {nullable:true})
    avatarUrl?: true;
    @Field(() => Boolean, {nullable:true})
    whatsappNumber?: true;
    @Field(() => Boolean, {nullable:true})
    whatsappVerifiedAt?: true;
    @Field(() => Boolean, {nullable:true})
    password?: true;
    @Field(() => Boolean, {nullable:true})
    referralCode?: true;
    @HideField()
    referredById?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    schoolId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    deletedAt?: true;
    @Field(() => Boolean, {nullable:true})
    theme?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class UserCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    firstName!: number;
    @Field(() => Int, {nullable:false})
    lastName!: number;
    @Field(() => Int, {nullable:false})
    email!: number;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => Int, {nullable:false})
    userRole!: number;
    @Field(() => Int, {nullable:false})
    userType!: number;
    @Field(() => Int, {nullable:false})
    avatarUrl!: number;
    @Field(() => Int, {nullable:false})
    whatsappNumber!: number;
    @Field(() => Int, {nullable:false})
    whatsappVerifiedAt!: number;
    @HideField()
    password!: number;
    @Field(() => Int, {nullable:false})
    referralCode!: number;
    @Field(() => Int, {nullable:false})
    referredById!: number;
    @Field(() => Int, {nullable:false})
    status!: number;
    @Field(() => Int, {nullable:false})
    schoolId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    deletedAt!: number;
    @Field(() => Int, {nullable:false})
    theme!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class UserCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    firstName?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    lastName?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    email?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    avatarUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    whatsappNumber?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    whatsappVerifiedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    password?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    referralCode?: keyof typeof SortOrder;
    @HideField()
    referredById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    schoolId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    deletedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    theme?: keyof typeof SortOrder;
}

@ObjectType()
export class UserCount {
    @Field(() => Int, {nullable:false})
    referredUsers?: number;
    @Field(() => Int, {nullable:false})
    checkIns?: number;
    @Field(() => Int, {nullable:false})
    accounts?: number;
    @Field(() => Int, {nullable:false})
    PointTransactions?: number;
    @Field(() => Int, {nullable:false})
    orders?: number;
    @Field(() => Int, {nullable:false})
    sessions?: number;
    @Field(() => Int, {nullable:false})
    hotelsCreated?: number;
    @Field(() => Int, {nullable:false})
    programsParticipation?: number;
    @Field(() => Int, {nullable:false})
    claimedRewards?: number;
    @Field(() => Int, {nullable:false})
    withdrawalRequest?: number;
    @Field(() => Int, {nullable:false})
    userNotifications?: number;
    @Field(() => Int, {nullable:false})
    programsCreated?: number;
    @Field(() => Int, {nullable:false})
    filesCreated?: number;
}

@InputType()
export class UserCreateManyReferredByInputEnvelope {
    @Field(() => [UserCreateManyReferredByInput], {nullable:false})
    @Type(() => UserCreateManyReferredByInput)
    data!: Array<UserCreateManyReferredByInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class UserCreateManyReferredByInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
}

@InputType()
export class UserCreateManySchoolInputEnvelope {
    @Field(() => [UserCreateManySchoolInput], {nullable:false})
    @Type(() => UserCreateManySchoolInput)
    data!: Array<UserCreateManySchoolInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class UserCreateManySchoolInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
}

@InputType()
export class UserCreateManyInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    referredById?: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
}

@InputType()
export class UserCreateNestedManyWithoutProgramsParticipationInput {
    @Field(() => [UserCreateWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserCreateWithoutProgramsParticipationInput)
    create?: Array<UserCreateWithoutProgramsParticipationInput>;
    @Field(() => [UserCreateOrConnectWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutProgramsParticipationInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutProgramsParticipationInput>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
}

@InputType()
export class UserCreateNestedManyWithoutReferredByInput {
    @Field(() => [UserCreateWithoutReferredByInput], {nullable:true})
    @Type(() => UserCreateWithoutReferredByInput)
    create?: Array<UserCreateWithoutReferredByInput>;
    @Field(() => [UserCreateOrConnectWithoutReferredByInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutReferredByInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutReferredByInput>;
    @Field(() => UserCreateManyReferredByInputEnvelope, {nullable:true})
    @Type(() => UserCreateManyReferredByInputEnvelope)
    createMany?: InstanceType<typeof UserCreateManyReferredByInputEnvelope>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
}

@InputType()
export class UserCreateNestedManyWithoutSchoolInput {
    @Field(() => [UserCreateWithoutSchoolInput], {nullable:true})
    @Type(() => UserCreateWithoutSchoolInput)
    create?: Array<UserCreateWithoutSchoolInput>;
    @Field(() => [UserCreateOrConnectWithoutSchoolInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutSchoolInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutSchoolInput>;
    @Field(() => UserCreateManySchoolInputEnvelope, {nullable:true})
    @Type(() => UserCreateManySchoolInputEnvelope)
    createMany?: InstanceType<typeof UserCreateManySchoolInputEnvelope>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
}

@InputType()
export class UserCreateNestedOneWithoutAccountsInput {
    @Field(() => UserCreateWithoutAccountsInput, {nullable:true})
    @Type(() => UserCreateWithoutAccountsInput)
    create?: InstanceType<typeof UserCreateWithoutAccountsInput>;
    @Field(() => UserCreateOrConnectWithoutAccountsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutAccountsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutAccountsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
}

@InputType()
export class UserCreateNestedOneWithoutAddressInput {
    @Field(() => UserCreateWithoutAddressInput, {nullable:true})
    @Type(() => UserCreateWithoutAddressInput)
    create?: InstanceType<typeof UserCreateWithoutAddressInput>;
    @Field(() => UserCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutAddressInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
}

@InputType()
export class UserCreateNestedOneWithoutCheckInsInput {
    @Field(() => UserCreateWithoutCheckInsInput, {nullable:true})
    @Type(() => UserCreateWithoutCheckInsInput)
    create?: InstanceType<typeof UserCreateWithoutCheckInsInput>;
    @Field(() => UserCreateOrConnectWithoutCheckInsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutCheckInsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutCheckInsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
}

@InputType()
export class UserCreateNestedOneWithoutClaimedRewardsInput {
    @Field(() => UserCreateWithoutClaimedRewardsInput, {nullable:true})
    @Type(() => UserCreateWithoutClaimedRewardsInput)
    create?: InstanceType<typeof UserCreateWithoutClaimedRewardsInput>;
    @Field(() => UserCreateOrConnectWithoutClaimedRewardsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutClaimedRewardsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutClaimedRewardsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
}

@InputType()
export class UserCreateNestedOneWithoutFilesCreatedInput {
    @Field(() => UserCreateWithoutFilesCreatedInput, {nullable:true})
    @Type(() => UserCreateWithoutFilesCreatedInput)
    create?: InstanceType<typeof UserCreateWithoutFilesCreatedInput>;
    @Field(() => UserCreateOrConnectWithoutFilesCreatedInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutFilesCreatedInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutFilesCreatedInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
}

@InputType()
export class UserCreateNestedOneWithoutHotelsCreatedInput {
    @Field(() => UserCreateWithoutHotelsCreatedInput, {nullable:true})
    @Type(() => UserCreateWithoutHotelsCreatedInput)
    create?: InstanceType<typeof UserCreateWithoutHotelsCreatedInput>;
    @Field(() => UserCreateOrConnectWithoutHotelsCreatedInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutHotelsCreatedInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutHotelsCreatedInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
}

@InputType()
export class UserCreateNestedOneWithoutOrdersInput {
    @Field(() => UserCreateWithoutOrdersInput, {nullable:true})
    @Type(() => UserCreateWithoutOrdersInput)
    create?: InstanceType<typeof UserCreateWithoutOrdersInput>;
    @Field(() => UserCreateOrConnectWithoutOrdersInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutOrdersInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutOrdersInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
}

@InputType()
export class UserCreateNestedOneWithoutPointTransactionsInput {
    @Field(() => UserCreateWithoutPointTransactionsInput, {nullable:true})
    @Type(() => UserCreateWithoutPointTransactionsInput)
    create?: InstanceType<typeof UserCreateWithoutPointTransactionsInput>;
    @Field(() => UserCreateOrConnectWithoutPointTransactionsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutPointTransactionsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutPointTransactionsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
}

@InputType()
export class UserCreateNestedOneWithoutProgramsCreatedInput {
    @Field(() => UserCreateWithoutProgramsCreatedInput, {nullable:true})
    @Type(() => UserCreateWithoutProgramsCreatedInput)
    create?: InstanceType<typeof UserCreateWithoutProgramsCreatedInput>;
    @Field(() => UserCreateOrConnectWithoutProgramsCreatedInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutProgramsCreatedInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutProgramsCreatedInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
}

@InputType()
export class UserCreateNestedOneWithoutReferredUsersInput {
    @Field(() => UserCreateWithoutReferredUsersInput, {nullable:true})
    @Type(() => UserCreateWithoutReferredUsersInput)
    create?: InstanceType<typeof UserCreateWithoutReferredUsersInput>;
    @Field(() => UserCreateOrConnectWithoutReferredUsersInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutReferredUsersInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutReferredUsersInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
}

@InputType()
export class UserCreateNestedOneWithoutSessionsInput {
    @Field(() => UserCreateWithoutSessionsInput, {nullable:true})
    @Type(() => UserCreateWithoutSessionsInput)
    create?: InstanceType<typeof UserCreateWithoutSessionsInput>;
    @Field(() => UserCreateOrConnectWithoutSessionsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutSessionsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutSessionsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
}

@InputType()
export class UserCreateNestedOneWithoutUserNotificationsInput {
    @Field(() => UserCreateWithoutUserNotificationsInput, {nullable:true})
    @Type(() => UserCreateWithoutUserNotificationsInput)
    create?: InstanceType<typeof UserCreateWithoutUserNotificationsInput>;
    @Field(() => UserCreateOrConnectWithoutUserNotificationsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutUserNotificationsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutUserNotificationsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
}

@InputType()
export class UserCreateNestedOneWithoutWithdrawalRequestInput {
    @Field(() => UserCreateWithoutWithdrawalRequestInput, {nullable:true})
    @Type(() => UserCreateWithoutWithdrawalRequestInput)
    create?: InstanceType<typeof UserCreateWithoutWithdrawalRequestInput>;
    @Field(() => UserCreateOrConnectWithoutWithdrawalRequestInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutWithdrawalRequestInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutWithdrawalRequestInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
}

@InputType()
export class UserCreateOrConnectWithoutAccountsInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserCreateWithoutAccountsInput, {nullable:false})
    @Type(() => UserCreateWithoutAccountsInput)
    create!: InstanceType<typeof UserCreateWithoutAccountsInput>;
}

@InputType()
export class UserCreateOrConnectWithoutAddressInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserCreateWithoutAddressInput, {nullable:false})
    @Type(() => UserCreateWithoutAddressInput)
    create!: InstanceType<typeof UserCreateWithoutAddressInput>;
}

@InputType()
export class UserCreateOrConnectWithoutCheckInsInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserCreateWithoutCheckInsInput, {nullable:false})
    @Type(() => UserCreateWithoutCheckInsInput)
    create!: InstanceType<typeof UserCreateWithoutCheckInsInput>;
}

@InputType()
export class UserCreateOrConnectWithoutClaimedRewardsInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserCreateWithoutClaimedRewardsInput, {nullable:false})
    @Type(() => UserCreateWithoutClaimedRewardsInput)
    create!: InstanceType<typeof UserCreateWithoutClaimedRewardsInput>;
}

@InputType()
export class UserCreateOrConnectWithoutFilesCreatedInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserCreateWithoutFilesCreatedInput, {nullable:false})
    @Type(() => UserCreateWithoutFilesCreatedInput)
    create!: InstanceType<typeof UserCreateWithoutFilesCreatedInput>;
}

@InputType()
export class UserCreateOrConnectWithoutHotelsCreatedInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserCreateWithoutHotelsCreatedInput, {nullable:false})
    @Type(() => UserCreateWithoutHotelsCreatedInput)
    create!: InstanceType<typeof UserCreateWithoutHotelsCreatedInput>;
}

@InputType()
export class UserCreateOrConnectWithoutOrdersInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserCreateWithoutOrdersInput, {nullable:false})
    @Type(() => UserCreateWithoutOrdersInput)
    create!: InstanceType<typeof UserCreateWithoutOrdersInput>;
}

@InputType()
export class UserCreateOrConnectWithoutPointTransactionsInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserCreateWithoutPointTransactionsInput, {nullable:false})
    @Type(() => UserCreateWithoutPointTransactionsInput)
    create!: InstanceType<typeof UserCreateWithoutPointTransactionsInput>;
}

@InputType()
export class UserCreateOrConnectWithoutProgramsCreatedInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserCreateWithoutProgramsCreatedInput, {nullable:false})
    @Type(() => UserCreateWithoutProgramsCreatedInput)
    create!: InstanceType<typeof UserCreateWithoutProgramsCreatedInput>;
}

@InputType()
export class UserCreateOrConnectWithoutProgramsParticipationInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserCreateWithoutProgramsParticipationInput, {nullable:false})
    @Type(() => UserCreateWithoutProgramsParticipationInput)
    create!: InstanceType<typeof UserCreateWithoutProgramsParticipationInput>;
}

@InputType()
export class UserCreateOrConnectWithoutReferredByInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserCreateWithoutReferredByInput, {nullable:false})
    @Type(() => UserCreateWithoutReferredByInput)
    create!: InstanceType<typeof UserCreateWithoutReferredByInput>;
}

@InputType()
export class UserCreateOrConnectWithoutReferredUsersInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserCreateWithoutReferredUsersInput, {nullable:false})
    @Type(() => UserCreateWithoutReferredUsersInput)
    create!: InstanceType<typeof UserCreateWithoutReferredUsersInput>;
}

@InputType()
export class UserCreateOrConnectWithoutSchoolInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserCreateWithoutSchoolInput, {nullable:false})
    @Type(() => UserCreateWithoutSchoolInput)
    create!: InstanceType<typeof UserCreateWithoutSchoolInput>;
}

@InputType()
export class UserCreateOrConnectWithoutSessionsInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserCreateWithoutSessionsInput, {nullable:false})
    @Type(() => UserCreateWithoutSessionsInput)
    create!: InstanceType<typeof UserCreateWithoutSessionsInput>;
}

@InputType()
export class UserCreateOrConnectWithoutUserNotificationsInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserCreateWithoutUserNotificationsInput, {nullable:false})
    @Type(() => UserCreateWithoutUserNotificationsInput)
    create!: InstanceType<typeof UserCreateWithoutUserNotificationsInput>;
}

@InputType()
export class UserCreateOrConnectWithoutWithdrawalRequestInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserCreateWithoutWithdrawalRequestInput, {nullable:false})
    @Type(() => UserCreateWithoutWithdrawalRequestInput)
    create!: InstanceType<typeof UserCreateWithoutWithdrawalRequestInput>;
}

@InputType()
export class UserCreateWithoutAccountsInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimCreateNestedManyWithoutUserInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutAddressInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @Field(() => AccountCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimCreateNestedManyWithoutUserInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutCheckInsInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @Field(() => AccountCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimCreateNestedManyWithoutUserInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutClaimedRewardsInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @Field(() => AccountCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutFilesCreatedInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @Field(() => AccountCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimCreateNestedManyWithoutUserInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutHotelsCreatedInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @Field(() => AccountCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimCreateNestedManyWithoutUserInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutOrdersInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @Field(() => AccountCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimCreateNestedManyWithoutUserInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutPointTransactionsInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @Field(() => AccountCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimCreateNestedManyWithoutUserInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutProgramsCreatedInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @Field(() => AccountCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimCreateNestedManyWithoutUserInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutProgramsParticipationInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @Field(() => AccountCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimCreateNestedManyWithoutUserInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutReferredByInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @Field(() => AccountCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimCreateNestedManyWithoutUserInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutReferredUsersInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @Field(() => AccountCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimCreateNestedManyWithoutUserInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutSchoolInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => AccountCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimCreateNestedManyWithoutUserInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutSessionsInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @Field(() => AccountCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimCreateNestedManyWithoutUserInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutUserNotificationsInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @Field(() => AccountCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimCreateNestedManyWithoutUserInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateWithoutWithdrawalRequestInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @Field(() => AccountCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserCreateInput {
    @HideField()
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @HideField()
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @HideField()
    referralCode!: string;
    @HideField()
    status?: keyof typeof UserStatus;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => AddressCreateNestedOneWithoutUserInput, {nullable:false})
    address!: InstanceType<typeof AddressCreateNestedOneWithoutUserInput>;
    @Field(() => UserCreateNestedOneWithoutReferredUsersInput, {nullable:true})
    referredBy?: InstanceType<typeof UserCreateNestedOneWithoutReferredUsersInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserCreateNestedManyWithoutReferredByInput>;
    @HideField()
    checkIns?: InstanceType<typeof CheckInCreateNestedManyWithoutUserInput>;
    @Field(() => SchoolCreateNestedOneWithoutStudentsInput, {nullable:true})
    school?: InstanceType<typeof SchoolCreateNestedOneWithoutStudentsInput>;
    @Field(() => AccountCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionCreateNestedManyWithoutUserInput>;
    @HideField()
    orders?: InstanceType<typeof OrderCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionCreateNestedManyWithoutUserInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    programsParticipation?: InstanceType<typeof ProgramCreateNestedManyWithoutParticipantInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimCreateNestedManyWithoutUserInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationCreateNestedManyWithoutUserInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileCreateNestedManyWithoutCreatedByInput>;
}

@ArgsType()
export class UserGroupByArgs {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => [UserOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<UserOrderByWithAggregationInput>;
    @Field(() => [UserScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof UserScalarFieldEnum>;
    @Field(() => UserScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof UserScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => UserCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof UserCountAggregateInput>;
    @Field(() => UserAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof UserAvgAggregateInput>;
    @Field(() => UserSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof UserSumAggregateInput>;
    @Field(() => UserMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof UserMinAggregateInput>;
    @Field(() => UserMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof UserMaxAggregateInput>;
}

@ObjectType()
export class UserGroupBy {
    @Field(() => String, {nullable:false})
    id!: string;
    @Field(() => String, {nullable:false})
    firstName!: string;
    @Field(() => String, {nullable:true})
    lastName?: string;
    @Field(() => String, {nullable:false})
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:false})
    userRole!: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @HideField()
    password!: string;
    @Field(() => String, {nullable:false})
    referralCode!: string;
    @Field(() => String, {nullable:true})
    referredById?: string;
    @Field(() => UserStatus, {nullable:false})
    status!: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:false})
    theme!: keyof typeof Theme;
    @Field(() => UserCountAggregate, {nullable:true})
    _count?: InstanceType<typeof UserCountAggregate>;
    @Field(() => UserAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof UserAvgAggregate>;
    @Field(() => UserSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof UserSumAggregate>;
    @Field(() => UserMinAggregate, {nullable:true})
    _min?: InstanceType<typeof UserMinAggregate>;
    @Field(() => UserMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof UserMaxAggregate>;
}

@InputType()
export class UserListRelationFilter {
    @Field(() => UserWhereInput, {nullable:true})
    every?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereInput, {nullable:true})
    some?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereInput, {nullable:true})
    none?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    firstName?: true;
    @Field(() => Boolean, {nullable:true})
    lastName?: true;
    @Field(() => Boolean, {nullable:true})
    email?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    userRole?: true;
    @Field(() => Boolean, {nullable:true})
    userType?: true;
    @Field(() => Boolean, {nullable:true})
    avatarUrl?: true;
    @Field(() => Boolean, {nullable:true})
    whatsappNumber?: true;
    @Field(() => Boolean, {nullable:true})
    whatsappVerifiedAt?: true;
    @Field(() => Boolean, {nullable:true})
    password?: true;
    @Field(() => Boolean, {nullable:true})
    referralCode?: true;
    @HideField()
    referredById?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    schoolId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    deletedAt?: true;
    @Field(() => Boolean, {nullable:true})
    theme?: true;
}

@ObjectType()
export class UserMaxAggregate {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:true})
    firstName?: string;
    @Field(() => String, {nullable:true})
    lastName?: string;
    @Field(() => String, {nullable:true})
    email?: string;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:true})
    userType?: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    avatarUrl?: string;
    @Field(() => String, {nullable:true})
    whatsappNumber?: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @HideField()
    password?: string;
    @Field(() => String, {nullable:true})
    referralCode?: string;
    @Field(() => String, {nullable:true})
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
}

@InputType()
export class UserMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    firstName?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    lastName?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    email?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    avatarUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    whatsappNumber?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    whatsappVerifiedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    password?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    referralCode?: keyof typeof SortOrder;
    @HideField()
    referredById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    schoolId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    deletedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    theme?: keyof typeof SortOrder;
}

@InputType()
export class UserMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    firstName?: true;
    @Field(() => Boolean, {nullable:true})
    lastName?: true;
    @Field(() => Boolean, {nullable:true})
    email?: true;
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    userRole?: true;
    @Field(() => Boolean, {nullable:true})
    userType?: true;
    @Field(() => Boolean, {nullable:true})
    avatarUrl?: true;
    @Field(() => Boolean, {nullable:true})
    whatsappNumber?: true;
    @Field(() => Boolean, {nullable:true})
    whatsappVerifiedAt?: true;
    @Field(() => Boolean, {nullable:true})
    password?: true;
    @Field(() => Boolean, {nullable:true})
    referralCode?: true;
    @HideField()
    referredById?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    schoolId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    deletedAt?: true;
    @Field(() => Boolean, {nullable:true})
    theme?: true;
}

@ObjectType()
export class UserMinAggregate {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:true})
    firstName?: string;
    @Field(() => String, {nullable:true})
    lastName?: string;
    @Field(() => String, {nullable:true})
    email?: string;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:true})
    userType?: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    avatarUrl?: string;
    @Field(() => String, {nullable:true})
    whatsappNumber?: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @HideField()
    password?: string;
    @Field(() => String, {nullable:true})
    referralCode?: string;
    @Field(() => String, {nullable:true})
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
}

@InputType()
export class UserMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    firstName?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    lastName?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    email?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userType?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    avatarUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    whatsappNumber?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    whatsappVerifiedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    password?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    referralCode?: keyof typeof SortOrder;
    @HideField()
    referredById?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    schoolId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    deletedAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    theme?: keyof typeof SortOrder;
}

@InputType()
export class UserNullableRelationFilter {
    @Field(() => UserWhereInput, {nullable:true})
    is?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereInput, {nullable:true})
    isNot?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class UserOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    firstName?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    lastName?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    email?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userType?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    avatarUrl?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    whatsappNumber?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    password?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    referralCode?: keyof typeof SortOrder;
    @HideField()
    referredById?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    schoolId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    deletedAt?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    theme?: keyof typeof SortOrder;
    @Field(() => UserCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof UserCountOrderByAggregateInput>;
    @Field(() => UserAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof UserAvgOrderByAggregateInput>;
    @Field(() => UserMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof UserMaxOrderByAggregateInput>;
    @Field(() => UserMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof UserMinOrderByAggregateInput>;
    @Field(() => UserSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof UserSumOrderByAggregateInput>;
}

@InputType()
export class UserOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    firstName?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    lastName?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    email?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userRole?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userType?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    avatarUrl?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    whatsappNumber?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    password?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    referralCode?: keyof typeof SortOrder;
    @HideField()
    referredById?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    schoolId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    deletedAt?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    theme?: keyof typeof SortOrder;
    @Field(() => AddressOrderByWithRelationInput, {nullable:true})
    address?: InstanceType<typeof AddressOrderByWithRelationInput>;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    referredBy?: InstanceType<typeof UserOrderByWithRelationInput>;
    @Field(() => UserOrderByRelationAggregateInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserOrderByRelationAggregateInput>;
    @Field(() => CheckInOrderByRelationAggregateInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInOrderByRelationAggregateInput>;
    @Field(() => SchoolOrderByWithRelationInput, {nullable:true})
    school?: InstanceType<typeof SchoolOrderByWithRelationInput>;
    @Field(() => AccountOrderByRelationAggregateInput, {nullable:true})
    accounts?: InstanceType<typeof AccountOrderByRelationAggregateInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionOrderByRelationAggregateInput>;
    @Field(() => OrderOrderByRelationAggregateInput, {nullable:true})
    orders?: InstanceType<typeof OrderOrderByRelationAggregateInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionOrderByRelationAggregateInput>;
    @Field(() => HotelOrderByRelationAggregateInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelOrderByRelationAggregateInput>;
    @Field(() => ProgramOrderByRelationAggregateInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramOrderByRelationAggregateInput>;
    @Field(() => RewardClaimOrderByRelationAggregateInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimOrderByRelationAggregateInput>;
    @Field(() => WithdrawalRequestOrderByRelationAggregateInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestOrderByRelationAggregateInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationOrderByRelationAggregateInput>;
    @Field(() => ProgramOrderByRelationAggregateInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramOrderByRelationAggregateInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileOrderByRelationAggregateInput>;
}

@InputType()
export class UserRelationFilter {
    @Field(() => UserWhereInput, {nullable:true})
    is?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereInput, {nullable:true})
    isNot?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserScalarWhereWithAggregatesInput {
    @Field(() => [UserScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<UserScalarWhereWithAggregatesInput>;
    @Field(() => [UserScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<UserScalarWhereWithAggregatesInput>;
    @Field(() => [UserScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<UserScalarWhereWithAggregatesInput>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    firstName?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringNullableWithAggregatesFilter, {nullable:true})
    lastName?: InstanceType<typeof StringNullableWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    email?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    addressId?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => EnumUserRoleWithAggregatesFilter, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleWithAggregatesFilter>;
    @Field(() => EnumUserTypeWithAggregatesFilter, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeWithAggregatesFilter>;
    @Field(() => StringNullableWithAggregatesFilter, {nullable:true})
    avatarUrl?: InstanceType<typeof StringNullableWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeNullableWithAggregatesFilter, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof DateTimeNullableWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    password?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    referralCode?: InstanceType<typeof StringWithAggregatesFilter>;
    @HideField()
    referredById?: InstanceType<typeof StringNullableWithAggregatesFilter>;
    @Field(() => EnumUserStatusWithAggregatesFilter, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusWithAggregatesFilter>;
    @Field(() => IntNullableWithAggregatesFilter, {nullable:true})
    schoolId?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeNullableWithAggregatesFilter, {nullable:true})
    deletedAt?: InstanceType<typeof DateTimeNullableWithAggregatesFilter>;
    @Field(() => EnumThemeWithAggregatesFilter, {nullable:true})
    theme?: InstanceType<typeof EnumThemeWithAggregatesFilter>;
}

@InputType()
export class UserScalarWhereInput {
    @Field(() => [UserScalarWhereInput], {nullable:true})
    AND?: Array<UserScalarWhereInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    OR?: Array<UserScalarWhereInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    NOT?: Array<UserScalarWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    id?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    firstName?: InstanceType<typeof StringFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    lastName?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    email?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    addressId?: InstanceType<typeof IntFilter>;
    @Field(() => EnumUserRoleFilter, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFilter>;
    @Field(() => EnumUserTypeFilter, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    avatarUrl?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeNullableFilter, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    password?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    referralCode?: InstanceType<typeof StringFilter>;
    @HideField()
    referredById?: InstanceType<typeof StringNullableFilter>;
    @Field(() => EnumUserStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    schoolId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeNullableFilter, {nullable:true})
    deletedAt?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => EnumThemeFilter, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFilter>;
}

@InputType()
export class UserSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    addressId?: true;
    @Field(() => Boolean, {nullable:true})
    schoolId?: true;
}

@ObjectType()
export class UserSumAggregate {
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
}

@InputType()
export class UserSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    addressId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    schoolId?: keyof typeof SortOrder;
}

@InputType()
export class UserUncheckedCreateNestedManyWithoutProgramsParticipationInput {
    @Field(() => [UserCreateWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserCreateWithoutProgramsParticipationInput)
    create?: Array<UserCreateWithoutProgramsParticipationInput>;
    @Field(() => [UserCreateOrConnectWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutProgramsParticipationInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutProgramsParticipationInput>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
}

@InputType()
export class UserUncheckedCreateNestedManyWithoutReferredByInput {
    @Field(() => [UserCreateWithoutReferredByInput], {nullable:true})
    @Type(() => UserCreateWithoutReferredByInput)
    create?: Array<UserCreateWithoutReferredByInput>;
    @Field(() => [UserCreateOrConnectWithoutReferredByInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutReferredByInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutReferredByInput>;
    @Field(() => UserCreateManyReferredByInputEnvelope, {nullable:true})
    @Type(() => UserCreateManyReferredByInputEnvelope)
    createMany?: InstanceType<typeof UserCreateManyReferredByInputEnvelope>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
}

@InputType()
export class UserUncheckedCreateNestedManyWithoutSchoolInput {
    @Field(() => [UserCreateWithoutSchoolInput], {nullable:true})
    @Type(() => UserCreateWithoutSchoolInput)
    create?: Array<UserCreateWithoutSchoolInput>;
    @Field(() => [UserCreateOrConnectWithoutSchoolInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutSchoolInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutSchoolInput>;
    @Field(() => UserCreateManySchoolInputEnvelope, {nullable:true})
    @Type(() => UserCreateManySchoolInputEnvelope)
    createMany?: InstanceType<typeof UserCreateManySchoolInputEnvelope>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
}

@InputType()
export class UserUncheckedCreateNestedOneWithoutAddressInput {
    @Field(() => UserCreateWithoutAddressInput, {nullable:true})
    @Type(() => UserCreateWithoutAddressInput)
    create?: InstanceType<typeof UserCreateWithoutAddressInput>;
    @Field(() => UserCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutAddressInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
}

@InputType()
export class UserUncheckedCreateWithoutAccountsInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @Field(() => String, {nullable:false})
    referralCode!: string;
    @HideField()
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => OrderUncheckedCreateNestedManyWithoutOrderByInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => HotelUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutParticipantInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @Field(() => RewardClaimUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutAddressInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @Field(() => String, {nullable:false})
    referralCode!: string;
    @HideField()
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => AccountUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => OrderUncheckedCreateNestedManyWithoutOrderByInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => HotelUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutParticipantInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @Field(() => RewardClaimUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutCheckInsInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @Field(() => String, {nullable:false})
    referralCode!: string;
    @HideField()
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => AccountUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => OrderUncheckedCreateNestedManyWithoutOrderByInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => HotelUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutParticipantInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @Field(() => RewardClaimUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutClaimedRewardsInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @Field(() => String, {nullable:false})
    referralCode!: string;
    @HideField()
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => AccountUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => OrderUncheckedCreateNestedManyWithoutOrderByInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => HotelUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutParticipantInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @Field(() => WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutFilesCreatedInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @Field(() => String, {nullable:false})
    referralCode!: string;
    @HideField()
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => AccountUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => OrderUncheckedCreateNestedManyWithoutOrderByInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => HotelUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutParticipantInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @Field(() => RewardClaimUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutHotelsCreatedInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @Field(() => String, {nullable:false})
    referralCode!: string;
    @HideField()
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => AccountUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => OrderUncheckedCreateNestedManyWithoutOrderByInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutParticipantInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @Field(() => RewardClaimUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutOrdersInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @Field(() => String, {nullable:false})
    referralCode!: string;
    @HideField()
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => AccountUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => HotelUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutParticipantInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @Field(() => RewardClaimUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutPointTransactionsInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @Field(() => String, {nullable:false})
    referralCode!: string;
    @HideField()
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => AccountUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => OrderUncheckedCreateNestedManyWithoutOrderByInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => HotelUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutParticipantInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @Field(() => RewardClaimUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutProgramsCreatedInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @Field(() => String, {nullable:false})
    referralCode!: string;
    @HideField()
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => AccountUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => OrderUncheckedCreateNestedManyWithoutOrderByInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => HotelUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutParticipantInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @Field(() => RewardClaimUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutProgramsParticipationInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @Field(() => String, {nullable:false})
    referralCode!: string;
    @HideField()
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => AccountUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => OrderUncheckedCreateNestedManyWithoutOrderByInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => HotelUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @Field(() => RewardClaimUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutReferredByInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @Field(() => String, {nullable:false})
    referralCode!: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => AccountUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => OrderUncheckedCreateNestedManyWithoutOrderByInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => HotelUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutParticipantInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @Field(() => RewardClaimUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutReferredUsersInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @Field(() => String, {nullable:false})
    referralCode!: string;
    @HideField()
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => AccountUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => OrderUncheckedCreateNestedManyWithoutOrderByInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => HotelUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutParticipantInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @Field(() => RewardClaimUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutSchoolInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @Field(() => String, {nullable:false})
    referralCode!: string;
    @HideField()
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => AccountUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => OrderUncheckedCreateNestedManyWithoutOrderByInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => HotelUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutParticipantInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @Field(() => RewardClaimUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutSessionsInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @Field(() => String, {nullable:false})
    referralCode!: string;
    @HideField()
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => AccountUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => OrderUncheckedCreateNestedManyWithoutOrderByInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @Field(() => HotelUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutParticipantInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @Field(() => RewardClaimUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutUserNotificationsInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @Field(() => String, {nullable:false})
    referralCode!: string;
    @HideField()
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => AccountUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => OrderUncheckedCreateNestedManyWithoutOrderByInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => HotelUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutParticipantInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @Field(() => RewardClaimUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateWithoutWithdrawalRequestInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @Field(() => String, {nullable:false})
    referralCode!: string;
    @HideField()
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => AccountUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => OrderUncheckedCreateNestedManyWithoutOrderByInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => HotelUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutParticipantInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @Field(() => RewardClaimUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedCreateInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    firstName!: string;
    @Field(() => String, {nullable:true})
    @Validator.MinLength(2)
    @Validator.MaxLength(20)
    @Validator.IsAlpha()
    @Validator.IsNotEmpty()
    lastName?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsEmail()
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:true})
    userRole?: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    @Validator.IsUrl({ require_protocol: true })
    avatarUrl?: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt?: Date | string;
    @Field(() => String, {nullable:false})
    @Validator.MinLength(6)
    @Validator.MaxLength(15)
    @Validator.IsAlphanumeric()
    password!: string;
    @Field(() => String, {nullable:false})
    referralCode!: string;
    @HideField()
    referredById?: string;
    @Field(() => UserStatus, {nullable:true})
    status?: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => Date, {nullable:true})
    deletedAt?: Date | string;
    @Field(() => Theme, {nullable:true})
    theme?: keyof typeof Theme;
    @Field(() => UserUncheckedCreateNestedManyWithoutReferredByInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutReferredByInput>;
    @Field(() => CheckInUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => AccountUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => OrderUncheckedCreateNestedManyWithoutOrderByInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedCreateNestedManyWithoutOrderByInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => HotelUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedCreateNestedManyWithoutCreatedByInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutParticipantInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutParticipantInput>;
    @Field(() => RewardClaimUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedCreateNestedManyWithoutUserInput>;
    @Field(() => ProgramUncheckedCreateNestedManyWithoutCreatedByInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedCreateNestedManyWithoutCreatedByInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedCreateNestedManyWithoutCreatedByInput>;
}

@InputType()
export class UserUncheckedUpdateManyWithoutProgramsParticipationNestedInput {
    @Field(() => [UserCreateWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserCreateWithoutProgramsParticipationInput)
    create?: Array<UserCreateWithoutProgramsParticipationInput>;
    @Field(() => [UserCreateOrConnectWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutProgramsParticipationInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutProgramsParticipationInput>;
    @Field(() => [UserUpsertWithWhereUniqueWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserUpsertWithWhereUniqueWithoutProgramsParticipationInput)
    upsert?: Array<UserUpsertWithWhereUniqueWithoutProgramsParticipationInput>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserUpdateWithWhereUniqueWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserUpdateWithWhereUniqueWithoutProgramsParticipationInput)
    update?: Array<UserUpdateWithWhereUniqueWithoutProgramsParticipationInput>;
    @Field(() => [UserUpdateManyWithWhereWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserUpdateManyWithWhereWithoutProgramsParticipationInput)
    updateMany?: Array<UserUpdateManyWithWhereWithoutProgramsParticipationInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    @Type(() => UserScalarWhereInput)
    deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUncheckedUpdateManyWithoutProgramsParticipationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
}

@InputType()
export class UserUncheckedUpdateManyWithoutReferredByNestedInput {
    @Field(() => [UserCreateWithoutReferredByInput], {nullable:true})
    @Type(() => UserCreateWithoutReferredByInput)
    create?: Array<UserCreateWithoutReferredByInput>;
    @Field(() => [UserCreateOrConnectWithoutReferredByInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutReferredByInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutReferredByInput>;
    @Field(() => [UserUpsertWithWhereUniqueWithoutReferredByInput], {nullable:true})
    @Type(() => UserUpsertWithWhereUniqueWithoutReferredByInput)
    upsert?: Array<UserUpsertWithWhereUniqueWithoutReferredByInput>;
    @Field(() => UserCreateManyReferredByInputEnvelope, {nullable:true})
    @Type(() => UserCreateManyReferredByInputEnvelope)
    createMany?: InstanceType<typeof UserCreateManyReferredByInputEnvelope>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserUpdateWithWhereUniqueWithoutReferredByInput], {nullable:true})
    @Type(() => UserUpdateWithWhereUniqueWithoutReferredByInput)
    update?: Array<UserUpdateWithWhereUniqueWithoutReferredByInput>;
    @Field(() => [UserUpdateManyWithWhereWithoutReferredByInput], {nullable:true})
    @Type(() => UserUpdateManyWithWhereWithoutReferredByInput)
    updateMany?: Array<UserUpdateManyWithWhereWithoutReferredByInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    @Type(() => UserScalarWhereInput)
    deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUncheckedUpdateManyWithoutReferredByInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
}

@InputType()
export class UserUncheckedUpdateManyWithoutSchoolNestedInput {
    @Field(() => [UserCreateWithoutSchoolInput], {nullable:true})
    @Type(() => UserCreateWithoutSchoolInput)
    create?: Array<UserCreateWithoutSchoolInput>;
    @Field(() => [UserCreateOrConnectWithoutSchoolInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutSchoolInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutSchoolInput>;
    @Field(() => [UserUpsertWithWhereUniqueWithoutSchoolInput], {nullable:true})
    @Type(() => UserUpsertWithWhereUniqueWithoutSchoolInput)
    upsert?: Array<UserUpsertWithWhereUniqueWithoutSchoolInput>;
    @Field(() => UserCreateManySchoolInputEnvelope, {nullable:true})
    @Type(() => UserCreateManySchoolInputEnvelope)
    createMany?: InstanceType<typeof UserCreateManySchoolInputEnvelope>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserUpdateWithWhereUniqueWithoutSchoolInput], {nullable:true})
    @Type(() => UserUpdateWithWhereUniqueWithoutSchoolInput)
    update?: Array<UserUpdateWithWhereUniqueWithoutSchoolInput>;
    @Field(() => [UserUpdateManyWithWhereWithoutSchoolInput], {nullable:true})
    @Type(() => UserUpdateManyWithWhereWithoutSchoolInput)
    updateMany?: Array<UserUpdateManyWithWhereWithoutSchoolInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    @Type(() => UserScalarWhereInput)
    deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUncheckedUpdateManyWithoutSchoolInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
}

@InputType()
export class UserUncheckedUpdateManyInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
}

@InputType()
export class UserUncheckedUpdateOneWithoutAddressNestedInput {
    @Field(() => UserCreateWithoutAddressInput, {nullable:true})
    @Type(() => UserCreateWithoutAddressInput)
    create?: InstanceType<typeof UserCreateWithoutAddressInput>;
    @Field(() => UserCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutAddressInput>;
    @Field(() => UserUpsertWithoutAddressInput, {nullable:true})
    @Type(() => UserUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof UserUpsertWithoutAddressInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    disconnect?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    delete?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutAccountsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => OrderUncheckedUpdateManyWithoutOrderByNestedInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => HotelUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @Field(() => RewardClaimUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutAddressInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => AccountUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => OrderUncheckedUpdateManyWithoutOrderByNestedInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => HotelUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @Field(() => RewardClaimUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutCheckInsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => AccountUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => OrderUncheckedUpdateManyWithoutOrderByNestedInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => HotelUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @Field(() => RewardClaimUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutClaimedRewardsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => AccountUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => OrderUncheckedUpdateManyWithoutOrderByNestedInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => HotelUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @Field(() => WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutFilesCreatedInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => AccountUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => OrderUncheckedUpdateManyWithoutOrderByNestedInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => HotelUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @Field(() => RewardClaimUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutHotelsCreatedInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => AccountUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => OrderUncheckedUpdateManyWithoutOrderByNestedInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @Field(() => RewardClaimUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutOrdersInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => AccountUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => HotelUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @Field(() => RewardClaimUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutPointTransactionsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => AccountUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => OrderUncheckedUpdateManyWithoutOrderByNestedInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => HotelUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @Field(() => RewardClaimUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutProgramsCreatedInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => AccountUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => OrderUncheckedUpdateManyWithoutOrderByNestedInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => HotelUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @Field(() => RewardClaimUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutProgramsParticipationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => AccountUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => OrderUncheckedUpdateManyWithoutOrderByNestedInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => HotelUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => RewardClaimUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutReferredByInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => AccountUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => OrderUncheckedUpdateManyWithoutOrderByNestedInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => HotelUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @Field(() => RewardClaimUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutReferredUsersInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => AccountUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => OrderUncheckedUpdateManyWithoutOrderByNestedInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => HotelUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @Field(() => RewardClaimUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutSchoolInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => AccountUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => OrderUncheckedUpdateManyWithoutOrderByNestedInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => HotelUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @Field(() => RewardClaimUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutSessionsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => AccountUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => OrderUncheckedUpdateManyWithoutOrderByNestedInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @Field(() => HotelUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @Field(() => RewardClaimUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutUserNotificationsInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => AccountUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => OrderUncheckedUpdateManyWithoutOrderByNestedInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => HotelUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @Field(() => RewardClaimUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutWithdrawalRequestInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => AccountUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => OrderUncheckedUpdateManyWithoutOrderByNestedInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => HotelUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @Field(() => RewardClaimUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUncheckedUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    addressId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => EnumUserRoleFieldUpdateOperationsInput, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referredById?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    schoolId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => UserUncheckedUpdateManyWithoutReferredByNestedInput, {nullable:true})
    referredUsers?: InstanceType<typeof UserUncheckedUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => AccountUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    accounts?: InstanceType<typeof AccountUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => OrderUncheckedUpdateManyWithoutOrderByNestedInput, {nullable:true})
    orders?: InstanceType<typeof OrderUncheckedUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => HotelUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutParticipantNestedInput>;
    @Field(() => RewardClaimUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUncheckedUpdateManyWithoutUserNestedInput>;
    @Field(() => ProgramUncheckedUpdateManyWithoutCreatedByNestedInput, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramUncheckedUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUncheckedUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateManyMutationInput {
    @HideField()
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
}

@InputType()
export class UserUpdateManyWithWhereWithoutProgramsParticipationInput {
    @Field(() => UserScalarWhereInput, {nullable:false})
    @Type(() => UserScalarWhereInput)
    where!: InstanceType<typeof UserScalarWhereInput>;
    @Field(() => UserUpdateManyMutationInput, {nullable:false})
    @Type(() => UserUpdateManyMutationInput)
    data!: InstanceType<typeof UserUpdateManyMutationInput>;
}

@InputType()
export class UserUpdateManyWithWhereWithoutReferredByInput {
    @Field(() => UserScalarWhereInput, {nullable:false})
    @Type(() => UserScalarWhereInput)
    where!: InstanceType<typeof UserScalarWhereInput>;
    @Field(() => UserUpdateManyMutationInput, {nullable:false})
    @Type(() => UserUpdateManyMutationInput)
    data!: InstanceType<typeof UserUpdateManyMutationInput>;
}

@InputType()
export class UserUpdateManyWithWhereWithoutSchoolInput {
    @Field(() => UserScalarWhereInput, {nullable:false})
    @Type(() => UserScalarWhereInput)
    where!: InstanceType<typeof UserScalarWhereInput>;
    @Field(() => UserUpdateManyMutationInput, {nullable:false})
    @Type(() => UserUpdateManyMutationInput)
    data!: InstanceType<typeof UserUpdateManyMutationInput>;
}

@InputType()
export class UserUpdateManyWithoutProgramsParticipationNestedInput {
    @Field(() => [UserCreateWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserCreateWithoutProgramsParticipationInput)
    create?: Array<UserCreateWithoutProgramsParticipationInput>;
    @Field(() => [UserCreateOrConnectWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutProgramsParticipationInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutProgramsParticipationInput>;
    @Field(() => [UserUpsertWithWhereUniqueWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserUpsertWithWhereUniqueWithoutProgramsParticipationInput)
    upsert?: Array<UserUpsertWithWhereUniqueWithoutProgramsParticipationInput>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserUpdateWithWhereUniqueWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserUpdateWithWhereUniqueWithoutProgramsParticipationInput)
    update?: Array<UserUpdateWithWhereUniqueWithoutProgramsParticipationInput>;
    @Field(() => [UserUpdateManyWithWhereWithoutProgramsParticipationInput], {nullable:true})
    @Type(() => UserUpdateManyWithWhereWithoutProgramsParticipationInput)
    updateMany?: Array<UserUpdateManyWithWhereWithoutProgramsParticipationInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    @Type(() => UserScalarWhereInput)
    deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUpdateManyWithoutReferredByNestedInput {
    @Field(() => [UserCreateWithoutReferredByInput], {nullable:true})
    @Type(() => UserCreateWithoutReferredByInput)
    create?: Array<UserCreateWithoutReferredByInput>;
    @Field(() => [UserCreateOrConnectWithoutReferredByInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutReferredByInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutReferredByInput>;
    @Field(() => [UserUpsertWithWhereUniqueWithoutReferredByInput], {nullable:true})
    @Type(() => UserUpsertWithWhereUniqueWithoutReferredByInput)
    upsert?: Array<UserUpsertWithWhereUniqueWithoutReferredByInput>;
    @Field(() => UserCreateManyReferredByInputEnvelope, {nullable:true})
    @Type(() => UserCreateManyReferredByInputEnvelope)
    createMany?: InstanceType<typeof UserCreateManyReferredByInputEnvelope>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserUpdateWithWhereUniqueWithoutReferredByInput], {nullable:true})
    @Type(() => UserUpdateWithWhereUniqueWithoutReferredByInput)
    update?: Array<UserUpdateWithWhereUniqueWithoutReferredByInput>;
    @Field(() => [UserUpdateManyWithWhereWithoutReferredByInput], {nullable:true})
    @Type(() => UserUpdateManyWithWhereWithoutReferredByInput)
    updateMany?: Array<UserUpdateManyWithWhereWithoutReferredByInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    @Type(() => UserScalarWhereInput)
    deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUpdateManyWithoutSchoolNestedInput {
    @Field(() => [UserCreateWithoutSchoolInput], {nullable:true})
    @Type(() => UserCreateWithoutSchoolInput)
    create?: Array<UserCreateWithoutSchoolInput>;
    @Field(() => [UserCreateOrConnectWithoutSchoolInput], {nullable:true})
    @Type(() => UserCreateOrConnectWithoutSchoolInput)
    connectOrCreate?: Array<UserCreateOrConnectWithoutSchoolInput>;
    @Field(() => [UserUpsertWithWhereUniqueWithoutSchoolInput], {nullable:true})
    @Type(() => UserUpsertWithWhereUniqueWithoutSchoolInput)
    upsert?: Array<UserUpsertWithWhereUniqueWithoutSchoolInput>;
    @Field(() => UserCreateManySchoolInputEnvelope, {nullable:true})
    @Type(() => UserCreateManySchoolInputEnvelope)
    createMany?: InstanceType<typeof UserCreateManySchoolInputEnvelope>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserWhereUniqueInput], {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>>;
    @Field(() => [UserUpdateWithWhereUniqueWithoutSchoolInput], {nullable:true})
    @Type(() => UserUpdateWithWhereUniqueWithoutSchoolInput)
    update?: Array<UserUpdateWithWhereUniqueWithoutSchoolInput>;
    @Field(() => [UserUpdateManyWithWhereWithoutSchoolInput], {nullable:true})
    @Type(() => UserUpdateManyWithWhereWithoutSchoolInput)
    updateMany?: Array<UserUpdateManyWithWhereWithoutSchoolInput>;
    @Field(() => [UserScalarWhereInput], {nullable:true})
    @Type(() => UserScalarWhereInput)
    deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutAccountsNestedInput {
    @Field(() => UserCreateWithoutAccountsInput, {nullable:true})
    @Type(() => UserCreateWithoutAccountsInput)
    create?: InstanceType<typeof UserCreateWithoutAccountsInput>;
    @Field(() => UserCreateOrConnectWithoutAccountsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutAccountsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutAccountsInput>;
    @Field(() => UserUpsertWithoutAccountsInput, {nullable:true})
    @Type(() => UserUpsertWithoutAccountsInput)
    upsert?: InstanceType<typeof UserUpsertWithoutAccountsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateToOneWithWhereWithoutAccountsInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutAccountsInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutAccountsInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutCheckInsNestedInput {
    @Field(() => UserCreateWithoutCheckInsInput, {nullable:true})
    @Type(() => UserCreateWithoutCheckInsInput)
    create?: InstanceType<typeof UserCreateWithoutCheckInsInput>;
    @Field(() => UserCreateOrConnectWithoutCheckInsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutCheckInsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutCheckInsInput>;
    @Field(() => UserUpsertWithoutCheckInsInput, {nullable:true})
    @Type(() => UserUpsertWithoutCheckInsInput)
    upsert?: InstanceType<typeof UserUpsertWithoutCheckInsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateToOneWithWhereWithoutCheckInsInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutCheckInsInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutCheckInsInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutClaimedRewardsNestedInput {
    @Field(() => UserCreateWithoutClaimedRewardsInput, {nullable:true})
    @Type(() => UserCreateWithoutClaimedRewardsInput)
    create?: InstanceType<typeof UserCreateWithoutClaimedRewardsInput>;
    @Field(() => UserCreateOrConnectWithoutClaimedRewardsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutClaimedRewardsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutClaimedRewardsInput>;
    @Field(() => UserUpsertWithoutClaimedRewardsInput, {nullable:true})
    @Type(() => UserUpsertWithoutClaimedRewardsInput)
    upsert?: InstanceType<typeof UserUpsertWithoutClaimedRewardsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateToOneWithWhereWithoutClaimedRewardsInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutClaimedRewardsInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutClaimedRewardsInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutFilesCreatedNestedInput {
    @Field(() => UserCreateWithoutFilesCreatedInput, {nullable:true})
    @Type(() => UserCreateWithoutFilesCreatedInput)
    create?: InstanceType<typeof UserCreateWithoutFilesCreatedInput>;
    @Field(() => UserCreateOrConnectWithoutFilesCreatedInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutFilesCreatedInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutFilesCreatedInput>;
    @Field(() => UserUpsertWithoutFilesCreatedInput, {nullable:true})
    @Type(() => UserUpsertWithoutFilesCreatedInput)
    upsert?: InstanceType<typeof UserUpsertWithoutFilesCreatedInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateToOneWithWhereWithoutFilesCreatedInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutFilesCreatedInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutFilesCreatedInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutHotelsCreatedNestedInput {
    @Field(() => UserCreateWithoutHotelsCreatedInput, {nullable:true})
    @Type(() => UserCreateWithoutHotelsCreatedInput)
    create?: InstanceType<typeof UserCreateWithoutHotelsCreatedInput>;
    @Field(() => UserCreateOrConnectWithoutHotelsCreatedInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutHotelsCreatedInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutHotelsCreatedInput>;
    @Field(() => UserUpsertWithoutHotelsCreatedInput, {nullable:true})
    @Type(() => UserUpsertWithoutHotelsCreatedInput)
    upsert?: InstanceType<typeof UserUpsertWithoutHotelsCreatedInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateToOneWithWhereWithoutHotelsCreatedInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutHotelsCreatedInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutHotelsCreatedInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutOrdersNestedInput {
    @Field(() => UserCreateWithoutOrdersInput, {nullable:true})
    @Type(() => UserCreateWithoutOrdersInput)
    create?: InstanceType<typeof UserCreateWithoutOrdersInput>;
    @Field(() => UserCreateOrConnectWithoutOrdersInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutOrdersInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutOrdersInput>;
    @Field(() => UserUpsertWithoutOrdersInput, {nullable:true})
    @Type(() => UserUpsertWithoutOrdersInput)
    upsert?: InstanceType<typeof UserUpsertWithoutOrdersInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateToOneWithWhereWithoutOrdersInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutOrdersInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutOrdersInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutPointTransactionsNestedInput {
    @Field(() => UserCreateWithoutPointTransactionsInput, {nullable:true})
    @Type(() => UserCreateWithoutPointTransactionsInput)
    create?: InstanceType<typeof UserCreateWithoutPointTransactionsInput>;
    @Field(() => UserCreateOrConnectWithoutPointTransactionsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutPointTransactionsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutPointTransactionsInput>;
    @Field(() => UserUpsertWithoutPointTransactionsInput, {nullable:true})
    @Type(() => UserUpsertWithoutPointTransactionsInput)
    upsert?: InstanceType<typeof UserUpsertWithoutPointTransactionsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateToOneWithWhereWithoutPointTransactionsInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutPointTransactionsInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutPointTransactionsInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutProgramsCreatedNestedInput {
    @Field(() => UserCreateWithoutProgramsCreatedInput, {nullable:true})
    @Type(() => UserCreateWithoutProgramsCreatedInput)
    create?: InstanceType<typeof UserCreateWithoutProgramsCreatedInput>;
    @Field(() => UserCreateOrConnectWithoutProgramsCreatedInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutProgramsCreatedInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutProgramsCreatedInput>;
    @Field(() => UserUpsertWithoutProgramsCreatedInput, {nullable:true})
    @Type(() => UserUpsertWithoutProgramsCreatedInput)
    upsert?: InstanceType<typeof UserUpsertWithoutProgramsCreatedInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateToOneWithWhereWithoutProgramsCreatedInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutProgramsCreatedInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutProgramsCreatedInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutSessionsNestedInput {
    @Field(() => UserCreateWithoutSessionsInput, {nullable:true})
    @Type(() => UserCreateWithoutSessionsInput)
    create?: InstanceType<typeof UserCreateWithoutSessionsInput>;
    @Field(() => UserCreateOrConnectWithoutSessionsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutSessionsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutSessionsInput>;
    @Field(() => UserUpsertWithoutSessionsInput, {nullable:true})
    @Type(() => UserUpsertWithoutSessionsInput)
    upsert?: InstanceType<typeof UserUpsertWithoutSessionsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateToOneWithWhereWithoutSessionsInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutSessionsInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutSessionsInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutUserNotificationsNestedInput {
    @Field(() => UserCreateWithoutUserNotificationsInput, {nullable:true})
    @Type(() => UserCreateWithoutUserNotificationsInput)
    create?: InstanceType<typeof UserCreateWithoutUserNotificationsInput>;
    @Field(() => UserCreateOrConnectWithoutUserNotificationsInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutUserNotificationsInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutUserNotificationsInput>;
    @Field(() => UserUpsertWithoutUserNotificationsInput, {nullable:true})
    @Type(() => UserUpsertWithoutUserNotificationsInput)
    upsert?: InstanceType<typeof UserUpsertWithoutUserNotificationsInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateToOneWithWhereWithoutUserNotificationsInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutUserNotificationsInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutUserNotificationsInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutWithdrawalRequestNestedInput {
    @Field(() => UserCreateWithoutWithdrawalRequestInput, {nullable:true})
    @Type(() => UserCreateWithoutWithdrawalRequestInput)
    create?: InstanceType<typeof UserCreateWithoutWithdrawalRequestInput>;
    @Field(() => UserCreateOrConnectWithoutWithdrawalRequestInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutWithdrawalRequestInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutWithdrawalRequestInput>;
    @Field(() => UserUpsertWithoutWithdrawalRequestInput, {nullable:true})
    @Type(() => UserUpsertWithoutWithdrawalRequestInput)
    upsert?: InstanceType<typeof UserUpsertWithoutWithdrawalRequestInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateToOneWithWhereWithoutWithdrawalRequestInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutWithdrawalRequestInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutWithdrawalRequestInput>;
}

@InputType()
export class UserUpdateOneWithoutAddressNestedInput {
    @Field(() => UserCreateWithoutAddressInput, {nullable:true})
    @Type(() => UserCreateWithoutAddressInput)
    create?: InstanceType<typeof UserCreateWithoutAddressInput>;
    @Field(() => UserCreateOrConnectWithoutAddressInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutAddressInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutAddressInput>;
    @Field(() => UserUpsertWithoutAddressInput, {nullable:true})
    @Type(() => UserUpsertWithoutAddressInput)
    upsert?: InstanceType<typeof UserUpsertWithoutAddressInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    disconnect?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    delete?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateToOneWithWhereWithoutAddressInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutAddressInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutAddressInput>;
}

@InputType()
export class UserUpdateOneWithoutReferredUsersNestedInput {
    @Field(() => UserCreateWithoutReferredUsersInput, {nullable:true})
    @Type(() => UserCreateWithoutReferredUsersInput)
    create?: InstanceType<typeof UserCreateWithoutReferredUsersInput>;
    @Field(() => UserCreateOrConnectWithoutReferredUsersInput, {nullable:true})
    @Type(() => UserCreateOrConnectWithoutReferredUsersInput)
    connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutReferredUsersInput>;
    @Field(() => UserUpsertWithoutReferredUsersInput, {nullable:true})
    @Type(() => UserUpsertWithoutReferredUsersInput)
    upsert?: InstanceType<typeof UserUpsertWithoutReferredUsersInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    disconnect?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    delete?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserWhereUniqueInput, {nullable:true})
    @Type(() => UserWhereUniqueInput)
    connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateToOneWithWhereWithoutReferredUsersInput, {nullable:true})
    @Type(() => UserUpdateToOneWithWhereWithoutReferredUsersInput)
    update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutReferredUsersInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutAccountsInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutAccountsInput, {nullable:false})
    @Type(() => UserUpdateWithoutAccountsInput)
    data!: InstanceType<typeof UserUpdateWithoutAccountsInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutAddressInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutAddressInput, {nullable:false})
    @Type(() => UserUpdateWithoutAddressInput)
    data!: InstanceType<typeof UserUpdateWithoutAddressInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutCheckInsInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutCheckInsInput, {nullable:false})
    @Type(() => UserUpdateWithoutCheckInsInput)
    data!: InstanceType<typeof UserUpdateWithoutCheckInsInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutClaimedRewardsInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutClaimedRewardsInput, {nullable:false})
    @Type(() => UserUpdateWithoutClaimedRewardsInput)
    data!: InstanceType<typeof UserUpdateWithoutClaimedRewardsInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutFilesCreatedInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutFilesCreatedInput, {nullable:false})
    @Type(() => UserUpdateWithoutFilesCreatedInput)
    data!: InstanceType<typeof UserUpdateWithoutFilesCreatedInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutHotelsCreatedInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutHotelsCreatedInput, {nullable:false})
    @Type(() => UserUpdateWithoutHotelsCreatedInput)
    data!: InstanceType<typeof UserUpdateWithoutHotelsCreatedInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutOrdersInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutOrdersInput, {nullable:false})
    @Type(() => UserUpdateWithoutOrdersInput)
    data!: InstanceType<typeof UserUpdateWithoutOrdersInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutPointTransactionsInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutPointTransactionsInput, {nullable:false})
    @Type(() => UserUpdateWithoutPointTransactionsInput)
    data!: InstanceType<typeof UserUpdateWithoutPointTransactionsInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutProgramsCreatedInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutProgramsCreatedInput, {nullable:false})
    @Type(() => UserUpdateWithoutProgramsCreatedInput)
    data!: InstanceType<typeof UserUpdateWithoutProgramsCreatedInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutReferredUsersInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutReferredUsersInput, {nullable:false})
    @Type(() => UserUpdateWithoutReferredUsersInput)
    data!: InstanceType<typeof UserUpdateWithoutReferredUsersInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutSessionsInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutSessionsInput, {nullable:false})
    @Type(() => UserUpdateWithoutSessionsInput)
    data!: InstanceType<typeof UserUpdateWithoutSessionsInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutUserNotificationsInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutUserNotificationsInput, {nullable:false})
    @Type(() => UserUpdateWithoutUserNotificationsInput)
    data!: InstanceType<typeof UserUpdateWithoutUserNotificationsInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutWithdrawalRequestInput {
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
    @Field(() => UserUpdateWithoutWithdrawalRequestInput, {nullable:false})
    @Type(() => UserUpdateWithoutWithdrawalRequestInput)
    data!: InstanceType<typeof UserUpdateWithoutWithdrawalRequestInput>;
}

@InputType()
export class UserUpdateWithWhereUniqueWithoutProgramsParticipationInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateWithoutProgramsParticipationInput, {nullable:false})
    @Type(() => UserUpdateWithoutProgramsParticipationInput)
    data!: InstanceType<typeof UserUpdateWithoutProgramsParticipationInput>;
}

@InputType()
export class UserUpdateWithWhereUniqueWithoutReferredByInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateWithoutReferredByInput, {nullable:false})
    @Type(() => UserUpdateWithoutReferredByInput)
    data!: InstanceType<typeof UserUpdateWithoutReferredByInput>;
}

@InputType()
export class UserUpdateWithWhereUniqueWithoutSchoolInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateWithoutSchoolInput, {nullable:false})
    @Type(() => UserUpdateWithoutSchoolInput)
    data!: InstanceType<typeof UserUpdateWithoutSchoolInput>;
}

@InputType()
export class UserUpdateWithoutAccountsInput {
    @HideField()
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @HideField()
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimUpdateManyWithoutUserNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutAddressInput {
    @HideField()
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @HideField()
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimUpdateManyWithoutUserNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutCheckInsInput {
    @HideField()
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @HideField()
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimUpdateManyWithoutUserNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutClaimedRewardsInput {
    @HideField()
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @HideField()
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutFilesCreatedInput {
    @HideField()
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @HideField()
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimUpdateManyWithoutUserNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutHotelsCreatedInput {
    @HideField()
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @HideField()
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @Field(() => ProgramUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimUpdateManyWithoutUserNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutOrdersInput {
    @HideField()
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @HideField()
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimUpdateManyWithoutUserNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutPointTransactionsInput {
    @HideField()
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @HideField()
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimUpdateManyWithoutUserNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutProgramsCreatedInput {
    @HideField()
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @HideField()
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimUpdateManyWithoutUserNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutProgramsParticipationInput {
    @HideField()
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @HideField()
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimUpdateManyWithoutUserNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutReferredByInput {
    @HideField()
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimUpdateManyWithoutUserNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutReferredUsersInput {
    @HideField()
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @HideField()
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimUpdateManyWithoutUserNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutSchoolInput {
    @HideField()
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @HideField()
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimUpdateManyWithoutUserNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutSessionsInput {
    @HideField()
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @HideField()
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimUpdateManyWithoutUserNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutUserNotificationsInput {
    @HideField()
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @HideField()
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimUpdateManyWithoutUserNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateWithoutWithdrawalRequestInput {
    @HideField()
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @HideField()
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpdateInput {
    @HideField()
    id?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    firstName?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    lastName?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    userRole?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
    @Field(() => EnumUserTypeFieldUpdateOperationsInput, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    avatarUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableDateTimeFieldUpdateOperationsInput, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    password?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @HideField()
    referralCode?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => EnumUserStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    deletedAt?: InstanceType<typeof NullableDateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumThemeFieldUpdateOperationsInput, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFieldUpdateOperationsInput>;
    @Field(() => AddressUpdateOneRequiredWithoutUserNestedInput, {nullable:true})
    address?: InstanceType<typeof AddressUpdateOneRequiredWithoutUserNestedInput>;
    @HideField()
    referredBy?: InstanceType<typeof UserUpdateOneWithoutReferredUsersNestedInput>;
    @HideField()
    referredUsers?: InstanceType<typeof UserUpdateManyWithoutReferredByNestedInput>;
    @Field(() => CheckInUpdateManyWithoutUserNestedInput, {nullable:true})
    checkIns?: InstanceType<typeof CheckInUpdateManyWithoutUserNestedInput>;
    @Field(() => SchoolUpdateOneWithoutStudentsNestedInput, {nullable:true})
    school?: InstanceType<typeof SchoolUpdateOneWithoutStudentsNestedInput>;
    @HideField()
    accounts?: InstanceType<typeof AccountUpdateManyWithoutUserNestedInput>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionUpdateManyWithoutUserNestedInput>;
    @HideField()
    orders?: InstanceType<typeof OrderUpdateManyWithoutOrderByNestedInput>;
    @HideField()
    sessions?: InstanceType<typeof SessionUpdateManyWithoutUserNestedInput>;
    @HideField()
    hotelsCreated?: InstanceType<typeof HotelUpdateManyWithoutCreatedByNestedInput>;
    @Field(() => ProgramUpdateManyWithoutParticipantNestedInput, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramUpdateManyWithoutParticipantNestedInput>;
    @HideField()
    claimedRewards?: InstanceType<typeof RewardClaimUpdateManyWithoutUserNestedInput>;
    @HideField()
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestUpdateManyWithoutUserNestedInput>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationUpdateManyWithoutUserNestedInput>;
    @HideField()
    programsCreated?: InstanceType<typeof ProgramUpdateManyWithoutCreatedByNestedInput>;
    @HideField()
    filesCreated?: InstanceType<typeof FileUpdateManyWithoutCreatedByNestedInput>;
}

@InputType()
export class UserUpsertWithWhereUniqueWithoutProgramsParticipationInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateWithoutProgramsParticipationInput, {nullable:false})
    @Type(() => UserUpdateWithoutProgramsParticipationInput)
    update!: InstanceType<typeof UserUpdateWithoutProgramsParticipationInput>;
    @Field(() => UserCreateWithoutProgramsParticipationInput, {nullable:false})
    @Type(() => UserCreateWithoutProgramsParticipationInput)
    create!: InstanceType<typeof UserCreateWithoutProgramsParticipationInput>;
}

@InputType()
export class UserUpsertWithWhereUniqueWithoutReferredByInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateWithoutReferredByInput, {nullable:false})
    @Type(() => UserUpdateWithoutReferredByInput)
    update!: InstanceType<typeof UserUpdateWithoutReferredByInput>;
    @Field(() => UserCreateWithoutReferredByInput, {nullable:false})
    @Type(() => UserCreateWithoutReferredByInput)
    create!: InstanceType<typeof UserCreateWithoutReferredByInput>;
}

@InputType()
export class UserUpsertWithWhereUniqueWithoutSchoolInput {
    @Field(() => UserWhereUniqueInput, {nullable:false})
    @Type(() => UserWhereUniqueInput)
    where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email' | 'addressId' | 'whatsappNumber' | 'referralCode'>;
    @Field(() => UserUpdateWithoutSchoolInput, {nullable:false})
    @Type(() => UserUpdateWithoutSchoolInput)
    update!: InstanceType<typeof UserUpdateWithoutSchoolInput>;
    @Field(() => UserCreateWithoutSchoolInput, {nullable:false})
    @Type(() => UserCreateWithoutSchoolInput)
    create!: InstanceType<typeof UserCreateWithoutSchoolInput>;
}

@InputType()
export class UserUpsertWithoutAccountsInput {
    @Field(() => UserUpdateWithoutAccountsInput, {nullable:false})
    @Type(() => UserUpdateWithoutAccountsInput)
    update!: InstanceType<typeof UserUpdateWithoutAccountsInput>;
    @Field(() => UserCreateWithoutAccountsInput, {nullable:false})
    @Type(() => UserCreateWithoutAccountsInput)
    create!: InstanceType<typeof UserCreateWithoutAccountsInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutAddressInput {
    @Field(() => UserUpdateWithoutAddressInput, {nullable:false})
    @Type(() => UserUpdateWithoutAddressInput)
    update!: InstanceType<typeof UserUpdateWithoutAddressInput>;
    @Field(() => UserCreateWithoutAddressInput, {nullable:false})
    @Type(() => UserCreateWithoutAddressInput)
    create!: InstanceType<typeof UserCreateWithoutAddressInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutCheckInsInput {
    @Field(() => UserUpdateWithoutCheckInsInput, {nullable:false})
    @Type(() => UserUpdateWithoutCheckInsInput)
    update!: InstanceType<typeof UserUpdateWithoutCheckInsInput>;
    @Field(() => UserCreateWithoutCheckInsInput, {nullable:false})
    @Type(() => UserCreateWithoutCheckInsInput)
    create!: InstanceType<typeof UserCreateWithoutCheckInsInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutClaimedRewardsInput {
    @Field(() => UserUpdateWithoutClaimedRewardsInput, {nullable:false})
    @Type(() => UserUpdateWithoutClaimedRewardsInput)
    update!: InstanceType<typeof UserUpdateWithoutClaimedRewardsInput>;
    @Field(() => UserCreateWithoutClaimedRewardsInput, {nullable:false})
    @Type(() => UserCreateWithoutClaimedRewardsInput)
    create!: InstanceType<typeof UserCreateWithoutClaimedRewardsInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutFilesCreatedInput {
    @Field(() => UserUpdateWithoutFilesCreatedInput, {nullable:false})
    @Type(() => UserUpdateWithoutFilesCreatedInput)
    update!: InstanceType<typeof UserUpdateWithoutFilesCreatedInput>;
    @Field(() => UserCreateWithoutFilesCreatedInput, {nullable:false})
    @Type(() => UserCreateWithoutFilesCreatedInput)
    create!: InstanceType<typeof UserCreateWithoutFilesCreatedInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutHotelsCreatedInput {
    @Field(() => UserUpdateWithoutHotelsCreatedInput, {nullable:false})
    @Type(() => UserUpdateWithoutHotelsCreatedInput)
    update!: InstanceType<typeof UserUpdateWithoutHotelsCreatedInput>;
    @Field(() => UserCreateWithoutHotelsCreatedInput, {nullable:false})
    @Type(() => UserCreateWithoutHotelsCreatedInput)
    create!: InstanceType<typeof UserCreateWithoutHotelsCreatedInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutOrdersInput {
    @Field(() => UserUpdateWithoutOrdersInput, {nullable:false})
    @Type(() => UserUpdateWithoutOrdersInput)
    update!: InstanceType<typeof UserUpdateWithoutOrdersInput>;
    @Field(() => UserCreateWithoutOrdersInput, {nullable:false})
    @Type(() => UserCreateWithoutOrdersInput)
    create!: InstanceType<typeof UserCreateWithoutOrdersInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutPointTransactionsInput {
    @Field(() => UserUpdateWithoutPointTransactionsInput, {nullable:false})
    @Type(() => UserUpdateWithoutPointTransactionsInput)
    update!: InstanceType<typeof UserUpdateWithoutPointTransactionsInput>;
    @Field(() => UserCreateWithoutPointTransactionsInput, {nullable:false})
    @Type(() => UserCreateWithoutPointTransactionsInput)
    create!: InstanceType<typeof UserCreateWithoutPointTransactionsInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutProgramsCreatedInput {
    @Field(() => UserUpdateWithoutProgramsCreatedInput, {nullable:false})
    @Type(() => UserUpdateWithoutProgramsCreatedInput)
    update!: InstanceType<typeof UserUpdateWithoutProgramsCreatedInput>;
    @Field(() => UserCreateWithoutProgramsCreatedInput, {nullable:false})
    @Type(() => UserCreateWithoutProgramsCreatedInput)
    create!: InstanceType<typeof UserCreateWithoutProgramsCreatedInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutReferredUsersInput {
    @Field(() => UserUpdateWithoutReferredUsersInput, {nullable:false})
    @Type(() => UserUpdateWithoutReferredUsersInput)
    update!: InstanceType<typeof UserUpdateWithoutReferredUsersInput>;
    @Field(() => UserCreateWithoutReferredUsersInput, {nullable:false})
    @Type(() => UserCreateWithoutReferredUsersInput)
    create!: InstanceType<typeof UserCreateWithoutReferredUsersInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutSessionsInput {
    @Field(() => UserUpdateWithoutSessionsInput, {nullable:false})
    @Type(() => UserUpdateWithoutSessionsInput)
    update!: InstanceType<typeof UserUpdateWithoutSessionsInput>;
    @Field(() => UserCreateWithoutSessionsInput, {nullable:false})
    @Type(() => UserCreateWithoutSessionsInput)
    create!: InstanceType<typeof UserCreateWithoutSessionsInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutUserNotificationsInput {
    @Field(() => UserUpdateWithoutUserNotificationsInput, {nullable:false})
    @Type(() => UserUpdateWithoutUserNotificationsInput)
    update!: InstanceType<typeof UserUpdateWithoutUserNotificationsInput>;
    @Field(() => UserCreateWithoutUserNotificationsInput, {nullable:false})
    @Type(() => UserCreateWithoutUserNotificationsInput)
    create!: InstanceType<typeof UserCreateWithoutUserNotificationsInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutWithdrawalRequestInput {
    @Field(() => UserUpdateWithoutWithdrawalRequestInput, {nullable:false})
    @Type(() => UserUpdateWithoutWithdrawalRequestInput)
    update!: InstanceType<typeof UserUpdateWithoutWithdrawalRequestInput>;
    @Field(() => UserCreateWithoutWithdrawalRequestInput, {nullable:false})
    @Type(() => UserCreateWithoutWithdrawalRequestInput)
    create!: InstanceType<typeof UserCreateWithoutWithdrawalRequestInput>;
    @Field(() => UserWhereInput, {nullable:true})
    @Type(() => UserWhereInput)
    where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserWhereUniqueInput {
    @Field(() => String, {nullable:true})
    id?: string;
    @Field(() => String, {nullable:true})
    @Validator.IsEmail()
    email?: string;
    @Field(() => Int, {nullable:true})
    addressId?: number;
    @Field(() => String, {nullable:true})
    @Validator.IsNotEmpty()
    whatsappNumber?: string;
    @Field(() => String, {nullable:true})
    referralCode?: string;
    @Field(() => [UserWhereInput], {nullable:true})
    AND?: Array<UserWhereInput>;
    @Field(() => [UserWhereInput], {nullable:true})
    OR?: Array<UserWhereInput>;
    @Field(() => [UserWhereInput], {nullable:true})
    NOT?: Array<UserWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    firstName?: InstanceType<typeof StringFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    lastName?: InstanceType<typeof StringNullableFilter>;
    @Field(() => EnumUserRoleFilter, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFilter>;
    @Field(() => EnumUserTypeFilter, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    avatarUrl?: InstanceType<typeof StringNullableFilter>;
    @Field(() => DateTimeNullableFilter, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    password?: InstanceType<typeof StringFilter>;
    @HideField()
    referredById?: InstanceType<typeof StringNullableFilter>;
    @Field(() => EnumUserStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    schoolId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeNullableFilter, {nullable:true})
    deletedAt?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => EnumThemeFilter, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFilter>;
    @Field(() => AddressRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressRelationFilter>;
    @Field(() => UserNullableRelationFilter, {nullable:true})
    referredBy?: InstanceType<typeof UserNullableRelationFilter>;
    @Field(() => UserListRelationFilter, {nullable:true})
    referredUsers?: InstanceType<typeof UserListRelationFilter>;
    @Field(() => CheckInListRelationFilter, {nullable:true})
    checkIns?: InstanceType<typeof CheckInListRelationFilter>;
    @Field(() => SchoolNullableRelationFilter, {nullable:true})
    school?: InstanceType<typeof SchoolNullableRelationFilter>;
    @Field(() => AccountListRelationFilter, {nullable:true})
    accounts?: InstanceType<typeof AccountListRelationFilter>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionListRelationFilter>;
    @Field(() => OrderListRelationFilter, {nullable:true})
    orders?: InstanceType<typeof OrderListRelationFilter>;
    @HideField()
    sessions?: InstanceType<typeof SessionListRelationFilter>;
    @Field(() => HotelListRelationFilter, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelListRelationFilter>;
    @Field(() => ProgramListRelationFilter, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramListRelationFilter>;
    @Field(() => RewardClaimListRelationFilter, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimListRelationFilter>;
    @Field(() => WithdrawalRequestListRelationFilter, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestListRelationFilter>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationListRelationFilter>;
    @Field(() => ProgramListRelationFilter, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramListRelationFilter>;
    @HideField()
    filesCreated?: InstanceType<typeof FileListRelationFilter>;
}

@InputType()
export class UserWhereInput {
    @Field(() => [UserWhereInput], {nullable:true})
    AND?: Array<UserWhereInput>;
    @Field(() => [UserWhereInput], {nullable:true})
    OR?: Array<UserWhereInput>;
    @Field(() => [UserWhereInput], {nullable:true})
    NOT?: Array<UserWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    id?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    firstName?: InstanceType<typeof StringFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    lastName?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    email?: InstanceType<typeof StringFilter>;
    @Field(() => IntFilter, {nullable:true})
    addressId?: InstanceType<typeof IntFilter>;
    @Field(() => EnumUserRoleFilter, {nullable:true})
    userRole?: InstanceType<typeof EnumUserRoleFilter>;
    @Field(() => EnumUserTypeFilter, {nullable:true})
    userType?: InstanceType<typeof EnumUserTypeFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    avatarUrl?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    whatsappNumber?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeNullableFilter, {nullable:true})
    whatsappVerifiedAt?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => StringFilter, {nullable:true})
    password?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    referralCode?: InstanceType<typeof StringFilter>;
    @HideField()
    referredById?: InstanceType<typeof StringNullableFilter>;
    @Field(() => EnumUserStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumUserStatusFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    schoolId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeNullableFilter, {nullable:true})
    deletedAt?: InstanceType<typeof DateTimeNullableFilter>;
    @Field(() => EnumThemeFilter, {nullable:true})
    theme?: InstanceType<typeof EnumThemeFilter>;
    @Field(() => AddressRelationFilter, {nullable:true})
    address?: InstanceType<typeof AddressRelationFilter>;
    @Field(() => UserNullableRelationFilter, {nullable:true})
    referredBy?: InstanceType<typeof UserNullableRelationFilter>;
    @Field(() => UserListRelationFilter, {nullable:true})
    referredUsers?: InstanceType<typeof UserListRelationFilter>;
    @Field(() => CheckInListRelationFilter, {nullable:true})
    checkIns?: InstanceType<typeof CheckInListRelationFilter>;
    @Field(() => SchoolNullableRelationFilter, {nullable:true})
    school?: InstanceType<typeof SchoolNullableRelationFilter>;
    @Field(() => AccountListRelationFilter, {nullable:true})
    accounts?: InstanceType<typeof AccountListRelationFilter>;
    @HideField()
    PointTransactions?: InstanceType<typeof PointTransactionListRelationFilter>;
    @Field(() => OrderListRelationFilter, {nullable:true})
    orders?: InstanceType<typeof OrderListRelationFilter>;
    @HideField()
    sessions?: InstanceType<typeof SessionListRelationFilter>;
    @Field(() => HotelListRelationFilter, {nullable:true})
    hotelsCreated?: InstanceType<typeof HotelListRelationFilter>;
    @Field(() => ProgramListRelationFilter, {nullable:true})
    programsParticipation?: InstanceType<typeof ProgramListRelationFilter>;
    @Field(() => RewardClaimListRelationFilter, {nullable:true})
    claimedRewards?: InstanceType<typeof RewardClaimListRelationFilter>;
    @Field(() => WithdrawalRequestListRelationFilter, {nullable:true})
    withdrawalRequest?: InstanceType<typeof WithdrawalRequestListRelationFilter>;
    @HideField()
    userNotifications?: InstanceType<typeof UserNotificationListRelationFilter>;
    @Field(() => ProgramListRelationFilter, {nullable:true})
    programsCreated?: InstanceType<typeof ProgramListRelationFilter>;
    @HideField()
    filesCreated?: InstanceType<typeof FileListRelationFilter>;
}

/** @ /O/b/j/e/c/t/T/y/p/e('UserAbstract', { isAbstract: true }) */
@ObjectType({description:"@/O/b/j/e/c/t/T/y/p/e('UserAbstract', { isAbstract: true })"})
export class User {
    @Field(() => String, {nullable:false})
    id!: string;
    @Field(() => String, {nullable:false})
    firstName!: string;
    @Field(() => String, {nullable:true})
    lastName!: string | null;
    @Field(() => String, {nullable:false})
    email!: string;
    @Field(() => Int, {nullable:false})
    addressId!: number;
    @Field(() => UserRole, {nullable:false,defaultValue:'MEMBER'})
    userRole!: keyof typeof UserRole;
    @Field(() => UserType, {nullable:false})
    userType!: keyof typeof UserType;
    @Field(() => String, {nullable:true})
    avatarUrl!: string | null;
    @Field(() => String, {nullable:false})
    whatsappNumber!: string;
    @Field(() => Date, {nullable:true})
    whatsappVerifiedAt!: Date | null;
    @HideField()
    password!: string;
    @Field(() => String, {nullable:false})
    referralCode!: string;
    @Field(() => String, {nullable:true})
    referredById!: string | null;
    @Field(() => UserStatus, {nullable:false,defaultValue:'PENDING'})
    status!: keyof typeof UserStatus;
    @Field(() => Int, {nullable:true})
    schoolId!: number | null;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => Date, {nullable:true})
    deletedAt!: Date | null;
    @Field(() => Theme, {nullable:false,defaultValue:'LIGHT'})
    theme!: keyof typeof Theme;
    /** @Validator .IsNotEmpty(g */
    @Field(() => Address, {nullable:false,description:'@Validator.IsNotEmpty(g'})
    address?: InstanceType<typeof Address>;
    @Field(() => User, {nullable:true})
    referredBy?: InstanceType<typeof User> | null;
    @Field(() => [User], {nullable:true})
    referredUsers?: Array<User>;
    @Field(() => [CheckIn], {nullable:true})
    checkIns?: Array<CheckIn>;
    @Field(() => School, {nullable:true})
    school?: InstanceType<typeof School> | null;
    @Field(() => [Account], {nullable:true})
    accounts?: Array<Account>;
    @Field(() => [PointTransaction], {nullable:true})
    PointTransactions?: Array<PointTransaction>;
    @Field(() => [Order], {nullable:true})
    orders?: Array<Order>;
    @Field(() => [Session], {nullable:true})
    sessions?: Array<Session>;
    @Field(() => [Hotel], {nullable:true})
    hotelsCreated?: Array<Hotel>;
    @Field(() => [Program], {nullable:true})
    programsParticipation?: Array<Program>;
    @Field(() => [RewardClaim], {nullable:true})
    claimedRewards?: Array<RewardClaim>;
    @Field(() => [WithdrawalRequest], {nullable:true})
    withdrawalRequest?: Array<WithdrawalRequest>;
    @Field(() => [UserNotification], {nullable:true})
    userNotifications?: Array<UserNotification>;
    @Field(() => [Program], {nullable:true})
    programsCreated?: Array<Program>;
    @Field(() => [File], {nullable:true})
    filesCreated?: Array<File>;
    @Field(() => UserCount, {nullable:false})
    _count?: InstanceType<typeof UserCount>;
}

@ObjectType()
export class AggregateUserNotification {
    @Field(() => UserNotificationCountAggregate, {nullable:true})
    _count?: InstanceType<typeof UserNotificationCountAggregate>;
    @Field(() => UserNotificationAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof UserNotificationAvgAggregate>;
    @Field(() => UserNotificationSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof UserNotificationSumAggregate>;
    @Field(() => UserNotificationMinAggregate, {nullable:true})
    _min?: InstanceType<typeof UserNotificationMinAggregate>;
    @Field(() => UserNotificationMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof UserNotificationMaxAggregate>;
}

@ArgsType()
export class CreateManyUserNotificationArgs {
    @Field(() => [UserNotificationCreateManyInput], {nullable:false})
    @Type(() => UserNotificationCreateManyInput)
    data!: Array<UserNotificationCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneUserNotificationArgs {
    @Field(() => UserNotificationCreateInput, {nullable:false})
    @Type(() => UserNotificationCreateInput)
    data!: InstanceType<typeof UserNotificationCreateInput>;
}

@ArgsType()
export class DeleteManyUserNotificationArgs {
    @Field(() => UserNotificationWhereInput, {nullable:true})
    @Type(() => UserNotificationWhereInput)
    where?: InstanceType<typeof UserNotificationWhereInput>;
}

@ArgsType()
export class DeleteOneUserNotificationArgs {
    @Field(() => UserNotificationWhereUniqueInput, {nullable:false})
    @Type(() => UserNotificationWhereUniqueInput)
    where!: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstUserNotificationOrThrowArgs {
    @Field(() => UserNotificationWhereInput, {nullable:true})
    @Type(() => UserNotificationWhereInput)
    where?: InstanceType<typeof UserNotificationWhereInput>;
    @Field(() => [UserNotificationOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<UserNotificationOrderByWithRelationInput>;
    @Field(() => UserNotificationWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [UserNotificationScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof UserNotificationScalarFieldEnum>;
}

@ArgsType()
export class FindFirstUserNotificationArgs {
    @Field(() => UserNotificationWhereInput, {nullable:true})
    @Type(() => UserNotificationWhereInput)
    where?: InstanceType<typeof UserNotificationWhereInput>;
    @Field(() => [UserNotificationOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<UserNotificationOrderByWithRelationInput>;
    @Field(() => UserNotificationWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [UserNotificationScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof UserNotificationScalarFieldEnum>;
}

@ArgsType()
export class FindManyUserNotificationArgs {
    @Field(() => UserNotificationWhereInput, {nullable:true})
    @Type(() => UserNotificationWhereInput)
    where?: InstanceType<typeof UserNotificationWhereInput>;
    @Field(() => [UserNotificationOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<UserNotificationOrderByWithRelationInput>;
    @Field(() => UserNotificationWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [UserNotificationScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof UserNotificationScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueUserNotificationOrThrowArgs {
    @Field(() => UserNotificationWhereUniqueInput, {nullable:false})
    @Type(() => UserNotificationWhereUniqueInput)
    where!: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueUserNotificationArgs {
    @Field(() => UserNotificationWhereUniqueInput, {nullable:false})
    @Type(() => UserNotificationWhereUniqueInput)
    where!: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpdateManyUserNotificationArgs {
    @Field(() => UserNotificationUpdateManyMutationInput, {nullable:false})
    @Type(() => UserNotificationUpdateManyMutationInput)
    data!: InstanceType<typeof UserNotificationUpdateManyMutationInput>;
    @Field(() => UserNotificationWhereInput, {nullable:true})
    @Type(() => UserNotificationWhereInput)
    where?: InstanceType<typeof UserNotificationWhereInput>;
}

@ArgsType()
export class UpdateOneUserNotificationArgs {
    @Field(() => UserNotificationUpdateInput, {nullable:false})
    @Type(() => UserNotificationUpdateInput)
    data!: InstanceType<typeof UserNotificationUpdateInput>;
    @Field(() => UserNotificationWhereUniqueInput, {nullable:false})
    @Type(() => UserNotificationWhereUniqueInput)
    where!: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneUserNotificationArgs {
    @Field(() => UserNotificationWhereUniqueInput, {nullable:false})
    @Type(() => UserNotificationWhereUniqueInput)
    where!: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
    @Field(() => UserNotificationCreateInput, {nullable:false})
    @Type(() => UserNotificationCreateInput)
    create!: InstanceType<typeof UserNotificationCreateInput>;
    @Field(() => UserNotificationUpdateInput, {nullable:false})
    @Type(() => UserNotificationUpdateInput)
    update!: InstanceType<typeof UserNotificationUpdateInput>;
}

@ArgsType()
export class UserNotificationAggregateArgs {
    @Field(() => UserNotificationWhereInput, {nullable:true})
    @Type(() => UserNotificationWhereInput)
    where?: InstanceType<typeof UserNotificationWhereInput>;
    @Field(() => [UserNotificationOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<UserNotificationOrderByWithRelationInput>;
    @Field(() => UserNotificationWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => UserNotificationCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof UserNotificationCountAggregateInput>;
    @Field(() => UserNotificationAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof UserNotificationAvgAggregateInput>;
    @Field(() => UserNotificationSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof UserNotificationSumAggregateInput>;
    @Field(() => UserNotificationMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof UserNotificationMinAggregateInput>;
    @Field(() => UserNotificationMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof UserNotificationMaxAggregateInput>;
}

@InputType()
export class UserNotificationAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
}

@ObjectType()
export class UserNotificationAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
}

@InputType()
export class UserNotificationAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
}

@InputType()
export class UserNotificationCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    title?: true;
    @Field(() => Boolean, {nullable:true})
    subtitle?: true;
    @Field(() => Boolean, {nullable:true})
    content?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    category?: true;
    @Field(() => Boolean, {nullable:true})
    isRead?: true;
    @Field(() => Boolean, {nullable:true})
    isCleared?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    deepLink?: true;
    @Field(() => Boolean, {nullable:true})
    fcmToken?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class UserNotificationCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    title!: number;
    @Field(() => Int, {nullable:false})
    subtitle!: number;
    @Field(() => Int, {nullable:false})
    content!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    category!: number;
    @Field(() => Int, {nullable:false})
    isRead!: number;
    @Field(() => Int, {nullable:false})
    isCleared!: number;
    @Field(() => Int, {nullable:false})
    userId!: number;
    @Field(() => Int, {nullable:false})
    deepLink!: number;
    @Field(() => Int, {nullable:false})
    fcmToken!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class UserNotificationCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    title?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    subtitle?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    content?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    category?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isRead?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isCleared?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    deepLink?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fcmToken?: keyof typeof SortOrder;
}

@InputType()
export class UserNotificationCreateManyUserInputEnvelope {
    @Field(() => [UserNotificationCreateManyUserInput], {nullable:false})
    @Type(() => UserNotificationCreateManyUserInput)
    data!: Array<UserNotificationCreateManyUserInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class UserNotificationCreateManyUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    title!: string;
    @Field(() => String, {nullable:false})
    subtitle!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    content!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserNotificationCategory, {nullable:false})
    category!: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:true})
    isRead?: boolean;
    @Field(() => Boolean, {nullable:true})
    isCleared?: boolean;
    @Field(() => String, {nullable:true})
    deepLink?: string;
    @Field(() => String, {nullable:true})
    fcmToken?: string;
}

@InputType()
export class UserNotificationCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    title!: string;
    @Field(() => String, {nullable:false})
    subtitle!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    content!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserNotificationCategory, {nullable:false})
    category!: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:true})
    isRead?: boolean;
    @Field(() => Boolean, {nullable:true})
    isCleared?: boolean;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => String, {nullable:true})
    deepLink?: string;
    @Field(() => String, {nullable:true})
    fcmToken?: string;
}

@InputType()
export class UserNotificationCreateNestedManyWithoutUserInput {
    @Field(() => [UserNotificationCreateWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationCreateWithoutUserInput)
    create?: Array<UserNotificationCreateWithoutUserInput>;
    @Field(() => [UserNotificationCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<UserNotificationCreateOrConnectWithoutUserInput>;
    @Field(() => UserNotificationCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => UserNotificationCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof UserNotificationCreateManyUserInputEnvelope>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
}

@InputType()
export class UserNotificationCreateOrConnectWithoutUserInput {
    @Field(() => UserNotificationWhereUniqueInput, {nullable:false})
    @Type(() => UserNotificationWhereUniqueInput)
    where!: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
    @Field(() => UserNotificationCreateWithoutUserInput, {nullable:false})
    @Type(() => UserNotificationCreateWithoutUserInput)
    create!: InstanceType<typeof UserNotificationCreateWithoutUserInput>;
}

@InputType()
export class UserNotificationCreateWithoutUserInput {
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    title!: string;
    @Field(() => String, {nullable:false})
    subtitle!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    content!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserNotificationCategory, {nullable:false})
    category!: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:true})
    isRead?: boolean;
    @Field(() => Boolean, {nullable:true})
    isCleared?: boolean;
    @Field(() => String, {nullable:true})
    deepLink?: string;
    @Field(() => String, {nullable:true})
    fcmToken?: string;
}

@InputType()
export class UserNotificationCreateInput {
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    title!: string;
    @Field(() => String, {nullable:false})
    subtitle!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    content!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserNotificationCategory, {nullable:false})
    category!: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:true})
    isRead?: boolean;
    @Field(() => Boolean, {nullable:true})
    isCleared?: boolean;
    @Field(() => String, {nullable:true})
    deepLink?: string;
    @Field(() => String, {nullable:true})
    fcmToken?: string;
    @Field(() => UserCreateNestedOneWithoutUserNotificationsInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutUserNotificationsInput>;
}

@ArgsType()
export class UserNotificationGroupByArgs {
    @Field(() => UserNotificationWhereInput, {nullable:true})
    @Type(() => UserNotificationWhereInput)
    where?: InstanceType<typeof UserNotificationWhereInput>;
    @Field(() => [UserNotificationOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<UserNotificationOrderByWithAggregationInput>;
    @Field(() => [UserNotificationScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof UserNotificationScalarFieldEnum>;
    @Field(() => UserNotificationScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof UserNotificationScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => UserNotificationCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof UserNotificationCountAggregateInput>;
    @Field(() => UserNotificationAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof UserNotificationAvgAggregateInput>;
    @Field(() => UserNotificationSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof UserNotificationSumAggregateInput>;
    @Field(() => UserNotificationMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof UserNotificationMinAggregateInput>;
    @Field(() => UserNotificationMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof UserNotificationMaxAggregateInput>;
}

@ObjectType()
export class UserNotificationGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    title!: string;
    @Field(() => String, {nullable:false})
    subtitle!: string;
    @Field(() => String, {nullable:false})
    content!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => UserNotificationCategory, {nullable:false})
    category!: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:false})
    isRead!: boolean;
    @Field(() => Boolean, {nullable:false})
    isCleared!: boolean;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => String, {nullable:true})
    deepLink?: string;
    @Field(() => String, {nullable:true})
    fcmToken?: string;
    @Field(() => UserNotificationCountAggregate, {nullable:true})
    _count?: InstanceType<typeof UserNotificationCountAggregate>;
    @Field(() => UserNotificationAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof UserNotificationAvgAggregate>;
    @Field(() => UserNotificationSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof UserNotificationSumAggregate>;
    @Field(() => UserNotificationMinAggregate, {nullable:true})
    _min?: InstanceType<typeof UserNotificationMinAggregate>;
    @Field(() => UserNotificationMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof UserNotificationMaxAggregate>;
}

@InputType()
export class UserNotificationListRelationFilter {
    @Field(() => UserNotificationWhereInput, {nullable:true})
    every?: InstanceType<typeof UserNotificationWhereInput>;
    @Field(() => UserNotificationWhereInput, {nullable:true})
    some?: InstanceType<typeof UserNotificationWhereInput>;
    @Field(() => UserNotificationWhereInput, {nullable:true})
    none?: InstanceType<typeof UserNotificationWhereInput>;
}

@InputType()
export class UserNotificationMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    title?: true;
    @Field(() => Boolean, {nullable:true})
    subtitle?: true;
    @Field(() => Boolean, {nullable:true})
    content?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    category?: true;
    @Field(() => Boolean, {nullable:true})
    isRead?: true;
    @Field(() => Boolean, {nullable:true})
    isCleared?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    deepLink?: true;
    @Field(() => Boolean, {nullable:true})
    fcmToken?: true;
}

@ObjectType()
export class UserNotificationMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    title?: string;
    @Field(() => String, {nullable:true})
    subtitle?: string;
    @Field(() => String, {nullable:true})
    content?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserNotificationCategory, {nullable:true})
    category?: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:true})
    isRead?: boolean;
    @Field(() => Boolean, {nullable:true})
    isCleared?: boolean;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => String, {nullable:true})
    deepLink?: string;
    @Field(() => String, {nullable:true})
    fcmToken?: string;
}

@InputType()
export class UserNotificationMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    title?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    subtitle?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    content?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    category?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isRead?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isCleared?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    deepLink?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fcmToken?: keyof typeof SortOrder;
}

@InputType()
export class UserNotificationMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    title?: true;
    @Field(() => Boolean, {nullable:true})
    subtitle?: true;
    @Field(() => Boolean, {nullable:true})
    content?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    category?: true;
    @Field(() => Boolean, {nullable:true})
    isRead?: true;
    @Field(() => Boolean, {nullable:true})
    isCleared?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    deepLink?: true;
    @Field(() => Boolean, {nullable:true})
    fcmToken?: true;
}

@ObjectType()
export class UserNotificationMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    title?: string;
    @Field(() => String, {nullable:true})
    subtitle?: string;
    @Field(() => String, {nullable:true})
    content?: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserNotificationCategory, {nullable:true})
    category?: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:true})
    isRead?: boolean;
    @Field(() => Boolean, {nullable:true})
    isCleared?: boolean;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => String, {nullable:true})
    deepLink?: string;
    @Field(() => String, {nullable:true})
    fcmToken?: string;
}

@InputType()
export class UserNotificationMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    title?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    subtitle?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    content?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    category?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isRead?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isCleared?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    deepLink?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    fcmToken?: keyof typeof SortOrder;
}

@InputType()
export class UserNotificationOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class UserNotificationOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    title?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    subtitle?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    content?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    category?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isRead?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isCleared?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    deepLink?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    fcmToken?: InstanceType<typeof SortOrderInput>;
    @Field(() => UserNotificationCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof UserNotificationCountOrderByAggregateInput>;
    @Field(() => UserNotificationAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof UserNotificationAvgOrderByAggregateInput>;
    @Field(() => UserNotificationMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof UserNotificationMaxOrderByAggregateInput>;
    @Field(() => UserNotificationMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof UserNotificationMinOrderByAggregateInput>;
    @Field(() => UserNotificationSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof UserNotificationSumOrderByAggregateInput>;
}

@InputType()
export class UserNotificationOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    title?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    subtitle?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    content?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    category?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isRead?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    isCleared?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    deepLink?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    fcmToken?: InstanceType<typeof SortOrderInput>;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    user?: InstanceType<typeof UserOrderByWithRelationInput>;
}

@InputType()
export class UserNotificationScalarWhereWithAggregatesInput {
    @Field(() => [UserNotificationScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<UserNotificationScalarWhereWithAggregatesInput>;
    @Field(() => [UserNotificationScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<UserNotificationScalarWhereWithAggregatesInput>;
    @Field(() => [UserNotificationScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<UserNotificationScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    title?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    subtitle?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    content?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => EnumUserNotificationCategoryWithAggregatesFilter, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryWithAggregatesFilter>;
    @Field(() => BoolWithAggregatesFilter, {nullable:true})
    isRead?: InstanceType<typeof BoolWithAggregatesFilter>;
    @Field(() => BoolWithAggregatesFilter, {nullable:true})
    isCleared?: InstanceType<typeof BoolWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    userId?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => StringNullableWithAggregatesFilter, {nullable:true})
    deepLink?: InstanceType<typeof StringNullableWithAggregatesFilter>;
    @Field(() => StringNullableWithAggregatesFilter, {nullable:true})
    fcmToken?: InstanceType<typeof StringNullableWithAggregatesFilter>;
}

@InputType()
export class UserNotificationScalarWhereInput {
    @Field(() => [UserNotificationScalarWhereInput], {nullable:true})
    AND?: Array<UserNotificationScalarWhereInput>;
    @Field(() => [UserNotificationScalarWhereInput], {nullable:true})
    OR?: Array<UserNotificationScalarWhereInput>;
    @Field(() => [UserNotificationScalarWhereInput], {nullable:true})
    NOT?: Array<UserNotificationScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    title?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    subtitle?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    content?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => EnumUserNotificationCategoryFilter, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFilter>;
    @Field(() => BoolFilter, {nullable:true})
    isRead?: InstanceType<typeof BoolFilter>;
    @Field(() => BoolFilter, {nullable:true})
    isCleared?: InstanceType<typeof BoolFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    deepLink?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    fcmToken?: InstanceType<typeof StringNullableFilter>;
}

@InputType()
export class UserNotificationSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
}

@ObjectType()
export class UserNotificationSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
}

@InputType()
export class UserNotificationSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
}

@InputType()
export class UserNotificationUncheckedCreateNestedManyWithoutUserInput {
    @Field(() => [UserNotificationCreateWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationCreateWithoutUserInput)
    create?: Array<UserNotificationCreateWithoutUserInput>;
    @Field(() => [UserNotificationCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<UserNotificationCreateOrConnectWithoutUserInput>;
    @Field(() => UserNotificationCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => UserNotificationCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof UserNotificationCreateManyUserInputEnvelope>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
}

@InputType()
export class UserNotificationUncheckedCreateWithoutUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    title!: string;
    @Field(() => String, {nullable:false})
    subtitle!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    content!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserNotificationCategory, {nullable:false})
    category!: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:true})
    isRead?: boolean;
    @Field(() => Boolean, {nullable:true})
    isCleared?: boolean;
    @Field(() => String, {nullable:true})
    deepLink?: string;
    @Field(() => String, {nullable:true})
    fcmToken?: string;
}

@InputType()
export class UserNotificationUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    title!: string;
    @Field(() => String, {nullable:false})
    subtitle!: string;
    @Field(() => String, {nullable:false})
    @Validator.IsNotEmpty()
    content!: string;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => UserNotificationCategory, {nullable:false})
    category!: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:true})
    isRead?: boolean;
    @Field(() => Boolean, {nullable:true})
    isCleared?: boolean;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => String, {nullable:true})
    deepLink?: string;
    @Field(() => String, {nullable:true})
    fcmToken?: string;
}

@InputType()
export class UserNotificationUncheckedUpdateManyWithoutUserNestedInput {
    @Field(() => [UserNotificationCreateWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationCreateWithoutUserInput)
    create?: Array<UserNotificationCreateWithoutUserInput>;
    @Field(() => [UserNotificationCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<UserNotificationCreateOrConnectWithoutUserInput>;
    @Field(() => [UserNotificationUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<UserNotificationUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => UserNotificationCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => UserNotificationCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof UserNotificationCreateManyUserInputEnvelope>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
    @Field(() => [UserNotificationUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<UserNotificationUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [UserNotificationUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<UserNotificationUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [UserNotificationScalarWhereInput], {nullable:true})
    @Type(() => UserNotificationScalarWhereInput)
    deleteMany?: Array<UserNotificationScalarWhereInput>;
}

@InputType()
export class UserNotificationUncheckedUpdateManyWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    subtitle?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    content?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumUserNotificationCategoryFieldUpdateOperationsInput, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isRead?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isCleared?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    deepLink?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    fcmToken?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
}

@InputType()
export class UserNotificationUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    subtitle?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    content?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumUserNotificationCategoryFieldUpdateOperationsInput, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isRead?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isCleared?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    deepLink?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    fcmToken?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
}

@InputType()
export class UserNotificationUncheckedUpdateWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    subtitle?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    content?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumUserNotificationCategoryFieldUpdateOperationsInput, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isRead?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isCleared?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    deepLink?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    fcmToken?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
}

@InputType()
export class UserNotificationUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    subtitle?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    content?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumUserNotificationCategoryFieldUpdateOperationsInput, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isRead?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isCleared?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    deepLink?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    fcmToken?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
}

@InputType()
export class UserNotificationUpdateManyMutationInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    subtitle?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    content?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumUserNotificationCategoryFieldUpdateOperationsInput, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isRead?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isCleared?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    deepLink?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    fcmToken?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
}

@InputType()
export class UserNotificationUpdateManyWithWhereWithoutUserInput {
    @Field(() => UserNotificationScalarWhereInput, {nullable:false})
    @Type(() => UserNotificationScalarWhereInput)
    where!: InstanceType<typeof UserNotificationScalarWhereInput>;
    @Field(() => UserNotificationUpdateManyMutationInput, {nullable:false})
    @Type(() => UserNotificationUpdateManyMutationInput)
    data!: InstanceType<typeof UserNotificationUpdateManyMutationInput>;
}

@InputType()
export class UserNotificationUpdateManyWithoutUserNestedInput {
    @Field(() => [UserNotificationCreateWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationCreateWithoutUserInput)
    create?: Array<UserNotificationCreateWithoutUserInput>;
    @Field(() => [UserNotificationCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<UserNotificationCreateOrConnectWithoutUserInput>;
    @Field(() => [UserNotificationUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<UserNotificationUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => UserNotificationCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => UserNotificationCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof UserNotificationCreateManyUserInputEnvelope>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    set?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
    @Field(() => [UserNotificationWhereUniqueInput], {nullable:true})
    @Type(() => UserNotificationWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>>;
    @Field(() => [UserNotificationUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<UserNotificationUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [UserNotificationUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => UserNotificationUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<UserNotificationUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [UserNotificationScalarWhereInput], {nullable:true})
    @Type(() => UserNotificationScalarWhereInput)
    deleteMany?: Array<UserNotificationScalarWhereInput>;
}

@InputType()
export class UserNotificationUpdateWithWhereUniqueWithoutUserInput {
    @Field(() => UserNotificationWhereUniqueInput, {nullable:false})
    @Type(() => UserNotificationWhereUniqueInput)
    where!: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
    @Field(() => UserNotificationUpdateWithoutUserInput, {nullable:false})
    @Type(() => UserNotificationUpdateWithoutUserInput)
    data!: InstanceType<typeof UserNotificationUpdateWithoutUserInput>;
}

@InputType()
export class UserNotificationUpdateWithoutUserInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    subtitle?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    content?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumUserNotificationCategoryFieldUpdateOperationsInput, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isRead?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isCleared?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    deepLink?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    fcmToken?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
}

@InputType()
export class UserNotificationUpdateInput {
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    subtitle?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    content?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => EnumUserNotificationCategoryFieldUpdateOperationsInput, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isRead?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => BoolFieldUpdateOperationsInput, {nullable:true})
    isCleared?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    deepLink?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    fcmToken?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => UserUpdateOneRequiredWithoutUserNotificationsNestedInput, {nullable:true})
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutUserNotificationsNestedInput>;
}

@InputType()
export class UserNotificationUpsertWithWhereUniqueWithoutUserInput {
    @Field(() => UserNotificationWhereUniqueInput, {nullable:false})
    @Type(() => UserNotificationWhereUniqueInput)
    where!: Prisma.AtLeast<UserNotificationWhereUniqueInput, 'id'>;
    @Field(() => UserNotificationUpdateWithoutUserInput, {nullable:false})
    @Type(() => UserNotificationUpdateWithoutUserInput)
    update!: InstanceType<typeof UserNotificationUpdateWithoutUserInput>;
    @Field(() => UserNotificationCreateWithoutUserInput, {nullable:false})
    @Type(() => UserNotificationCreateWithoutUserInput)
    create!: InstanceType<typeof UserNotificationCreateWithoutUserInput>;
}

@InputType()
export class UserNotificationWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [UserNotificationWhereInput], {nullable:true})
    AND?: Array<UserNotificationWhereInput>;
    @Field(() => [UserNotificationWhereInput], {nullable:true})
    OR?: Array<UserNotificationWhereInput>;
    @Field(() => [UserNotificationWhereInput], {nullable:true})
    NOT?: Array<UserNotificationWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    title?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    subtitle?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    content?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => EnumUserNotificationCategoryFilter, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFilter>;
    @Field(() => BoolFilter, {nullable:true})
    isRead?: InstanceType<typeof BoolFilter>;
    @Field(() => BoolFilter, {nullable:true})
    isCleared?: InstanceType<typeof BoolFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    deepLink?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    fcmToken?: InstanceType<typeof StringNullableFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
}

@InputType()
export class UserNotificationWhereInput {
    @Field(() => [UserNotificationWhereInput], {nullable:true})
    AND?: Array<UserNotificationWhereInput>;
    @Field(() => [UserNotificationWhereInput], {nullable:true})
    OR?: Array<UserNotificationWhereInput>;
    @Field(() => [UserNotificationWhereInput], {nullable:true})
    NOT?: Array<UserNotificationWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    title?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    subtitle?: InstanceType<typeof StringFilter>;
    @Field(() => StringFilter, {nullable:true})
    content?: InstanceType<typeof StringFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => EnumUserNotificationCategoryFilter, {nullable:true})
    category?: InstanceType<typeof EnumUserNotificationCategoryFilter>;
    @Field(() => BoolFilter, {nullable:true})
    isRead?: InstanceType<typeof BoolFilter>;
    @Field(() => BoolFilter, {nullable:true})
    isCleared?: InstanceType<typeof BoolFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    deepLink?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    fcmToken?: InstanceType<typeof StringNullableFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
}

@ObjectType()
export class UserNotification {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    title!: string;
    @Field(() => String, {nullable:false})
    subtitle!: string;
    @Field(() => String, {nullable:false})
    content!: string;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => UserNotificationCategory, {nullable:false})
    category!: keyof typeof UserNotificationCategory;
    @Field(() => Boolean, {nullable:false,defaultValue:false})
    isRead!: boolean;
    @Field(() => Boolean, {nullable:false,defaultValue:false})
    isCleared!: boolean;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => String, {nullable:true})
    deepLink!: string | null;
    @Field(() => String, {nullable:true})
    fcmToken!: string | null;
    @Field(() => User, {nullable:false})
    user?: InstanceType<typeof User>;
}

@ObjectType()
export class AggregateWithdrawalRequest {
    @Field(() => WithdrawalRequestCountAggregate, {nullable:true})
    _count?: InstanceType<typeof WithdrawalRequestCountAggregate>;
    @Field(() => WithdrawalRequestAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof WithdrawalRequestAvgAggregate>;
    @Field(() => WithdrawalRequestSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof WithdrawalRequestSumAggregate>;
    @Field(() => WithdrawalRequestMinAggregate, {nullable:true})
    _min?: InstanceType<typeof WithdrawalRequestMinAggregate>;
    @Field(() => WithdrawalRequestMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof WithdrawalRequestMaxAggregate>;
}

@ArgsType()
export class CreateManyWithdrawalRequestArgs {
    @Field(() => [WithdrawalRequestCreateManyInput], {nullable:false})
    @Type(() => WithdrawalRequestCreateManyInput)
    data!: Array<WithdrawalRequestCreateManyInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneWithdrawalRequestArgs {
    @Field(() => WithdrawalRequestCreateInput, {nullable:false})
    @Type(() => WithdrawalRequestCreateInput)
    data!: InstanceType<typeof WithdrawalRequestCreateInput>;
}

@ArgsType()
export class DeleteManyWithdrawalRequestArgs {
    @Field(() => WithdrawalRequestWhereInput, {nullable:true})
    @Type(() => WithdrawalRequestWhereInput)
    where?: InstanceType<typeof WithdrawalRequestWhereInput>;
}

@ArgsType()
export class DeleteOneWithdrawalRequestArgs {
    @Field(() => WithdrawalRequestWhereUniqueInput, {nullable:false})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    where!: Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstWithdrawalRequestOrThrowArgs {
    @Field(() => WithdrawalRequestWhereInput, {nullable:true})
    @Type(() => WithdrawalRequestWhereInput)
    where?: InstanceType<typeof WithdrawalRequestWhereInput>;
    @Field(() => [WithdrawalRequestOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<WithdrawalRequestOrderByWithRelationInput>;
    @Field(() => WithdrawalRequestWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [WithdrawalRequestScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof WithdrawalRequestScalarFieldEnum>;
}

@ArgsType()
export class FindFirstWithdrawalRequestArgs {
    @Field(() => WithdrawalRequestWhereInput, {nullable:true})
    @Type(() => WithdrawalRequestWhereInput)
    where?: InstanceType<typeof WithdrawalRequestWhereInput>;
    @Field(() => [WithdrawalRequestOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<WithdrawalRequestOrderByWithRelationInput>;
    @Field(() => WithdrawalRequestWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [WithdrawalRequestScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof WithdrawalRequestScalarFieldEnum>;
}

@ArgsType()
export class FindManyWithdrawalRequestArgs {
    @Field(() => WithdrawalRequestWhereInput, {nullable:true})
    @Type(() => WithdrawalRequestWhereInput)
    where?: InstanceType<typeof WithdrawalRequestWhereInput>;
    @Field(() => [WithdrawalRequestOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<WithdrawalRequestOrderByWithRelationInput>;
    @Field(() => WithdrawalRequestWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => [WithdrawalRequestScalarFieldEnum], {nullable:true})
    distinct?: Array<keyof typeof WithdrawalRequestScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueWithdrawalRequestOrThrowArgs {
    @Field(() => WithdrawalRequestWhereUniqueInput, {nullable:false})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    where!: Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueWithdrawalRequestArgs {
    @Field(() => WithdrawalRequestWhereUniqueInput, {nullable:false})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    where!: Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpdateManyWithdrawalRequestArgs {
    @Field(() => WithdrawalRequestUpdateManyMutationInput, {nullable:false})
    @Type(() => WithdrawalRequestUpdateManyMutationInput)
    data!: InstanceType<typeof WithdrawalRequestUpdateManyMutationInput>;
    @Field(() => WithdrawalRequestWhereInput, {nullable:true})
    @Type(() => WithdrawalRequestWhereInput)
    where?: InstanceType<typeof WithdrawalRequestWhereInput>;
}

@ArgsType()
export class UpdateOneWithdrawalRequestArgs {
    @Field(() => WithdrawalRequestUpdateInput, {nullable:false})
    @Type(() => WithdrawalRequestUpdateInput)
    data!: InstanceType<typeof WithdrawalRequestUpdateInput>;
    @Field(() => WithdrawalRequestWhereUniqueInput, {nullable:false})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    where!: Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneWithdrawalRequestArgs {
    @Field(() => WithdrawalRequestWhereUniqueInput, {nullable:false})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    where!: Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>;
    @Field(() => WithdrawalRequestCreateInput, {nullable:false})
    @Type(() => WithdrawalRequestCreateInput)
    create!: InstanceType<typeof WithdrawalRequestCreateInput>;
    @Field(() => WithdrawalRequestUpdateInput, {nullable:false})
    @Type(() => WithdrawalRequestUpdateInput)
    update!: InstanceType<typeof WithdrawalRequestUpdateInput>;
}

@ArgsType()
export class WithdrawalRequestAggregateArgs {
    @Field(() => WithdrawalRequestWhereInput, {nullable:true})
    @Type(() => WithdrawalRequestWhereInput)
    where?: InstanceType<typeof WithdrawalRequestWhereInput>;
    @Field(() => [WithdrawalRequestOrderByWithRelationInput], {nullable:true})
    orderBy?: Array<WithdrawalRequestOrderByWithRelationInput>;
    @Field(() => WithdrawalRequestWhereUniqueInput, {nullable:true})
    cursor?: Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => WithdrawalRequestCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof WithdrawalRequestCountAggregateInput>;
    @Field(() => WithdrawalRequestAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof WithdrawalRequestAvgAggregateInput>;
    @Field(() => WithdrawalRequestSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof WithdrawalRequestSumAggregateInput>;
    @Field(() => WithdrawalRequestMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof WithdrawalRequestMinAggregateInput>;
    @Field(() => WithdrawalRequestMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof WithdrawalRequestMaxAggregateInput>;
}

@InputType()
export class WithdrawalRequestAvgAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    transactionId?: true;
}

@ObjectType()
export class WithdrawalRequestAvgAggregate {
    @Field(() => Float, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => Float, {nullable:true})
    transactionId?: number;
}

@InputType()
export class WithdrawalRequestAvgOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionId?: keyof typeof SortOrder;
}

@InputType()
export class WithdrawalRequestCountAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    proofUrl?: true;
    @Field(() => Boolean, {nullable:true})
    proofDescription?: true;
    @Field(() => Boolean, {nullable:true})
    transactionId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
    @Field(() => Boolean, {nullable:true})
    _all?: true;
}

@ObjectType()
export class WithdrawalRequestCountAggregate {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => Int, {nullable:false})
    userId!: number;
    @Field(() => Int, {nullable:false})
    amount!: number;
    @Field(() => Int, {nullable:false})
    status!: number;
    @Field(() => Int, {nullable:false})
    proofUrl!: number;
    @Field(() => Int, {nullable:false})
    proofDescription!: number;
    @Field(() => Int, {nullable:false})
    transactionId!: number;
    @Field(() => Int, {nullable:false})
    createdAt!: number;
    @Field(() => Int, {nullable:false})
    updatedAt!: number;
    @Field(() => Int, {nullable:false})
    _all!: number;
}

@InputType()
export class WithdrawalRequestCountOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    proofUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    proofDescription?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class WithdrawalRequestCreateManyUserInputEnvelope {
    @Field(() => [WithdrawalRequestCreateManyUserInput], {nullable:false})
    @Type(() => WithdrawalRequestCreateManyUserInput)
    data!: Array<WithdrawalRequestCreateManyUserInput>;
    @Field(() => Boolean, {nullable:true})
    skipDuplicates?: boolean;
}

@InputType()
export class WithdrawalRequestCreateManyUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @HideField()
    status!: keyof typeof TransactionStatus;
    @HideField()
    proofUrl?: string;
    @HideField()
    proofDescription?: string;
    @HideField()
    transactionId?: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class WithdrawalRequestCreateManyInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @HideField()
    status!: keyof typeof TransactionStatus;
    @HideField()
    proofUrl?: string;
    @HideField()
    proofDescription?: string;
    @HideField()
    transactionId?: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
}

@InputType()
export class WithdrawalRequestCreateNestedManyWithoutUserInput {
    @Field(() => [WithdrawalRequestCreateWithoutUserInput], {nullable:true})
    @Type(() => WithdrawalRequestCreateWithoutUserInput)
    create?: Array<WithdrawalRequestCreateWithoutUserInput>;
    @Field(() => [WithdrawalRequestCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => WithdrawalRequestCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<WithdrawalRequestCreateOrConnectWithoutUserInput>;
    @Field(() => WithdrawalRequestCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => WithdrawalRequestCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof WithdrawalRequestCreateManyUserInputEnvelope>;
    @Field(() => [WithdrawalRequestWhereUniqueInput], {nullable:true})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>>;
}

@InputType()
export class WithdrawalRequestCreateNestedOneWithoutTransactionInput {
    @Field(() => WithdrawalRequestCreateWithoutTransactionInput, {nullable:true})
    @Type(() => WithdrawalRequestCreateWithoutTransactionInput)
    create?: InstanceType<typeof WithdrawalRequestCreateWithoutTransactionInput>;
    @Field(() => WithdrawalRequestCreateOrConnectWithoutTransactionInput, {nullable:true})
    @Type(() => WithdrawalRequestCreateOrConnectWithoutTransactionInput)
    connectOrCreate?: InstanceType<typeof WithdrawalRequestCreateOrConnectWithoutTransactionInput>;
    @Field(() => WithdrawalRequestWhereUniqueInput, {nullable:true})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    connect?: Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>;
}

@InputType()
export class WithdrawalRequestCreateOrConnectWithoutTransactionInput {
    @Field(() => WithdrawalRequestWhereUniqueInput, {nullable:false})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    where!: Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>;
    @Field(() => WithdrawalRequestCreateWithoutTransactionInput, {nullable:false})
    @Type(() => WithdrawalRequestCreateWithoutTransactionInput)
    create!: InstanceType<typeof WithdrawalRequestCreateWithoutTransactionInput>;
}

@InputType()
export class WithdrawalRequestCreateOrConnectWithoutUserInput {
    @Field(() => WithdrawalRequestWhereUniqueInput, {nullable:false})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    where!: Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>;
    @Field(() => WithdrawalRequestCreateWithoutUserInput, {nullable:false})
    @Type(() => WithdrawalRequestCreateWithoutUserInput)
    create!: InstanceType<typeof WithdrawalRequestCreateWithoutUserInput>;
}

@InputType()
export class WithdrawalRequestCreateWithoutTransactionInput {
    @Field(() => Float, {nullable:false})
    amount!: number;
    @HideField()
    status!: keyof typeof TransactionStatus;
    @HideField()
    proofUrl?: string;
    @HideField()
    proofDescription?: string;
    @HideField()
    transactionId?: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutWithdrawalRequestInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutWithdrawalRequestInput>;
}

@InputType()
export class WithdrawalRequestCreateWithoutUserInput {
    @Field(() => Float, {nullable:false})
    amount!: number;
    @HideField()
    status!: keyof typeof TransactionStatus;
    @HideField()
    proofUrl?: string;
    @HideField()
    proofDescription?: string;
    @HideField()
    transactionId?: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @HideField()
    transaction?: InstanceType<typeof TransactionCreateNestedOneWithoutWithdrawalRequestInput>;
}

@InputType()
export class WithdrawalRequestCreateInput {
    @Field(() => Float, {nullable:false})
    amount!: number;
    @HideField()
    status!: keyof typeof TransactionStatus;
    @HideField()
    proofUrl?: string;
    @HideField()
    proofDescription?: string;
    @HideField()
    transactionId?: number;
    @HideField()
    createdAt?: Date | string;
    @HideField()
    updatedAt?: Date | string;
    @Field(() => UserCreateNestedOneWithoutWithdrawalRequestInput, {nullable:false})
    user!: InstanceType<typeof UserCreateNestedOneWithoutWithdrawalRequestInput>;
    @HideField()
    transaction?: InstanceType<typeof TransactionCreateNestedOneWithoutWithdrawalRequestInput>;
}

@ArgsType()
export class WithdrawalRequestGroupByArgs {
    @Field(() => WithdrawalRequestWhereInput, {nullable:true})
    @Type(() => WithdrawalRequestWhereInput)
    where?: InstanceType<typeof WithdrawalRequestWhereInput>;
    @Field(() => [WithdrawalRequestOrderByWithAggregationInput], {nullable:true})
    orderBy?: Array<WithdrawalRequestOrderByWithAggregationInput>;
    @Field(() => [WithdrawalRequestScalarFieldEnum], {nullable:false})
    by!: Array<keyof typeof WithdrawalRequestScalarFieldEnum>;
    @Field(() => WithdrawalRequestScalarWhereWithAggregatesInput, {nullable:true})
    having?: InstanceType<typeof WithdrawalRequestScalarWhereWithAggregatesInput>;
    @Field(() => Int, {nullable:true})
    take?: number;
    @Field(() => Int, {nullable:true})
    skip?: number;
    @Field(() => WithdrawalRequestCountAggregateInput, {nullable:true})
    _count?: InstanceType<typeof WithdrawalRequestCountAggregateInput>;
    @Field(() => WithdrawalRequestAvgAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof WithdrawalRequestAvgAggregateInput>;
    @Field(() => WithdrawalRequestSumAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof WithdrawalRequestSumAggregateInput>;
    @Field(() => WithdrawalRequestMinAggregateInput, {nullable:true})
    _min?: InstanceType<typeof WithdrawalRequestMinAggregateInput>;
    @Field(() => WithdrawalRequestMaxAggregateInput, {nullable:true})
    _max?: InstanceType<typeof WithdrawalRequestMaxAggregateInput>;
}

@ObjectType()
export class WithdrawalRequestGroupBy {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @Field(() => String, {nullable:true})
    proofDescription?: string;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => Date, {nullable:false})
    createdAt!: Date | string;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date | string;
    @Field(() => WithdrawalRequestCountAggregate, {nullable:true})
    _count?: InstanceType<typeof WithdrawalRequestCountAggregate>;
    @Field(() => WithdrawalRequestAvgAggregate, {nullable:true})
    _avg?: InstanceType<typeof WithdrawalRequestAvgAggregate>;
    @Field(() => WithdrawalRequestSumAggregate, {nullable:true})
    _sum?: InstanceType<typeof WithdrawalRequestSumAggregate>;
    @Field(() => WithdrawalRequestMinAggregate, {nullable:true})
    _min?: InstanceType<typeof WithdrawalRequestMinAggregate>;
    @Field(() => WithdrawalRequestMaxAggregate, {nullable:true})
    _max?: InstanceType<typeof WithdrawalRequestMaxAggregate>;
}

@InputType()
export class WithdrawalRequestListRelationFilter {
    @Field(() => WithdrawalRequestWhereInput, {nullable:true})
    every?: InstanceType<typeof WithdrawalRequestWhereInput>;
    @Field(() => WithdrawalRequestWhereInput, {nullable:true})
    some?: InstanceType<typeof WithdrawalRequestWhereInput>;
    @Field(() => WithdrawalRequestWhereInput, {nullable:true})
    none?: InstanceType<typeof WithdrawalRequestWhereInput>;
}

@InputType()
export class WithdrawalRequestMaxAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    proofUrl?: true;
    @Field(() => Boolean, {nullable:true})
    proofDescription?: true;
    @Field(() => Boolean, {nullable:true})
    transactionId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class WithdrawalRequestMaxAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => TransactionStatus, {nullable:true})
    status?: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @Field(() => String, {nullable:true})
    proofDescription?: string;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class WithdrawalRequestMaxOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    proofUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    proofDescription?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class WithdrawalRequestMinAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    userId?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    status?: true;
    @Field(() => Boolean, {nullable:true})
    proofUrl?: true;
    @Field(() => Boolean, {nullable:true})
    proofDescription?: true;
    @Field(() => Boolean, {nullable:true})
    transactionId?: true;
    @Field(() => Boolean, {nullable:true})
    createdAt?: true;
    @Field(() => Boolean, {nullable:true})
    updatedAt?: true;
}

@ObjectType()
export class WithdrawalRequestMinAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:true})
    userId?: string;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => TransactionStatus, {nullable:true})
    status?: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @Field(() => String, {nullable:true})
    proofDescription?: string;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class WithdrawalRequestMinOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    proofUrl?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    proofDescription?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class WithdrawalRequestNullableRelationFilter {
    @Field(() => WithdrawalRequestWhereInput, {nullable:true})
    is?: InstanceType<typeof WithdrawalRequestWhereInput>;
    @Field(() => WithdrawalRequestWhereInput, {nullable:true})
    isNot?: InstanceType<typeof WithdrawalRequestWhereInput>;
}

@InputType()
export class WithdrawalRequestOrderByRelationAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    _count?: keyof typeof SortOrder;
}

@InputType()
export class WithdrawalRequestOrderByWithAggregationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    proofUrl?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    proofDescription?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    transactionId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => WithdrawalRequestCountOrderByAggregateInput, {nullable:true})
    _count?: InstanceType<typeof WithdrawalRequestCountOrderByAggregateInput>;
    @Field(() => WithdrawalRequestAvgOrderByAggregateInput, {nullable:true})
    _avg?: InstanceType<typeof WithdrawalRequestAvgOrderByAggregateInput>;
    @Field(() => WithdrawalRequestMaxOrderByAggregateInput, {nullable:true})
    _max?: InstanceType<typeof WithdrawalRequestMaxOrderByAggregateInput>;
    @Field(() => WithdrawalRequestMinOrderByAggregateInput, {nullable:true})
    _min?: InstanceType<typeof WithdrawalRequestMinOrderByAggregateInput>;
    @Field(() => WithdrawalRequestSumOrderByAggregateInput, {nullable:true})
    _sum?: InstanceType<typeof WithdrawalRequestSumOrderByAggregateInput>;
}

@InputType()
export class WithdrawalRequestOrderByWithRelationInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    userId?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    status?: keyof typeof SortOrder;
    @Field(() => SortOrderInput, {nullable:true})
    proofUrl?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    proofDescription?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrderInput, {nullable:true})
    transactionId?: InstanceType<typeof SortOrderInput>;
    @Field(() => SortOrder, {nullable:true})
    createdAt?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    updatedAt?: keyof typeof SortOrder;
    @Field(() => UserOrderByWithRelationInput, {nullable:true})
    user?: InstanceType<typeof UserOrderByWithRelationInput>;
    @Field(() => TransactionOrderByWithRelationInput, {nullable:true})
    transaction?: InstanceType<typeof TransactionOrderByWithRelationInput>;
}

@InputType()
export class WithdrawalRequestScalarWhereWithAggregatesInput {
    @Field(() => [WithdrawalRequestScalarWhereWithAggregatesInput], {nullable:true})
    AND?: Array<WithdrawalRequestScalarWhereWithAggregatesInput>;
    @Field(() => [WithdrawalRequestScalarWhereWithAggregatesInput], {nullable:true})
    OR?: Array<WithdrawalRequestScalarWhereWithAggregatesInput>;
    @Field(() => [WithdrawalRequestScalarWhereWithAggregatesInput], {nullable:true})
    NOT?: Array<WithdrawalRequestScalarWhereWithAggregatesInput>;
    @Field(() => IntWithAggregatesFilter, {nullable:true})
    id?: InstanceType<typeof IntWithAggregatesFilter>;
    @Field(() => StringWithAggregatesFilter, {nullable:true})
    userId?: InstanceType<typeof StringWithAggregatesFilter>;
    @Field(() => FloatWithAggregatesFilter, {nullable:true})
    amount?: InstanceType<typeof FloatWithAggregatesFilter>;
    @Field(() => EnumTransactionStatusWithAggregatesFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusWithAggregatesFilter>;
    @Field(() => StringNullableWithAggregatesFilter, {nullable:true})
    proofUrl?: InstanceType<typeof StringNullableWithAggregatesFilter>;
    @Field(() => StringNullableWithAggregatesFilter, {nullable:true})
    proofDescription?: InstanceType<typeof StringNullableWithAggregatesFilter>;
    @Field(() => IntNullableWithAggregatesFilter, {nullable:true})
    transactionId?: InstanceType<typeof IntNullableWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
    @Field(() => DateTimeWithAggregatesFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
}

@InputType()
export class WithdrawalRequestScalarWhereInput {
    @Field(() => [WithdrawalRequestScalarWhereInput], {nullable:true})
    AND?: Array<WithdrawalRequestScalarWhereInput>;
    @Field(() => [WithdrawalRequestScalarWhereInput], {nullable:true})
    OR?: Array<WithdrawalRequestScalarWhereInput>;
    @Field(() => [WithdrawalRequestScalarWhereInput], {nullable:true})
    NOT?: Array<WithdrawalRequestScalarWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @Field(() => EnumTransactionStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    proofUrl?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    proofDescription?: InstanceType<typeof StringNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    transactionId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class WithdrawalRequestSumAggregateInput {
    @Field(() => Boolean, {nullable:true})
    id?: true;
    @Field(() => Boolean, {nullable:true})
    amount?: true;
    @Field(() => Boolean, {nullable:true})
    transactionId?: true;
}

@ObjectType()
export class WithdrawalRequestSumAggregate {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:true})
    amount?: number;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
}

@InputType()
export class WithdrawalRequestSumOrderByAggregateInput {
    @Field(() => SortOrder, {nullable:true})
    id?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    amount?: keyof typeof SortOrder;
    @Field(() => SortOrder, {nullable:true})
    transactionId?: keyof typeof SortOrder;
}

@InputType()
export class WithdrawalRequestUncheckedCreateNestedManyWithoutUserInput {
    @Field(() => [WithdrawalRequestCreateWithoutUserInput], {nullable:true})
    @Type(() => WithdrawalRequestCreateWithoutUserInput)
    create?: Array<WithdrawalRequestCreateWithoutUserInput>;
    @Field(() => [WithdrawalRequestCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => WithdrawalRequestCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<WithdrawalRequestCreateOrConnectWithoutUserInput>;
    @Field(() => WithdrawalRequestCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => WithdrawalRequestCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof WithdrawalRequestCreateManyUserInputEnvelope>;
    @Field(() => [WithdrawalRequestWhereUniqueInput], {nullable:true})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>>;
}

@InputType()
export class WithdrawalRequestUncheckedCreateWithoutTransactionInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @Field(() => String, {nullable:true})
    proofDescription?: string;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
}

@InputType()
export class WithdrawalRequestUncheckedCreateWithoutUserInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @Field(() => String, {nullable:true})
    proofDescription?: string;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => TransactionUncheckedCreateNestedOneWithoutWithdrawalRequestInput, {nullable:true})
    transaction?: InstanceType<typeof TransactionUncheckedCreateNestedOneWithoutWithdrawalRequestInput>;
}

@InputType()
export class WithdrawalRequestUncheckedCreateInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:true})
    proofUrl?: string;
    @Field(() => String, {nullable:true})
    proofDescription?: string;
    @Field(() => Int, {nullable:true})
    transactionId?: number;
    @Field(() => Date, {nullable:true})
    createdAt?: Date | string;
    @Field(() => Date, {nullable:true})
    updatedAt?: Date | string;
    @Field(() => TransactionUncheckedCreateNestedOneWithoutWithdrawalRequestInput, {nullable:true})
    transaction?: InstanceType<typeof TransactionUncheckedCreateNestedOneWithoutWithdrawalRequestInput>;
}

@InputType()
export class WithdrawalRequestUncheckedUpdateManyWithoutUserNestedInput {
    @Field(() => [WithdrawalRequestCreateWithoutUserInput], {nullable:true})
    @Type(() => WithdrawalRequestCreateWithoutUserInput)
    create?: Array<WithdrawalRequestCreateWithoutUserInput>;
    @Field(() => [WithdrawalRequestCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => WithdrawalRequestCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<WithdrawalRequestCreateOrConnectWithoutUserInput>;
    @Field(() => [WithdrawalRequestUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => WithdrawalRequestUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<WithdrawalRequestUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => WithdrawalRequestCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => WithdrawalRequestCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof WithdrawalRequestCreateManyUserInputEnvelope>;
    @Field(() => [WithdrawalRequestWhereUniqueInput], {nullable:true})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    set?: Array<Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>>;
    @Field(() => [WithdrawalRequestWhereUniqueInput], {nullable:true})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>>;
    @Field(() => [WithdrawalRequestWhereUniqueInput], {nullable:true})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>>;
    @Field(() => [WithdrawalRequestWhereUniqueInput], {nullable:true})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>>;
    @Field(() => [WithdrawalRequestUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => WithdrawalRequestUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<WithdrawalRequestUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [WithdrawalRequestUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => WithdrawalRequestUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<WithdrawalRequestUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [WithdrawalRequestScalarWhereInput], {nullable:true})
    @Type(() => WithdrawalRequestScalarWhereInput)
    deleteMany?: Array<WithdrawalRequestScalarWhereInput>;
}

@InputType()
export class WithdrawalRequestUncheckedUpdateManyWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofDescription?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    transactionId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class WithdrawalRequestUncheckedUpdateManyInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofDescription?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    transactionId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class WithdrawalRequestUncheckedUpdateWithoutTransactionInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofDescription?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    transactionId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class WithdrawalRequestUncheckedUpdateWithoutUserInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofDescription?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    transactionId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => TransactionUncheckedUpdateOneWithoutWithdrawalRequestNestedInput, {nullable:true})
    transaction?: InstanceType<typeof TransactionUncheckedUpdateOneWithoutWithdrawalRequestNestedInput>;
}

@InputType()
export class WithdrawalRequestUncheckedUpdateInput {
    @Field(() => IntFieldUpdateOperationsInput, {nullable:true})
    id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
    @Field(() => StringFieldUpdateOperationsInput, {nullable:true})
    userId?: InstanceType<typeof StringFieldUpdateOperationsInput>;
    @Field(() => FloatFieldUpdateOperationsInput, {nullable:true})
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofDescription?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableIntFieldUpdateOperationsInput, {nullable:true})
    transactionId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => DateTimeFieldUpdateOperationsInput, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @Field(() => TransactionUncheckedUpdateOneWithoutWithdrawalRequestNestedInput, {nullable:true})
    transaction?: InstanceType<typeof TransactionUncheckedUpdateOneWithoutWithdrawalRequestNestedInput>;
}

@InputType()
export class WithdrawalRequestUpdateManyMutationInput {
    @HideField()
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofDescription?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    transactionId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
}

@InputType()
export class WithdrawalRequestUpdateManyWithWhereWithoutUserInput {
    @Field(() => WithdrawalRequestScalarWhereInput, {nullable:false})
    @Type(() => WithdrawalRequestScalarWhereInput)
    where!: InstanceType<typeof WithdrawalRequestScalarWhereInput>;
    @Field(() => WithdrawalRequestUpdateManyMutationInput, {nullable:false})
    @Type(() => WithdrawalRequestUpdateManyMutationInput)
    data!: InstanceType<typeof WithdrawalRequestUpdateManyMutationInput>;
}

@InputType()
export class WithdrawalRequestUpdateManyWithoutUserNestedInput {
    @Field(() => [WithdrawalRequestCreateWithoutUserInput], {nullable:true})
    @Type(() => WithdrawalRequestCreateWithoutUserInput)
    create?: Array<WithdrawalRequestCreateWithoutUserInput>;
    @Field(() => [WithdrawalRequestCreateOrConnectWithoutUserInput], {nullable:true})
    @Type(() => WithdrawalRequestCreateOrConnectWithoutUserInput)
    connectOrCreate?: Array<WithdrawalRequestCreateOrConnectWithoutUserInput>;
    @Field(() => [WithdrawalRequestUpsertWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => WithdrawalRequestUpsertWithWhereUniqueWithoutUserInput)
    upsert?: Array<WithdrawalRequestUpsertWithWhereUniqueWithoutUserInput>;
    @Field(() => WithdrawalRequestCreateManyUserInputEnvelope, {nullable:true})
    @Type(() => WithdrawalRequestCreateManyUserInputEnvelope)
    createMany?: InstanceType<typeof WithdrawalRequestCreateManyUserInputEnvelope>;
    @Field(() => [WithdrawalRequestWhereUniqueInput], {nullable:true})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    set?: Array<Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>>;
    @Field(() => [WithdrawalRequestWhereUniqueInput], {nullable:true})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    disconnect?: Array<Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>>;
    @Field(() => [WithdrawalRequestWhereUniqueInput], {nullable:true})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    delete?: Array<Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>>;
    @Field(() => [WithdrawalRequestWhereUniqueInput], {nullable:true})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    connect?: Array<Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>>;
    @Field(() => [WithdrawalRequestUpdateWithWhereUniqueWithoutUserInput], {nullable:true})
    @Type(() => WithdrawalRequestUpdateWithWhereUniqueWithoutUserInput)
    update?: Array<WithdrawalRequestUpdateWithWhereUniqueWithoutUserInput>;
    @Field(() => [WithdrawalRequestUpdateManyWithWhereWithoutUserInput], {nullable:true})
    @Type(() => WithdrawalRequestUpdateManyWithWhereWithoutUserInput)
    updateMany?: Array<WithdrawalRequestUpdateManyWithWhereWithoutUserInput>;
    @Field(() => [WithdrawalRequestScalarWhereInput], {nullable:true})
    @Type(() => WithdrawalRequestScalarWhereInput)
    deleteMany?: Array<WithdrawalRequestScalarWhereInput>;
}

@InputType()
export class WithdrawalRequestUpdateOneWithoutTransactionNestedInput {
    @Field(() => WithdrawalRequestCreateWithoutTransactionInput, {nullable:true})
    @Type(() => WithdrawalRequestCreateWithoutTransactionInput)
    create?: InstanceType<typeof WithdrawalRequestCreateWithoutTransactionInput>;
    @Field(() => WithdrawalRequestCreateOrConnectWithoutTransactionInput, {nullable:true})
    @Type(() => WithdrawalRequestCreateOrConnectWithoutTransactionInput)
    connectOrCreate?: InstanceType<typeof WithdrawalRequestCreateOrConnectWithoutTransactionInput>;
    @Field(() => WithdrawalRequestUpsertWithoutTransactionInput, {nullable:true})
    @Type(() => WithdrawalRequestUpsertWithoutTransactionInput)
    upsert?: InstanceType<typeof WithdrawalRequestUpsertWithoutTransactionInput>;
    @Field(() => WithdrawalRequestWhereInput, {nullable:true})
    @Type(() => WithdrawalRequestWhereInput)
    disconnect?: InstanceType<typeof WithdrawalRequestWhereInput>;
    @Field(() => WithdrawalRequestWhereInput, {nullable:true})
    @Type(() => WithdrawalRequestWhereInput)
    delete?: InstanceType<typeof WithdrawalRequestWhereInput>;
    @Field(() => WithdrawalRequestWhereUniqueInput, {nullable:true})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    connect?: Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>;
    @Field(() => WithdrawalRequestUpdateToOneWithWhereWithoutTransactionInput, {nullable:true})
    @Type(() => WithdrawalRequestUpdateToOneWithWhereWithoutTransactionInput)
    update?: InstanceType<typeof WithdrawalRequestUpdateToOneWithWhereWithoutTransactionInput>;
}

@InputType()
export class WithdrawalRequestUpdateToOneWithWhereWithoutTransactionInput {
    @Field(() => WithdrawalRequestWhereInput, {nullable:true})
    @Type(() => WithdrawalRequestWhereInput)
    where?: InstanceType<typeof WithdrawalRequestWhereInput>;
    @Field(() => WithdrawalRequestUpdateWithoutTransactionInput, {nullable:false})
    @Type(() => WithdrawalRequestUpdateWithoutTransactionInput)
    data!: InstanceType<typeof WithdrawalRequestUpdateWithoutTransactionInput>;
}

@InputType()
export class WithdrawalRequestUpdateWithWhereUniqueWithoutUserInput {
    @Field(() => WithdrawalRequestWhereUniqueInput, {nullable:false})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    where!: Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>;
    @Field(() => WithdrawalRequestUpdateWithoutUserInput, {nullable:false})
    @Type(() => WithdrawalRequestUpdateWithoutUserInput)
    data!: InstanceType<typeof WithdrawalRequestUpdateWithoutUserInput>;
}

@InputType()
export class WithdrawalRequestUpdateWithoutTransactionInput {
    @HideField()
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofDescription?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    transactionId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutWithdrawalRequestNestedInput>;
}

@InputType()
export class WithdrawalRequestUpdateWithoutUserInput {
    @HideField()
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofDescription?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    transactionId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    transaction?: InstanceType<typeof TransactionUpdateOneWithoutWithdrawalRequestNestedInput>;
}

@InputType()
export class WithdrawalRequestUpdateInput {
    @HideField()
    amount?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
    @Field(() => EnumTransactionStatusFieldUpdateOperationsInput, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofUrl?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @Field(() => NullableStringFieldUpdateOperationsInput, {nullable:true})
    proofDescription?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
    @HideField()
    transactionId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
    @HideField()
    createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
    @HideField()
    user?: InstanceType<typeof UserUpdateOneRequiredWithoutWithdrawalRequestNestedInput>;
    @HideField()
    transaction?: InstanceType<typeof TransactionUpdateOneWithoutWithdrawalRequestNestedInput>;
}

@InputType()
export class WithdrawalRequestUpsertWithWhereUniqueWithoutUserInput {
    @Field(() => WithdrawalRequestWhereUniqueInput, {nullable:false})
    @Type(() => WithdrawalRequestWhereUniqueInput)
    where!: Prisma.AtLeast<WithdrawalRequestWhereUniqueInput, 'id'>;
    @Field(() => WithdrawalRequestUpdateWithoutUserInput, {nullable:false})
    @Type(() => WithdrawalRequestUpdateWithoutUserInput)
    update!: InstanceType<typeof WithdrawalRequestUpdateWithoutUserInput>;
    @Field(() => WithdrawalRequestCreateWithoutUserInput, {nullable:false})
    @Type(() => WithdrawalRequestCreateWithoutUserInput)
    create!: InstanceType<typeof WithdrawalRequestCreateWithoutUserInput>;
}

@InputType()
export class WithdrawalRequestUpsertWithoutTransactionInput {
    @Field(() => WithdrawalRequestUpdateWithoutTransactionInput, {nullable:false})
    @Type(() => WithdrawalRequestUpdateWithoutTransactionInput)
    update!: InstanceType<typeof WithdrawalRequestUpdateWithoutTransactionInput>;
    @Field(() => WithdrawalRequestCreateWithoutTransactionInput, {nullable:false})
    @Type(() => WithdrawalRequestCreateWithoutTransactionInput)
    create!: InstanceType<typeof WithdrawalRequestCreateWithoutTransactionInput>;
    @Field(() => WithdrawalRequestWhereInput, {nullable:true})
    @Type(() => WithdrawalRequestWhereInput)
    where?: InstanceType<typeof WithdrawalRequestWhereInput>;
}

@InputType()
export class WithdrawalRequestWhereUniqueInput {
    @Field(() => Int, {nullable:true})
    id?: number;
    @Field(() => [WithdrawalRequestWhereInput], {nullable:true})
    AND?: Array<WithdrawalRequestWhereInput>;
    @Field(() => [WithdrawalRequestWhereInput], {nullable:true})
    OR?: Array<WithdrawalRequestWhereInput>;
    @Field(() => [WithdrawalRequestWhereInput], {nullable:true})
    NOT?: Array<WithdrawalRequestWhereInput>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @Field(() => EnumTransactionStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    proofUrl?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    proofDescription?: InstanceType<typeof StringNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    transactionId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
    @Field(() => TransactionNullableRelationFilter, {nullable:true})
    transaction?: InstanceType<typeof TransactionNullableRelationFilter>;
}

@InputType()
export class WithdrawalRequestWhereInput {
    @Field(() => [WithdrawalRequestWhereInput], {nullable:true})
    AND?: Array<WithdrawalRequestWhereInput>;
    @Field(() => [WithdrawalRequestWhereInput], {nullable:true})
    OR?: Array<WithdrawalRequestWhereInput>;
    @Field(() => [WithdrawalRequestWhereInput], {nullable:true})
    NOT?: Array<WithdrawalRequestWhereInput>;
    @Field(() => IntFilter, {nullable:true})
    id?: InstanceType<typeof IntFilter>;
    @Field(() => StringFilter, {nullable:true})
    userId?: InstanceType<typeof StringFilter>;
    @Field(() => FloatFilter, {nullable:true})
    amount?: InstanceType<typeof FloatFilter>;
    @Field(() => EnumTransactionStatusFilter, {nullable:true})
    status?: InstanceType<typeof EnumTransactionStatusFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    proofUrl?: InstanceType<typeof StringNullableFilter>;
    @Field(() => StringNullableFilter, {nullable:true})
    proofDescription?: InstanceType<typeof StringNullableFilter>;
    @Field(() => IntNullableFilter, {nullable:true})
    transactionId?: InstanceType<typeof IntNullableFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    createdAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => DateTimeFilter, {nullable:true})
    updatedAt?: InstanceType<typeof DateTimeFilter>;
    @Field(() => UserRelationFilter, {nullable:true})
    user?: InstanceType<typeof UserRelationFilter>;
    @Field(() => TransactionNullableRelationFilter, {nullable:true})
    transaction?: InstanceType<typeof TransactionNullableRelationFilter>;
}

@ObjectType()
export class WithdrawalRequest {
    @Field(() => Int, {nullable:false})
    id!: number;
    @Field(() => String, {nullable:false})
    userId!: string;
    @Field(() => Float, {nullable:false})
    amount!: number;
    @Field(() => TransactionStatus, {nullable:false})
    status!: keyof typeof TransactionStatus;
    @Field(() => String, {nullable:true})
    proofUrl!: string | null;
    @Field(() => String, {nullable:true})
    proofDescription!: string | null;
    @Field(() => Int, {nullable:true})
    transactionId!: number | null;
    @Field(() => Date, {nullable:false})
    createdAt!: Date;
    @Field(() => Date, {nullable:false})
    updatedAt!: Date;
    @Field(() => User, {nullable:false})
    user?: InstanceType<typeof User>;
    @Field(() => Transaction, {nullable:true})
    transaction?: InstanceType<typeof Transaction> | null;
}
